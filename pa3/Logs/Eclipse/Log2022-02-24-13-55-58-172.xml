<Events startTimestamp="1645728958172" logVersion="1.0.0.202009141527">
  <Command __id="1" _type="MoveCaretCommand" caretOffset="850" date="Thu Feb 24 13:56:00 EST 2022" docOffset="1007" starttimestamp="1645728958172" timestamp="2397" />
  <Command __id="2" _type="ShellCommand" date="Thu Feb 24 13:57:04 EST 2022" starttimestamp="1645728958172" timestamp="66084" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="0" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 13:56:00 EST 2022" docASTNodeCount="163" docActiveCodeLength="1007" docExpressionCount="111" docLength="1007" projectName="pa1" starttimestamp="1645728958172" timestamp="2111">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(1);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			System.exit(0);
		}
	}
}
]]></snapshot>
  </Command>
  <Command __id="4" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 13:59:15 EST 2022" docASTNodeCount="1" docActiveCodeLength="28" docExpressionCount="0" docLength="28" projectName="pa1" starttimestamp="1645728958172" timestamp="197435">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[if (1 == 1) {
	return 1;
}]]></snapshot>
  </Command>
  <Command __id="3" _type="ShellCommand" date="Thu Feb 24 13:59:01 EST 2022" starttimestamp="1645728958172" timestamp="183449" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6" _type="MoveCaretCommand" caretOffset="850" date="Thu Feb 24 13:59:20 EST 2022" docOffset="1007" starttimestamp="1645728958172" timestamp="202477" />
  <Command __id="7" _type="ShellCommand" date="Thu Feb 24 14:00:18 EST 2022" starttimestamp="1645728958172" timestamp="260544" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8" _type="ShellCommand" date="Thu Feb 24 14:00:46 EST 2022" starttimestamp="1645728958172" timestamp="288488" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="9" _type="MoveCaretCommand" caretOffset="840" date="Thu Feb 24 14:00:55 EST 2022" docOffset="997" starttimestamp="1645728958172" timestamp="297068" />
  <Command __id="10" _type="ShellCommand" date="Thu Feb 24 14:01:09 EST 2022" starttimestamp="1645728958172" timestamp="311623" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 13:59:20 EST 2022" docASTNodeCount="163" docActiveCodeLength="1007" docExpressionCount="111" docLength="1007" projectName="pa1" starttimestamp="1645728958172" timestamp="202361">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(1);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			System.exit(0);¶		}¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="11" _type="ShellCommand" date="Thu Feb 24 14:01:16 EST 2022" starttimestamp="1645728958172" timestamp="318019" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="12" _type="EclipseCommand" commandID="org.eclipse.ui.file.properties" date="Thu Feb 24 14:01:16 EST 2022" starttimestamp="1645728958172" timestamp="318044" />
  <Command __id="15" _type="RunCommand" date="Thu Feb 24 14:01:26 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="328128" type="Run" />
  <Command __id="16" _type="RunCommand" date="Thu Feb 24 14:01:26 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="328129" type="Run" />
  <Command __id="17" _type="RunCommand" date="Thu Feb 24 14:01:26 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="328380" type="Run" />
  <Command __id="18" _type="RunCommand" date="Thu Feb 24 14:01:26 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="328381" type="Run" />
  <Command __id="19" _type="MoveCaretCommand" caretOffset="154" date="Thu Feb 24 14:01:36 EST 2022" docOffset="154" starttimestamp="1645728958172" timestamp="337939" />
  <Command __id="20" _type="MoveCaretCommand" caretOffset="145" date="Thu Feb 24 14:01:37 EST 2022" docOffset="145" starttimestamp="1645728958172" timestamp="339566" />
  <Command __id="22" _type="InsertStringCommand" date="Thu Feb 24 14:01:38 EST 2022" starttimestamp="1645728958172" timestamp="339940" timestamp2="339940">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="24" _type="InsertStringCommand" date="Thu Feb 24 14:01:38 EST 2022" starttimestamp="1645728958172" timestamp="340197" timestamp2="340197">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="26" _type="InsertStringCommand" date="Thu Feb 24 14:01:38 EST 2022" starttimestamp="1645728958172" timestamp="340601" timestamp2="340601">
    <data><![CDATA[y]]></data>
  </Command>
  <Command __id="28" _type="InsertStringCommand" date="Thu Feb 24 14:01:38 EST 2022" starttimestamp="1645728958172" timestamp="340674" timestamp2="340674">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="30" _type="InsertStringCommand" date="Thu Feb 24 14:01:39 EST 2022" starttimestamp="1645728958172" timestamp="340851" timestamp2="340851">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="32" _type="InsertStringCommand" date="Thu Feb 24 14:01:39 EST 2022" starttimestamp="1645728958172" timestamp="340967" timestamp2="340967">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="34" _type="InsertStringCommand" date="Thu Feb 24 14:01:39 EST 2022" starttimestamp="1645728958172" timestamp="341086" timestamp2="341086">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="36" _type="InsertStringCommand" date="Thu Feb 24 14:01:39 EST 2022" starttimestamp="1645728958172" timestamp="341715" timestamp2="341715">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="37" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 14:01:42 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="344469" />
  <Command __id="42" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 14:01:43 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="345034" />
  <Command __id="44" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345042" timestamp2="345042">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="46" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345048" timestamp2="345048">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="48" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345055" timestamp2="345055">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="50" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345062" timestamp2="345062">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="52" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345069" timestamp2="345069">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="54" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345074" timestamp2="345074">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="56" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345080" timestamp2="345080">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="58" _type="InsertStringCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345112" timestamp2="345112">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="59" _type="ShellCommand" date="Thu Feb 24 14:01:43 EST 2022" starttimestamp="1645728958172" timestamp="345756" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="13" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:01:20 EST 2022" docASTNodeCount="33" docActiveCodeLength="154" docExpressionCount="13" docLength="154" projectName="pa1" starttimestamp="1645728958172" timestamp="322050">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava;

public class test {
	public static void main(String[] args) {
		String[] b = {"testfile"};
		Compiler a = new Compiler();
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="21" _type="Insert" date="Thu Feb 24 14:01:38 EST 2022" docASTNodeCount="33" docActiveCodeLength="158" docExpressionCount="13" docLength="158" length="4" offset="145" starttimestamp="1645728958172" timestamp="339910">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="23" _type="Insert" date="Thu Feb 24 14:01:38 EST 2022" docASTNodeCount="35" docActiveCodeLength="159" docExpressionCount="14" docLength="159" length="1" offset="149" starttimestamp="1645728958172" timestamp="340194">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="25" _type="Insert" date="Thu Feb 24 14:01:38 EST 2022" docASTNodeCount="35" docActiveCodeLength="160" docExpressionCount="14" docLength="160" length="1" offset="150" starttimestamp="1645728958172" timestamp="340598">
    <text><![CDATA[y]]></text>
  </DocumentChange>
  <DocumentChange __id="27" _type="Insert" date="Thu Feb 24 14:01:38 EST 2022" docASTNodeCount="35" docActiveCodeLength="161" docExpressionCount="14" docLength="161" length="1" offset="151" starttimestamp="1645728958172" timestamp="340671">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="29" _type="Insert" date="Thu Feb 24 14:01:39 EST 2022" docASTNodeCount="35" docActiveCodeLength="162" docExpressionCount="14" docLength="162" length="1" offset="152" starttimestamp="1645728958172" timestamp="340847">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="31" _type="Insert" date="Thu Feb 24 14:01:39 EST 2022" docASTNodeCount="35" docActiveCodeLength="163" docExpressionCount="14" docLength="163" length="1" offset="153" starttimestamp="1645728958172" timestamp="340963">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="33" _type="Insert" date="Thu Feb 24 14:01:39 EST 2022" docASTNodeCount="35" docActiveCodeLength="164" docExpressionCount="14" docLength="164" length="1" offset="154" starttimestamp="1645728958172" timestamp="341081">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="35" _type="Insert" date="Thu Feb 24 14:01:39 EST 2022" docASTNodeCount="35" docActiveCodeLength="165" docExpressionCount="14" docLength="165" length="1" offset="155" starttimestamp="1645728958172" timestamp="341711">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="38" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="37" docActiveCodeLength="166" docExpressionCount="16" docLength="166" length="1" offset="156" starttimestamp="1645728958172" timestamp="344993">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="39" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="37" docActiveCodeLength="167" docExpressionCount="16" docLength="167" length="1" offset="157" starttimestamp="1645728958172" timestamp="345007">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="40" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="37" docActiveCodeLength="168" docExpressionCount="16" docLength="168" length="1" offset="158" starttimestamp="1645728958172" timestamp="345015">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="41" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="38" docActiveCodeLength="169" docExpressionCount="15" docLength="169" length="1" offset="159" starttimestamp="1645728958172" timestamp="345026">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="43" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="40" docActiveCodeLength="170" docExpressionCount="16" docLength="170" length="1" offset="160" starttimestamp="1645728958172" timestamp="345039">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="45" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="40" docActiveCodeLength="171" docExpressionCount="16" docLength="171" length="1" offset="161" starttimestamp="1645728958172" timestamp="345045">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="47" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="40" docActiveCodeLength="172" docExpressionCount="16" docLength="172" length="1" offset="162" starttimestamp="1645728958172" timestamp="345051">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="49" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="40" docActiveCodeLength="173" docExpressionCount="16" docLength="173" length="1" offset="163" starttimestamp="1645728958172" timestamp="345059">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="51" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="40" docActiveCodeLength="174" docExpressionCount="16" docLength="174" length="1" offset="164" starttimestamp="1645728958172" timestamp="345065">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="53" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="40" docActiveCodeLength="175" docExpressionCount="16" docLength="175" length="1" offset="165" starttimestamp="1645728958172" timestamp="345072">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="55" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="40" docActiveCodeLength="176" docExpressionCount="16" docLength="176" length="1" offset="166" starttimestamp="1645728958172" timestamp="345078">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="57" _type="Insert" date="Thu Feb 24 14:01:43 EST 2022" docASTNodeCount="39" docActiveCodeLength="178" docExpressionCount="18" docLength="178" length="2" offset="167" starttimestamp="1645728958172" timestamp="345085">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="61" _type="Delete" date="Thu Feb 24 14:01:50 EST 2022" docASTNodeCount="38" docActiveCodeLength="177" docExpressionCount="17" docLength="177" endLine="6" length="1" offset="167" startLine="6" starttimestamp="1645728958172" timestamp="352466">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="63" _type="Delete" date="Thu Feb 24 14:01:51 EST 2022" docASTNodeCount="38" docActiveCodeLength="176" docExpressionCount="17" docLength="176" endLine="6" length="1" offset="166" startLine="6" starttimestamp="1645728958172" timestamp="352917">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="65" _type="Delete" date="Thu Feb 24 14:01:51 EST 2022" docASTNodeCount="38" docActiveCodeLength="175" docExpressionCount="17" docLength="175" endLine="6" length="1" offset="165" startLine="6" starttimestamp="1645728958172" timestamp="352947">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="67" _type="Delete" date="Thu Feb 24 14:01:51 EST 2022" docASTNodeCount="38" docActiveCodeLength="174" docExpressionCount="17" docLength="174" endLine="6" length="1" offset="164" startLine="6" starttimestamp="1645728958172" timestamp="352982">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="69" _type="Delete" date="Thu Feb 24 14:01:51 EST 2022" docASTNodeCount="38" docActiveCodeLength="173" docExpressionCount="17" docLength="173" endLine="6" length="1" offset="163" startLine="6" starttimestamp="1645728958172" timestamp="353007">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="71" _type="Delete" date="Thu Feb 24 14:01:51 EST 2022" docASTNodeCount="38" docActiveCodeLength="172" docExpressionCount="17" docLength="172" endLine="6" length="1" offset="162" startLine="6" starttimestamp="1645728958172" timestamp="353038">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="73" _type="Delete" date="Thu Feb 24 14:01:51 EST 2022" docASTNodeCount="38" docActiveCodeLength="171" docExpressionCount="17" docLength="171" endLine="6" length="1" offset="161" startLine="6" starttimestamp="1645728958172" timestamp="353210">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="75" _type="Delete" date="Thu Feb 24 14:01:51 EST 2022" docASTNodeCount="38" docActiveCodeLength="170" docExpressionCount="15" docLength="170" endLine="6" length="1" offset="160" startLine="6" starttimestamp="1645728958172" timestamp="353404">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="78" _type="Delete" date="Thu Feb 24 14:01:52 EST 2022" docASTNodeCount="38" docActiveCodeLength="169" docExpressionCount="15" docLength="169" endLine="6" length="1" offset="160" startLine="6" starttimestamp="1645728958172" timestamp="354178">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="80" _type="Delete" date="Thu Feb 24 14:01:52 EST 2022" docASTNodeCount="37" docActiveCodeLength="168" docExpressionCount="16" docLength="168" endLine="6" length="1" offset="159" startLine="6" starttimestamp="1645728958172" timestamp="354326">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="82" _type="Insert" date="Thu Feb 24 14:01:53 EST 2022" docASTNodeCount="37" docActiveCodeLength="169" docExpressionCount="16" docLength="169" length="1" offset="159" starttimestamp="1645728958172" timestamp="355015">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="85" _type="Insert" date="Thu Feb 24 14:01:54 EST 2022" docASTNodeCount="39" docActiveCodeLength="170" docExpressionCount="18" docLength="170" length="1" offset="160" starttimestamp="1645728958172" timestamp="356494">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="86" _type="Insert" date="Thu Feb 24 14:01:54 EST 2022" docASTNodeCount="39" docActiveCodeLength="171" docExpressionCount="18" docLength="171" length="1" offset="161" starttimestamp="1645728958172" timestamp="356608">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="87" _type="Insert" date="Thu Feb 24 14:01:54 EST 2022" docASTNodeCount="39" docActiveCodeLength="172" docExpressionCount="18" docLength="172" length="1" offset="162" starttimestamp="1645728958172" timestamp="356667">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="88" _type="Insert" date="Thu Feb 24 14:01:54 EST 2022" docASTNodeCount="39" docActiveCodeLength="173" docExpressionCount="18" docLength="173" length="1" offset="163" starttimestamp="1645728958172" timestamp="356756">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="89" _type="Insert" date="Thu Feb 24 14:01:55 EST 2022" docASTNodeCount="39" docActiveCodeLength="174" docExpressionCount="18" docLength="174" length="1" offset="164" starttimestamp="1645728958172" timestamp="356844">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="90" _type="Insert" date="Thu Feb 24 14:01:55 EST 2022" docASTNodeCount="39" docActiveCodeLength="175" docExpressionCount="18" docLength="175" length="1" offset="165" starttimestamp="1645728958172" timestamp="356938">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="91" _type="Insert" date="Thu Feb 24 14:01:55 EST 2022" docASTNodeCount="39" docActiveCodeLength="176" docExpressionCount="18" docLength="176" length="1" offset="166" starttimestamp="1645728958172" timestamp="357092">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="92" _type="Insert" date="Thu Feb 24 14:01:55 EST 2022" docASTNodeCount="39" docActiveCodeLength="178" docExpressionCount="18" docLength="178" length="2" offset="167" starttimestamp="1645728958172" timestamp="357546">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="60" _type="ShellCommand" date="Thu Feb 24 14:01:49 EST 2022" starttimestamp="1645728958172" timestamp="351712" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="62" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:50 EST 2022" starttimestamp="1645728958172" timestamp="352469" />
  <Command __id="64" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:51 EST 2022" starttimestamp="1645728958172" timestamp="352919" />
  <Command __id="66" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:51 EST 2022" starttimestamp="1645728958172" timestamp="352949" />
  <Command __id="68" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:51 EST 2022" starttimestamp="1645728958172" timestamp="352986" />
  <Command __id="70" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:51 EST 2022" starttimestamp="1645728958172" timestamp="353009" />
  <Command __id="72" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:51 EST 2022" starttimestamp="1645728958172" timestamp="353039" />
  <Command __id="74" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:51 EST 2022" starttimestamp="1645728958172" timestamp="353213" />
  <Command __id="76" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:51 EST 2022" starttimestamp="1645728958172" timestamp="353406" />
  <Command __id="77" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:01:52 EST 2022" starttimestamp="1645728958172" timestamp="353883" />
  <Command __id="79" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:52 EST 2022" starttimestamp="1645728958172" timestamp="354180" />
  <Command __id="81" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:01:52 EST 2022" starttimestamp="1645728958172" timestamp="354328" />
  <Command __id="83" _type="InsertStringCommand" date="Thu Feb 24 14:01:53 EST 2022" starttimestamp="1645728958172" timestamp="355017" timestamp2="355017">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="84" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 14:01:53 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="355021" />
  <Command __id="94" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 14:01:57 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="359678" />
  <Command __id="95" _type="InsertStringCommand" date="Thu Feb 24 14:01:57 EST 2022" starttimestamp="1645728958172" timestamp="359796" timestamp2="359796">
    <data><![CDATA["]]></data>
  </Command>
  <Command __id="96" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_PREVIOUS" date="Thu Feb 24 14:01:58 EST 2022" starttimestamp="1645728958172" timestamp="360559" />
  <Command __id="98" _type="InsertStringCommand" date="Thu Feb 24 14:01:58 EST 2022" starttimestamp="1645728958172" timestamp="360766" timestamp2="360766">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="99" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:01:59 EST 2022" starttimestamp="1645728958172" timestamp="360882" />
  <Command __id="100" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:01:59 EST 2022" starttimestamp="1645728958172" timestamp="361074" />
  <Command __id="102" _type="InsertStringCommand" date="Thu Feb 24 14:02:00 EST 2022" starttimestamp="1645728958172" timestamp="361983" timestamp2="361983">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="103" _type="ShellCommand" date="Thu Feb 24 14:02:03 EST 2022" starttimestamp="1645728958172" timestamp="365201" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="104" _type="ShellCommand" date="Thu Feb 24 14:02:07 EST 2022" starttimestamp="1645728958172" timestamp="369224" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="105" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:02:07 EST 2022" starttimestamp="1645728958172" timestamp="369466" />
  <Command __id="106" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:02:07 EST 2022" starttimestamp="1645728958172" timestamp="369660" />
  <Command __id="107" _type="RunCommand" date="Thu Feb 24 14:02:07 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="369680" type="Run" />
  <Command __id="108" _type="RunCommand" date="Thu Feb 24 14:02:07 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="369680" type="Run" />
  <Command __id="109" _type="RunCommand" date="Thu Feb 24 14:02:07 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="369798" type="Run" />
  <Command __id="110" _type="RunCommand" date="Thu Feb 24 14:02:07 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="369798" type="Run" />
  <Command __id="111" _type="ShellCommand" date="Thu Feb 24 14:02:15 EST 2022" starttimestamp="1645728958172" timestamp="377453" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="112" _type="ShellCommand" date="Thu Feb 24 14:02:38 EST 2022" starttimestamp="1645728958172" timestamp="400431" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="93" _type="Insert" date="Thu Feb 24 14:01:57 EST 2022" docASTNodeCount="40" docActiveCodeLength="180" docExpressionCount="19" docLength="180" length="2" offset="168" starttimestamp="1645728958172" timestamp="359641">
    <text><![CDATA[""]]></text>
  </DocumentChange>
  <DocumentChange __id="97" _type="Insert" date="Thu Feb 24 14:01:58 EST 2022" docASTNodeCount="40" docActiveCodeLength="181" docExpressionCount="19" docLength="181" length="1" offset="169" starttimestamp="1645728958172" timestamp="360764">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="101" _type="Insert" date="Thu Feb 24 14:02:00 EST 2022" docASTNodeCount="40" docActiveCodeLength="182" docExpressionCount="19" docLength="182" length="1" offset="172" starttimestamp="1645728958172" timestamp="361977">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="113" _type="MoveCaretCommand" caretOffset="142" date="Thu Feb 24 14:02:41 EST 2022" docOffset="142" starttimestamp="1645728958172" timestamp="402830" />
  <DocumentChange __id="114" _type="Insert" date="Thu Feb 24 14:02:42 EST 2022" docASTNodeCount="42" docActiveCodeLength="183" docExpressionCount="21" docLength="183" length="1" offset="142" starttimestamp="1645728958172" timestamp="403927">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="115" _type="InsertStringCommand" date="Thu Feb 24 14:02:42 EST 2022" starttimestamp="1645728958172" timestamp="403931" timestamp2="403931">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="116" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 14:02:42 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="403935" />
  <Command __id="117" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 14:02:42 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="403944" />
  <DocumentChange __id="118" _type="Insert" date="Thu Feb 24 14:02:42 EST 2022" docASTNodeCount="42" docActiveCodeLength="184" docExpressionCount="21" docLength="184" length="1" offset="143" starttimestamp="1645728958172" timestamp="404276">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="119" _type="InsertStringCommand" date="Thu Feb 24 14:02:42 EST 2022" starttimestamp="1645728958172" timestamp="404280" timestamp2="404280">
    <data><![CDATA[m]]></data>
  </Command>
  <DocumentChange __id="120" _type="Insert" date="Thu Feb 24 14:02:42 EST 2022" docASTNodeCount="42" docActiveCodeLength="185" docExpressionCount="21" docLength="185" length="1" offset="144" starttimestamp="1645728958172" timestamp="404439">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="121" _type="InsertStringCommand" date="Thu Feb 24 14:02:42 EST 2022" starttimestamp="1645728958172" timestamp="404448" timestamp2="404448">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="122" _type="Insert" date="Thu Feb 24 14:02:42 EST 2022" docASTNodeCount="42" docActiveCodeLength="186" docExpressionCount="21" docLength="186" length="1" offset="145" starttimestamp="1645728958172" timestamp="404536">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="123" _type="InsertStringCommand" date="Thu Feb 24 14:02:42 EST 2022" starttimestamp="1645728958172" timestamp="404549" timestamp2="404549">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="124" _type="Insert" date="Thu Feb 24 14:02:42 EST 2022" docASTNodeCount="42" docActiveCodeLength="187" docExpressionCount="21" docLength="187" length="1" offset="146" starttimestamp="1645728958172" timestamp="404642">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="125" _type="InsertStringCommand" date="Thu Feb 24 14:02:42 EST 2022" starttimestamp="1645728958172" timestamp="404652" timestamp2="404652">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="126" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:02:43 EST 2022" starttimestamp="1645728958172" timestamp="405560" />
  <Command __id="128" _type="InsertStringCommand" date="Thu Feb 24 14:02:44 EST 2022" starttimestamp="1645728958172" timestamp="406809" timestamp2="406809">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="129" _type="ShellCommand" date="Thu Feb 24 14:02:50 EST 2022" starttimestamp="1645728958172" timestamp="412302" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="130" _type="ShellCommand" date="Thu Feb 24 14:02:50 EST 2022" starttimestamp="1645728958172" timestamp="412450" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="133" _type="MoveCaretCommand" caretOffset="142" date="Thu Feb 24 14:02:54 EST 2022" docOffset="142" starttimestamp="1645728958172" timestamp="416611" />
  <Command __id="135" _type="InsertStringCommand" date="Thu Feb 24 14:02:55 EST 2022" starttimestamp="1645728958172" timestamp="417418" timestamp2="417418">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="136" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 14:02:55 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="417423" />
  <Command __id="137" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 14:02:55 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="417428" />
  <Command __id="139" _type="InsertStringCommand" date="Thu Feb 24 14:02:56 EST 2022" starttimestamp="1645728958172" timestamp="417948" timestamp2="417948">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="141" _type="InsertStringCommand" date="Thu Feb 24 14:02:56 EST 2022" starttimestamp="1645728958172" timestamp="418097" timestamp2="418097">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="143" _type="InsertStringCommand" date="Thu Feb 24 14:02:56 EST 2022" starttimestamp="1645728958172" timestamp="418159" timestamp2="418159">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="145" _type="InsertStringCommand" date="Thu Feb 24 14:02:56 EST 2022" starttimestamp="1645728958172" timestamp="418229" timestamp2="418229">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="146" _type="ShellCommand" date="Thu Feb 24 14:02:57 EST 2022" starttimestamp="1645728958172" timestamp="419404" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="127" _type="Insert" date="Thu Feb 24 14:02:44 EST 2022" docASTNodeCount="43" docActiveCodeLength="188" docExpressionCount="22" docLength="188" length="1" offset="148" starttimestamp="1645728958172" timestamp="406801">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="131" _type="Delete" date="Thu Feb 24 14:02:50 EST 2022" docASTNodeCount="30" docActiveCodeLength="175" docExpressionCount="11" docLength="175" endLine="5" length="13" offset="134" startLine="5" starttimestamp="1645728958172" timestamp="412553">
    <text><![CDATA[Compiler.main]]></text>
  </DocumentChange>
  <DocumentChange __id="132" _type="Insert" date="Thu Feb 24 14:02:50 EST 2022" docASTNodeCount="41" docActiveCodeLength="183" docExpressionCount="20" docLength="183" length="8" offset="134" starttimestamp="1645728958172" timestamp="412556">
    <text><![CDATA[Compiler]]></text>
  </DocumentChange>
  <DocumentChange __id="134" _type="Insert" date="Thu Feb 24 14:02:55 EST 2022" docASTNodeCount="43" docActiveCodeLength="184" docExpressionCount="22" docLength="184" length="1" offset="142" starttimestamp="1645728958172" timestamp="417413">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="138" _type="Insert" date="Thu Feb 24 14:02:56 EST 2022" docASTNodeCount="43" docActiveCodeLength="185" docExpressionCount="22" docLength="185" length="1" offset="143" starttimestamp="1645728958172" timestamp="417943">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="140" _type="Insert" date="Thu Feb 24 14:02:56 EST 2022" docASTNodeCount="43" docActiveCodeLength="186" docExpressionCount="22" docLength="186" length="1" offset="144" starttimestamp="1645728958172" timestamp="418075">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="142" _type="Insert" date="Thu Feb 24 14:02:56 EST 2022" docASTNodeCount="43" docActiveCodeLength="187" docExpressionCount="22" docLength="187" length="1" offset="145" starttimestamp="1645728958172" timestamp="418135">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="144" _type="Insert" date="Thu Feb 24 14:02:56 EST 2022" docASTNodeCount="43" docActiveCodeLength="188" docExpressionCount="22" docLength="188" length="1" offset="146" starttimestamp="1645728958172" timestamp="418225">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="147" _type="ShellCommand" date="Thu Feb 24 14:04:32 EST 2022" starttimestamp="1645728958172" timestamp="514761" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="149" _type="MoveCaretCommand" caretOffset="840" date="Thu Feb 24 14:04:43 EST 2022" docOffset="997" starttimestamp="1645728958172" timestamp="525025" />
  <Command __id="148" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:04:43 EST 2022" docASTNodeCount="163" docActiveCodeLength="1007" docExpressionCount="111" docLength="1007" projectName="pa1" starttimestamp="1645728958172" timestamp="524921">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(1);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			System.exit(0);¶		}¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="150" _type="ShellCommand" date="Thu Feb 24 14:04:47 EST 2022" starttimestamp="1645728958172" timestamp="529576" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="151" _type="ShellCommand" date="Thu Feb 24 14:04:48 EST 2022" starttimestamp="1645728958172" timestamp="530573" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="152" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:04:53 EST 2022" docASTNodeCount="43" docActiveCodeLength="188" docExpressionCount="22" docLength="188" projectName="pa1" starttimestamp="1645728958172" timestamp="535441">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"testfile"};¶		Compiler a = new Compiler"), Diff(DELETE,"("), Diff(INSERT,".main(b);¶		System.out.println("1""), Diff(EQUAL,");¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

public class test {
	public static void main(String[] args) {
		String[] b = {"testfile"};
		Compiler a = new Compiler.main(b);
		System.out.println("1");
	}
}
]]></snapshot>
  </Command>
  <Command __id="153" _type="MoveCaretCommand" caretOffset="147" date="Thu Feb 24 14:04:53 EST 2022" docOffset="147" starttimestamp="1645728958172" timestamp="535668" />
  <DocumentChange __id="154" _type="Delete" date="Thu Feb 24 14:04:55 EST 2022" docASTNodeCount="43" docActiveCodeLength="187" docExpressionCount="22" docLength="187" endLine="5" length="1" offset="146" startLine="5" starttimestamp="1645728958172" timestamp="537093">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="155" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:55 EST 2022" starttimestamp="1645728958172" timestamp="537098" />
  <DocumentChange __id="156" _type="Delete" date="Thu Feb 24 14:04:55 EST 2022" docASTNodeCount="43" docActiveCodeLength="186" docExpressionCount="22" docLength="186" endLine="5" length="1" offset="145" startLine="5" starttimestamp="1645728958172" timestamp="537273">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="157" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:55 EST 2022" starttimestamp="1645728958172" timestamp="537277" />
  <DocumentChange __id="158" _type="Delete" date="Thu Feb 24 14:04:55 EST 2022" docASTNodeCount="43" docActiveCodeLength="185" docExpressionCount="22" docLength="185" endLine="5" length="1" offset="144" startLine="5" starttimestamp="1645728958172" timestamp="537437">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="159" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:55 EST 2022" starttimestamp="1645728958172" timestamp="537438" />
  <DocumentChange __id="160" _type="Delete" date="Thu Feb 24 14:04:55 EST 2022" docASTNodeCount="43" docActiveCodeLength="184" docExpressionCount="22" docLength="184" endLine="5" length="1" offset="143" startLine="5" starttimestamp="1645728958172" timestamp="537584">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="161" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:55 EST 2022" starttimestamp="1645728958172" timestamp="537587" />
  <DocumentChange __id="162" _type="Delete" date="Thu Feb 24 14:04:56 EST 2022" docASTNodeCount="41" docActiveCodeLength="183" docExpressionCount="20" docLength="183" endLine="5" length="1" offset="142" startLine="5" starttimestamp="1645728958172" timestamp="538089">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="163" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:56 EST 2022" starttimestamp="1645728958172" timestamp="538092" />
  <Command __id="164" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:04:56 EST 2022" starttimestamp="1645728958172" timestamp="538346" />
  <Command __id="165" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:04:56 EST 2022" starttimestamp="1645728958172" timestamp="538541" />
  <DocumentChange __id="166" _type="Delete" date="Thu Feb 24 14:04:56 EST 2022" docASTNodeCount="40" docActiveCodeLength="182" docExpressionCount="19" docLength="182" endLine="5" length="1" offset="143" startLine="5" starttimestamp="1645728958172" timestamp="538811">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <Command __id="167" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:56 EST 2022" starttimestamp="1645728958172" timestamp="538814" />
  <Command __id="168" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:04:57 EST 2022" starttimestamp="1645728958172" timestamp="539237" />
  <Command __id="169" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:04:57 EST 2022" starttimestamp="1645728958172" timestamp="539437" />
  <DocumentChange __id="170" _type="Insert" date="Thu Feb 24 14:04:57 EST 2022" docASTNodeCount="40" docActiveCodeLength="186" docExpressionCount="19" docLength="186" length="4" offset="145" starttimestamp="1645728958172" timestamp="539756">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="171" _type="InsertStringCommand" date="Thu Feb 24 14:04:57 EST 2022" starttimestamp="1645728958172" timestamp="539760" timestamp2="539760">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="172" _type="Insert" date="Thu Feb 24 14:04:58 EST 2022" docASTNodeCount="43" docActiveCodeLength="187" docExpressionCount="19" docLength="187" length="1" offset="149" starttimestamp="1645728958172" timestamp="540313">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="173" _type="InsertStringCommand" date="Thu Feb 24 14:04:58 EST 2022" starttimestamp="1645728958172" timestamp="540317" timestamp2="540317">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="174" _type="Insert" date="Thu Feb 24 14:04:58 EST 2022" docASTNodeCount="43" docActiveCodeLength="188" docExpressionCount="19" docLength="188" length="1" offset="150" starttimestamp="1645728958172" timestamp="540431">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="175" _type="InsertStringCommand" date="Thu Feb 24 14:04:58 EST 2022" starttimestamp="1645728958172" timestamp="540436" timestamp2="540436">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="176" _type="Delete" date="Thu Feb 24 14:04:58 EST 2022" docASTNodeCount="43" docActiveCodeLength="187" docExpressionCount="19" docLength="187" endLine="6" length="1" offset="150" startLine="6" starttimestamp="1645728958172" timestamp="540789">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="177" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:58 EST 2022" starttimestamp="1645728958172" timestamp="540791" />
  <DocumentChange __id="178" _type="Delete" date="Thu Feb 24 14:04:59 EST 2022" docASTNodeCount="40" docActiveCodeLength="186" docExpressionCount="19" docLength="186" endLine="6" length="1" offset="149" startLine="6" starttimestamp="1645728958172" timestamp="540913">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="179" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:04:59 EST 2022" starttimestamp="1645728958172" timestamp="540915" />
  <DocumentChange __id="180" _type="Insert" date="Thu Feb 24 14:04:59 EST 2022" docASTNodeCount="40" docActiveCodeLength="187" docExpressionCount="19" docLength="187" length="1" offset="149" starttimestamp="1645728958172" timestamp="541807">
    <text><![CDATA[A]]></text>
  </DocumentChange>
  <Command __id="181" _type="InsertStringCommand" date="Thu Feb 24 14:04:59 EST 2022" starttimestamp="1645728958172" timestamp="541814" timestamp2="541814">
    <data><![CDATA[A]]></data>
  </Command>
  <DocumentChange __id="182" _type="Insert" date="Thu Feb 24 14:05:00 EST 2022" docASTNodeCount="42" docActiveCodeLength="188" docExpressionCount="21" docLength="188" length="1" offset="150" starttimestamp="1645728958172" timestamp="542154">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="183" _type="InsertStringCommand" date="Thu Feb 24 14:05:00 EST 2022" starttimestamp="1645728958172" timestamp="542159" timestamp2="542159">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="184" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 14:05:00 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="542164" />
  <Command __id="185" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 14:05:00 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="542222" />
  <DocumentChange __id="186" _type="Delete" date="Thu Feb 24 14:05:00 EST 2022" docASTNodeCount="40" docActiveCodeLength="187" docExpressionCount="19" docLength="187" endLine="6" length="1" offset="150" startLine="6" starttimestamp="1645728958172" timestamp="542457">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="187" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:05:00 EST 2022" starttimestamp="1645728958172" timestamp="542461" />
  <DocumentChange __id="188" _type="Delete" date="Thu Feb 24 14:05:00 EST 2022" docASTNodeCount="40" docActiveCodeLength="186" docExpressionCount="19" docLength="186" endLine="6" length="1" offset="149" startLine="6" starttimestamp="1645728958172" timestamp="542587">
    <text><![CDATA[A]]></text>
  </DocumentChange>
  <Command __id="189" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:05:00 EST 2022" starttimestamp="1645728958172" timestamp="542588" />
  <DocumentChange __id="190" _type="Insert" date="Thu Feb 24 14:05:00 EST 2022" docASTNodeCount="40" docActiveCodeLength="187" docExpressionCount="19" docLength="187" length="1" offset="149" starttimestamp="1645728958172" timestamp="542669">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="191" _type="InsertStringCommand" date="Thu Feb 24 14:05:00 EST 2022" starttimestamp="1645728958172" timestamp="542673" timestamp2="542673">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="192" _type="Insert" date="Thu Feb 24 14:05:01 EST 2022" docASTNodeCount="42" docActiveCodeLength="188" docExpressionCount="21" docLength="188" length="1" offset="150" starttimestamp="1645728958172" timestamp="542836">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="193" _type="InsertStringCommand" date="Thu Feb 24 14:05:01 EST 2022" starttimestamp="1645728958172" timestamp="542837" timestamp2="542837">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="194" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 14:05:01 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="542841" />
  <DocumentChange __id="195" _type="Insert" date="Thu Feb 24 14:05:01 EST 2022" docASTNodeCount="45" docActiveCodeLength="189" docExpressionCount="21" docLength="189" length="1" offset="151" starttimestamp="1645728958172" timestamp="543162">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="196" _type="Insert" date="Thu Feb 24 14:05:01 EST 2022" docASTNodeCount="45" docActiveCodeLength="190" docExpressionCount="21" docLength="190" length="1" offset="152" starttimestamp="1645728958172" timestamp="543280">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197" _type="Insert" date="Thu Feb 24 14:05:01 EST 2022" docASTNodeCount="45" docActiveCodeLength="191" docExpressionCount="21" docLength="191" length="1" offset="153" starttimestamp="1645728958172" timestamp="543353">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="198" _type="Insert" date="Thu Feb 24 14:05:01 EST 2022" docASTNodeCount="45" docActiveCodeLength="192" docExpressionCount="21" docLength="192" length="1" offset="154" starttimestamp="1645728958172" timestamp="543457">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="199" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 14:05:02 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="544470" />
  <DocumentChange __id="200" _type="Replace" date="Thu Feb 24 14:05:02 EST 2022" docASTNodeCount="45" docActiveCodeLength="199" docExpressionCount="23" docLength="199" endLine="6" insertionLength="11" int_docASTNodeCount="42" int_docActiveCodeLength="188" int_docExpressionCount="21" int_docLength="188" length="4" offset="151" startLine="6" starttimestamp="1645728958172" timestamp="544473">
    <deletedText><![CDATA[main]]></deletedText>
    <insertedText><![CDATA[main(args);]]></insertedText>
  </DocumentChange>
  <Command __id="201" _type="InsertStringCommand" date="Thu Feb 24 14:05:02 EST 2022" starttimestamp="1645728958172" timestamp="544528" timestamp2="544528">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="202" _type="Replace" date="Thu Feb 24 14:05:03 EST 2022" docASTNodeCount="45" docActiveCodeLength="196" docExpressionCount="23" docLength="196" endLine="6" insertionLength="1" int_docASTNodeCount="44" int_docActiveCodeLength="195" int_docExpressionCount="22" int_docLength="195" length="4" offset="156" startLine="6" starttimestamp="1645728958172" timestamp="544936">
    <deletedText><![CDATA[args]]></deletedText>
    <insertedText><![CDATA[b]]></insertedText>
  </DocumentChange>
  <Command __id="203" _type="InsertStringCommand" date="Thu Feb 24 14:05:03 EST 2022" starttimestamp="1645728958172" timestamp="544941" timestamp2="544941">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="204" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 14:05:03 EST 2022" starttimestamp="1645728958172" timestamp="545383" />
  <Command __id="205" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Feb 24 14:05:04 EST 2022" starttimestamp="1645728958172" timestamp="546334" />
  <Command __id="206" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:05:04 EST 2022" starttimestamp="1645728958172" timestamp="546423" />
  <Command __id="207" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:05:04 EST 2022" starttimestamp="1645728958172" timestamp="546436" />
  <Command __id="208" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:05:30 EST 2022" docASTNodeCount="163" docActiveCodeLength="1007" docExpressionCount="111" docLength="1007" projectName="pa1" starttimestamp="1645728958172" timestamp="572810">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(1);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			System.exit(0);¶		}¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="210" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:05:35 EST 2022" docASTNodeCount="1" docActiveCodeLength="28" docExpressionCount="0" docLength="28" projectName="pa1" starttimestamp="1645728958172" timestamp="577086">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"if (1 == 1) {¶	return 1;¶}")]]]></diff>
  </Command>
  <Command __id="213" _type="RunCommand" date="Thu Feb 24 14:05:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="581480" type="Run" />
  <Command __id="214" _type="RunCommand" date="Thu Feb 24 14:05:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="581480" type="Run" />
  <Command __id="215" _type="RunCommand" date="Thu Feb 24 14:05:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="581652" type="Run" />
  <Command __id="216" _type="RunCommand" date="Thu Feb 24 14:05:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="581707" type="Run" />
  <Command __id="217" _type="RunCommand" date="Thu Feb 24 14:05:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="581707" type="Run" />
  <Command __id="218" _type="RunCommand" date="Thu Feb 24 14:05:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="581769" type="Run" />
  <Command __id="219" _type="RunCommand" date="Thu Feb 24 14:05:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="581769" type="Run" />
  <Command __id="220" _type="EHExceptionCommand" date="Thu Feb 24 14:05:39 EST 2022" starttimestamp="1645728958172" timestamp="581792" type="Exception">
    <outputString><![CDATA[Input file testfile not found
]]></outputString>
  </Command>
  <Command __id="221" _type="EHExceptionCommand" date="Thu Feb 24 14:05:40 EST 2022" starttimestamp="1645728958172" timestamp="581937" type="Exception">
    <outputString><![CDATA[Input file testfile not found
]]></outputString>
  </Command>
  <Command __id="222" _type="ShellCommand" date="Thu Feb 24 14:05:47 EST 2022" starttimestamp="1645728958172" timestamp="589600" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="223" _type="ShellCommand" date="Thu Feb 24 14:07:51 EST 2022" starttimestamp="1645728958172" timestamp="713051" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="224" _type="ShellCommand" date="Thu Feb 24 14:08:05 EST 2022" starttimestamp="1645728958172" timestamp="727613" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="225" _type="ShellCommand" date="Thu Feb 24 14:08:16 EST 2022" starttimestamp="1645728958172" timestamp="738522" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="226" _type="ShellCommand" date="Thu Feb 24 14:08:18 EST 2022" starttimestamp="1645728958172" timestamp="740597" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="227" _type="ShellCommand" date="Thu Feb 24 14:10:34 EST 2022" starttimestamp="1645728958172" timestamp="876625" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="228" _type="ShellCommand" date="Thu Feb 24 14:10:40 EST 2022" starttimestamp="1645728958172" timestamp="882315" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="229" _type="CopyCommand" date="Thu Feb 24 14:10:49 EST 2022" starttimestamp="1645728958172" timestamp="891182" />
  <Command __id="230" _type="ShellCommand" date="Thu Feb 24 14:10:50 EST 2022" starttimestamp="1645728958172" timestamp="892721" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="231" _type="EclipseCommand" commandID="org.eclipse.ui.file.properties" date="Thu Feb 24 14:10:50 EST 2022" starttimestamp="1645728958172" timestamp="892737" />
  <Command __id="211" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:05:36 EST 2022" docASTNodeCount="45" docActiveCodeLength="196" docExpressionCount="23" docLength="196" projectName="pa1" starttimestamp="1645728958172" timestamp="578184">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"testfile"};¶		Compiler a = new Compiler"), Diff(INSERT,"();¶		a"), Diff(EQUAL,".main(b);¶		System.out.println("1");¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

public class test {
	public static void main(String[] args) {
		String[] b = {"testfile"};
		Compiler a = new Compiler();
		a.main(b);
		System.out.println("1");
	}
}
]]></snapshot>
  </Command>
  <Command __id="232" _type="SelectTextCommand" caretOffset="102" date="Thu Feb 24 14:10:54 EST 2022" end="110" start="102" starttimestamp="1645728958172" timestamp="896310" />
  <Command __id="234" _type="PasteCommand" date="Thu Feb 24 14:10:55 EST 2022" starttimestamp="1645728958172" timestamp="897770" />
  <Command __id="235" _type="ShellCommand" date="Thu Feb 24 14:10:57 EST 2022" starttimestamp="1645728958172" timestamp="898868" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="236" _type="ShellCommand" date="Thu Feb 24 14:11:01 EST 2022" starttimestamp="1645728958172" timestamp="902991" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="237" _type="ShellCommand" date="Thu Feb 24 14:11:06 EST 2022" starttimestamp="1645728958172" timestamp="907978" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="238" _type="ShellCommand" date="Thu Feb 24 14:11:08 EST 2022" starttimestamp="1645728958172" timestamp="910054" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="239" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:11:08 EST 2022" starttimestamp="1645728958172" timestamp="910252" />
  <Command __id="240" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:11:08 EST 2022" starttimestamp="1645728958172" timestamp="910266" />
  <Command __id="241" _type="RunCommand" date="Thu Feb 24 14:11:08 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="910287" type="Run" />
  <Command __id="242" _type="RunCommand" date="Thu Feb 24 14:11:08 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="910287" type="Run" />
  <Command __id="243" _type="EHExceptionCommand" date="Thu Feb 24 14:11:08 EST 2022" starttimestamp="1645728958172" timestamp="910545" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
]]></outputString>
  </Command>
  <Command __id="244" _type="RunCommand" date="Thu Feb 24 14:11:08 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="910576" type="Run" />
  <Command __id="245" _type="RunCommand" date="Thu Feb 24 14:11:08 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="910577" type="Run" />
  <Command __id="246" _type="EHExceptionCommand" date="Thu Feb 24 14:11:08 EST 2022" starttimestamp="1645728958172" timestamp="910603" type="Exception">
    <outputString><![CDATA[Parse error: Parsing if and expecting 'CLASS' but found 'IF'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <DocumentChange __id="233" _type="Replace" date="Thu Feb 24 14:10:55 EST 2022" docASTNodeCount="45" docActiveCodeLength="247" docExpressionCount="23" docLength="247" endLine="4" insertionLength="59" int_docASTNodeCount="45" int_docActiveCodeLength="188" int_docExpressionCount="23" int_docLength="188" length="8" offset="102" startLine="4" starttimestamp="1645728958172" timestamp="897758">
    <deletedText><![CDATA[testfile]]></deletedText>
    <insertedText><![CDATA[F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile]]></insertedText>
  </DocumentChange>
  <Command __id="247" _type="MoveCaretCommand" caretOffset="235" date="Thu Feb 24 14:11:30 EST 2022" docOffset="235" starttimestamp="1645728958172" timestamp="932136" />
  <DocumentChange __id="248" _type="Delete" date="Thu Feb 24 14:11:32 EST 2022" docASTNodeCount="45" docActiveCodeLength="246" docExpressionCount="23" docLength="246" endLine="7" length="1" offset="234" startLine="7" starttimestamp="1645728958172" timestamp="934702">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="249" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:11:32 EST 2022" starttimestamp="1645728958172" timestamp="934710" />
  <DocumentChange __id="250" _type="Insert" date="Thu Feb 24 14:11:33 EST 2022" docASTNodeCount="45" docActiveCodeLength="247" docExpressionCount="23" docLength="247" length="1" offset="234" starttimestamp="1645728958172" timestamp="935627">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="251" _type="InsertStringCommand" date="Thu Feb 24 14:11:33 EST 2022" starttimestamp="1645728958172" timestamp="935630" timestamp2="935630">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="252" _type="Insert" date="Thu Feb 24 14:11:33 EST 2022" docASTNodeCount="45" docActiveCodeLength="248" docExpressionCount="23" docLength="248" length="1" offset="235" starttimestamp="1645728958172" timestamp="935827">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="253" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="935865" timestamp2="935865">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="254" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="249" docExpressionCount="23" docLength="249" length="1" offset="236" starttimestamp="1645728958172" timestamp="936329">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="255" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936331" timestamp2="936331">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="256" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="250" docExpressionCount="23" docLength="250" length="1" offset="237" starttimestamp="1645728958172" timestamp="936356">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="257" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936359" timestamp2="936359">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="258" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="251" docExpressionCount="23" docLength="251" length="1" offset="238" starttimestamp="1645728958172" timestamp="936385">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="259" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936388" timestamp2="936388">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="260" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="252" docExpressionCount="23" docLength="252" length="1" offset="239" starttimestamp="1645728958172" timestamp="936415">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="261" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936418" timestamp2="936418">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="262" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="253" docExpressionCount="23" docLength="253" length="1" offset="240" starttimestamp="1645728958172" timestamp="936447">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="263" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936449" timestamp2="936449">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="264" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="254" docExpressionCount="23" docLength="254" length="1" offset="241" starttimestamp="1645728958172" timestamp="936478">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="265" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936480" timestamp2="936480">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="266" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="255" docExpressionCount="23" docLength="255" length="1" offset="242" starttimestamp="1645728958172" timestamp="936509">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="267" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936512" timestamp2="936512">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="268" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="256" docExpressionCount="23" docLength="256" length="1" offset="243" starttimestamp="1645728958172" timestamp="936541">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="269" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936543" timestamp2="936543">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="270" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="257" docExpressionCount="23" docLength="257" length="1" offset="244" starttimestamp="1645728958172" timestamp="936569">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="271" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936571" timestamp2="936571">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="272" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="258" docExpressionCount="23" docLength="258" length="1" offset="245" starttimestamp="1645728958172" timestamp="936598">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <Command __id="273" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936600" timestamp2="936600">
    <data><![CDATA[E]]></data>
  </Command>
  <DocumentChange __id="274" _type="Insert" date="Thu Feb 24 14:11:34 EST 2022" docASTNodeCount="45" docActiveCodeLength="259" docExpressionCount="23" docLength="259" length="1" offset="246" starttimestamp="1645728958172" timestamp="936611">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <Command __id="275" _type="InsertStringCommand" date="Thu Feb 24 14:11:34 EST 2022" starttimestamp="1645728958172" timestamp="936614" timestamp2="936614">
    <data><![CDATA[N]]></data>
  </Command>
  <DocumentChange __id="276" _type="Insert" date="Thu Feb 24 14:11:35 EST 2022" docASTNodeCount="45" docActiveCodeLength="260" docExpressionCount="23" docLength="260" length="1" offset="247" starttimestamp="1645728958172" timestamp="937292">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="277" _type="InsertStringCommand" date="Thu Feb 24 14:11:35 EST 2022" starttimestamp="1645728958172" timestamp="937295" timestamp2="937295">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="278" _type="Insert" date="Thu Feb 24 14:11:36 EST 2022" docASTNodeCount="45" docActiveCodeLength="261" docExpressionCount="23" docLength="261" length="1" offset="248" starttimestamp="1645728958172" timestamp="937943">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="279" _type="InsertStringCommand" date="Thu Feb 24 14:11:36 EST 2022" starttimestamp="1645728958172" timestamp="937947" timestamp2="937947">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="280" _type="Delete" date="Thu Feb 24 14:11:36 EST 2022" docASTNodeCount="45" docActiveCodeLength="260" docExpressionCount="23" docLength="260" endLine="7" length="1" offset="248" startLine="7" starttimestamp="1645728958172" timestamp="938527">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="281" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:11:36 EST 2022" starttimestamp="1645728958172" timestamp="938529" />
  <DocumentChange __id="282" _type="Insert" date="Thu Feb 24 14:11:36 EST 2022" docASTNodeCount="45" docActiveCodeLength="261" docExpressionCount="23" docLength="261" length="1" offset="248" starttimestamp="1645728958172" timestamp="938808">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="283" _type="InsertStringCommand" date="Thu Feb 24 14:11:36 EST 2022" starttimestamp="1645728958172" timestamp="938811" timestamp2="938811">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="284" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="262" docExpressionCount="23" docLength="262" length="1" offset="249" starttimestamp="1645728958172" timestamp="939304">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="285" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939307" timestamp2="939307">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="286" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="263" docExpressionCount="23" docLength="263" length="1" offset="250" starttimestamp="1645728958172" timestamp="939338">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="287" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939340" timestamp2="939340">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="288" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="264" docExpressionCount="23" docLength="264" length="1" offset="251" starttimestamp="1645728958172" timestamp="939364">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="289" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939366" timestamp2="939366">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="290" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="265" docExpressionCount="23" docLength="265" length="1" offset="252" starttimestamp="1645728958172" timestamp="939394">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="291" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939397" timestamp2="939397">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="292" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="266" docExpressionCount="23" docLength="266" length="1" offset="253" starttimestamp="1645728958172" timestamp="939424">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="293" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939427" timestamp2="939427">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="294" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="267" docExpressionCount="23" docLength="267" length="1" offset="254" starttimestamp="1645728958172" timestamp="939459">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="295" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939465" timestamp2="939465">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="296" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="268" docExpressionCount="23" docLength="268" length="1" offset="255" starttimestamp="1645728958172" timestamp="939488">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="297" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939494" timestamp2="939494">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="298" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="269" docExpressionCount="23" docLength="269" length="1" offset="256" starttimestamp="1645728958172" timestamp="939515">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="299" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939517" timestamp2="939517">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="300" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="270" docExpressionCount="23" docLength="270" length="1" offset="257" starttimestamp="1645728958172" timestamp="939546">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="301" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939548" timestamp2="939548">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="302" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="271" docExpressionCount="23" docLength="271" length="1" offset="258" starttimestamp="1645728958172" timestamp="939576">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="303" _type="InsertStringCommand" date="Thu Feb 24 14:11:37 EST 2022" starttimestamp="1645728958172" timestamp="939579" timestamp2="939579">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="304" _type="Insert" date="Thu Feb 24 14:11:37 EST 2022" docASTNodeCount="45" docActiveCodeLength="272" docExpressionCount="23" docLength="272" length="1" offset="259" starttimestamp="1645728958172" timestamp="939607">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="309" _type="RunCommand" date="Thu Feb 24 14:11:41 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="942868" type="Run" />
  <Command __id="310" _type="RunCommand" date="Thu Feb 24 14:11:41 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="942870" type="Run" />
  <Command __id="311" _type="RunCommand" date="Thu Feb 24 14:11:41 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="942983" type="Run" />
  <Command __id="312" _type="RunCommand" date="Thu Feb 24 14:11:41 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="942983" type="Run" />
  <Command __id="313" _type="EHExceptionCommand" date="Thu Feb 24 14:11:41 EST 2022" starttimestamp="1645728958172" timestamp="943073" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
Parse error: Parsing if and expecting 'CLASS' but found 'IF'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="315" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.delete.line" date="Thu Feb 24 14:15:38 EST 2022" starttimestamp="1645728958172" timestamp="1180335" />
  <Command __id="316" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Feb 24 14:15:39 EST 2022" starttimestamp="1645728958172" timestamp="1181357" />
  <Command __id="317" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:15:39 EST 2022" starttimestamp="1645728958172" timestamp="1181449" />
  <Command __id="318" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:15:39 EST 2022" starttimestamp="1645728958172" timestamp="1181461" />
  <Command __id="319" _type="ShellCommand" date="Thu Feb 24 14:36:22 EST 2022" starttimestamp="1645728958172" timestamp="2423887" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="314" _type="Delete" date="Thu Feb 24 14:15:38 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" endLine="8" length="53" offset="212" startLine="7" starttimestamp="1645728958172" timestamp="1180330">
    <text><![CDATA[		System.out.println("EEEEEEEEEEEENDDDDDDDDDDDDD");
]]></text>
  </DocumentChange>
  <Command __id="321" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:53:57 EST 2022" docASTNodeCount="1" docActiveCodeLength="28" docExpressionCount="0" docLength="28" projectName="pa1" starttimestamp="1645728958172" timestamp="3478894">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"if (1 == 1) {¶	return 1;¶}")]]]></diff>
  </Command>
  <Command __id="320" _type="ShellCommand" date="Thu Feb 24 14:37:32 EST 2022" starttimestamp="1645728958172" timestamp="2494137" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="323" _type="SelectTextCommand" caretOffset="224" date="Thu Feb 24 14:54:43 EST 2022" end="224" start="215" starttimestamp="1645728958172" timestamp="3525753" />
  <Command __id="324" _type="MoveCaretCommand" caretOffset="445" date="Thu Feb 24 14:54:48 EST 2022" docOffset="445" starttimestamp="1645728958172" timestamp="3530044" />
  <Command __id="325" _type="SelectTextCommand" caretOffset="176" date="Thu Feb 24 14:54:57 EST 2022" end="443" start="176" starttimestamp="1645728958172" timestamp="3539072" />
  <Command __id="326" _type="CopyCommand" date="Thu Feb 24 14:54:57 EST 2022" starttimestamp="1645728958172" timestamp="3539725" />
  <Command __id="322" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:54:43 EST 2022" docASTNodeCount="46" docActiveCodeLength="299" docExpressionCount="22" docLength="445" projectName="pa1" starttimestamp="1645728958172" timestamp="3525569">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\ErrorReporter.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava;

/**
 * reports errors from different phases of compilation
 * and maintains a count of total errors for use in 
 * the compiler driver
 *
 */
public class ErrorReporter {

		private int numErrors;

		ErrorReporter() {
			numErrors = 0;
		}

		public boolean hasErrors() {
			return numErrors > 0;
		}

		public void reportError(String message) {
			System.out.println(message);
			numErrors++;
		}	
}
]]></snapshot>
  </Command>
  <Command __id="328" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:55:02 EST 2022" docASTNodeCount="3" docActiveCodeLength="18" docExpressionCount="1" docLength="18" projectName="pa1" starttimestamp="1645728958172" timestamp="3544749">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(DELETE,"if (1 == 1) {¶	return 1;"), Diff(INSERT,"class test {¶	"), Diff(EQUAL,"¶}")]]]></diff>
    <snapshot><![CDATA[class test {
	
}]]></snapshot>
  </Command>
  <Command __id="331" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:56:27 EST 2022" starttimestamp="1645728958172" timestamp="3629362" />
  <Command __id="332" _type="EclipseCommand" commandID="" date="Thu Feb 24 14:56:27 EST 2022" starttimestamp="1645728958172" timestamp="3629369" />
  <Command __id="333" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:56:34 EST 2022" docASTNodeCount="163" docActiveCodeLength="1007" docExpressionCount="111" docLength="1007" projectName="pa1" starttimestamp="1645728958172" timestamp="3636214">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(1);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			System.exit(0);¶		}¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="334" _type="MoveCaretCommand" caretOffset="840" date="Thu Feb 24 14:56:34 EST 2022" docOffset="997" starttimestamp="1645728958172" timestamp="3636314" />
  <Command __id="335" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:56:37 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="3638886">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {""), Diff(INSERT,"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\"), Diff(EQUAL,"testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	"), Diff(DELETE,"	System.out.println("1");¶	"), Diff(EQUAL,"}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

public class test {
	public static void main(String[] args) {
		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};
		Compiler a = new Compiler();
		a.main(b);
	}
}
]]></snapshot>
  </Command>
  <Command __id="342" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:56:46 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="3648152">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class "), Diff(DELETE,"test {¶"), Diff(INSERT,"ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}"), Diff(EQUAL,"	¶}")]]]></diff>
    <snapshot><![CDATA[class ErrorReporter {

		private int numErrors;
		public static kill;

		static ErrorReporter() {
			numErrors = 0;
		}

		public boolean hasErrors() {
			return numErrors > 0;
		}

		public void reportError(String message) {
			System.out.println(message);
			numErrors++;
		}	
}]]></snapshot>
  </Command>
  <Command __id="337" _type="RunCommand" date="Thu Feb 24 14:56:38 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3640136" type="Run" />
  <Command __id="338" _type="RunCommand" date="Thu Feb 24 14:56:38 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3640136" type="Run" />
  <Command __id="339" _type="RunCommand" date="Thu Feb 24 14:56:38 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3640252" type="Run" />
  <Command __id="340" _type="RunCommand" date="Thu Feb 24 14:56:38 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3640252" type="Run" />
  <Command __id="341" _type="EHExceptionCommand" date="Thu Feb 24 14:56:38 EST 2022" starttimestamp="1645728958172" timestamp="3640305" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
Parse error: Parsing  and expecting 'RCURLY' but found 'EOT'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="344" _type="MoveCaretCommand" caretOffset="8144" date="Thu Feb 24 14:57:03 EST 2022" docOffset="8222" starttimestamp="1645728958172" timestamp="3665307" />
  <Command __id="346" _type="ShellCommand" date="Thu Feb 24 14:57:04 EST 2022" starttimestamp="1645728958172" timestamp="3666052" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="347" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:09 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3671304" wrapSearch="false">
    <searchString><![CDATA[RCURLY']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="348" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:11 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3673584" wrapSearch="false">
    <searchString><![CDATA[RCURLY']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="349" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:12 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3674094" wrapSearch="false">
    <searchString><![CDATA[RCURLY']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="350" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:12 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3674171" wrapSearch="false">
    <searchString><![CDATA[RCURLY']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="351" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:12 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3674410" wrapSearch="false">
    <searchString><![CDATA[RCURLY']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="352" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:30 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3692191" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="353" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:30 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3692778" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="354" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:31 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3692863" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="355" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:31 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3693079" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="356" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:31 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3693179" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="357" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:33 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3695181" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="358" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:33 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3695377" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="359" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:33 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3695555" wrapSearch="false">
    <searchString><![CDATA[Parsing  and expecting]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="360" _type="ShellCommand" date="Thu Feb 24 14:57:35 EST 2022" starttimestamp="1645728958172" timestamp="3697500" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="362" _type="ShellCommand" date="Thu Feb 24 14:57:37 EST 2022" starttimestamp="1645728958172" timestamp="3699376" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="363" _type="ShellCommand" date="Thu Feb 24 14:57:39 EST 2022" starttimestamp="1645728958172" timestamp="3701150" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="364" _type="CopyCommand" date="Thu Feb 24 14:57:41 EST 2022" starttimestamp="1645728958172" timestamp="3702835" />
  <Command __id="365" _type="ShellCommand" date="Thu Feb 24 14:57:43 EST 2022" starttimestamp="1645728958172" timestamp="3704927" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="366" _type="PasteCommand" date="Thu Feb 24 14:57:43 EST 2022" starttimestamp="1645728958172" timestamp="3705058" />
  <Command __id="367" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:44 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3706586" wrapSearch="false">
    <searchString><![CDATA['RCURLY' but found 'EOT']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="368" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:44 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3706686" wrapSearch="false">
    <searchString><![CDATA['RCURLY' but found 'EOT']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="369" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:45 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3706939" wrapSearch="false">
    <searchString><![CDATA['RCURLY' but found 'EOT']]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="370" _type="EclipseCommand" commandID="org.eclipse.ui.edit.selectAll" date="Thu Feb 24 14:57:47 EST 2022" starttimestamp="1645728958172" timestamp="3709006" />
  <Command __id="371" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:48 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3710433" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="372" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:48 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3710533" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="373" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:48 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3710749" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="374" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:49 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3710912" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="375" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:50 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3712791" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="376" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:51 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3712889" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="377" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:51 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3713085" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="378" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:51 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3713170" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="379" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:51 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3713362" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="380" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:57:51 EST 2022" forward="false" matchWord="true" offset="8222" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3713528" wrapSearch="false">
    <searchString><![CDATA[R]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="381" _type="ShellCommand" date="Thu Feb 24 14:57:52 EST 2022" starttimestamp="1645728958172" timestamp="3714728" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="382" _type="MoveCaretCommand" caretOffset="10338" date="Thu Feb 24 14:58:07 EST 2022" docOffset="10416" starttimestamp="1645728958172" timestamp="3729250" />
  <Command __id="343" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:57:03 EST 2022" docASTNodeCount="1522" docActiveCodeLength="10648" docExpressionCount="1057" docLength="11264" projectName="pa1" starttimestamp="1645728958172" timestamp="3665191">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

import miniJava.SyntacticAnalyzer.Scanner;
import miniJava.SyntacticAnalyzer.TokenKind;
import miniJava.ErrorReporter;

public class Parser {
	private Scanner scanner;
	private ErrorReporter reporter;
	private Token currentToken;

	public Parser(Scanner scanner, ErrorReporter reporter) {
		this.scanner = scanner;
		this.reporter = reporter;
	}


	/**
	 *  parse input, catch possible parse error
	 */
	public void parse() {
		currentToken = scanner.scan();
		try {
			parseProgram();
		}
		catch (SyntaxError e) { }
	}
	
	private boolean startsDeclaration(TokenKind kind) {
		return kind == TokenKind.PUBLIC ||
				kind == TokenKind.PRIVATE ||
				 kind == TokenKind.STATIC ||
				  startsType(kind) ||
					 kind == TokenKind.VOID;
	}
	
	private boolean startsType(TokenKind kind) {
		return kind == TokenKind.INT ||
				   kind == TokenKind.BOOLEAN ||
					kind == TokenKind.ID;
	}

	
	//   
	private void parseProgram() throws SyntaxError {
		accept(TokenKind.CLASS);
		parseId();
		accept(TokenKind.LCURLY);
		
		while (startsDeclaration(currentToken.kind)) {
			parseVisibility();
			parseAccess();
			switch(currentToken.kind) {
				case VOID:
					parseId();
					accept(TokenKind.LPAREN);
					if (startsType(currentToken.kind)) {
						parseParameterList();
					}
					accept(TokenKind.RPAREN);
					accept(TokenKind.LCURLY);
					
					while (startsStatement(currentToken.kind)) {
						parseStatement();
					}
					accept(TokenKind.RCURLY);
					break;
					
				default:
					if (startsType(currentToken.kind)) {
						parseType();
						parseId();
						switch(currentToken.kind) {
						case SEMICOLON:
							accept(TokenKind.SEMICOLON);
							break;
						case ID:
							parseId();
							accept(TokenKind.LPAREN);
							if (startsType(currentToken.kind)) {
								parseParameterList();
							}
							accept(TokenKind.RPAREN);
							accept(TokenKind.LCURLY);
							
							while (startsStatement(currentToken.kind)) {
								parseStatement();
							}
							accept(TokenKind.RCURLY);
							break;
						}
					}
					else {
						parseError("Parsing wrong in declarations");
					}
					
			}
		}
		
		accept(TokenKind.RCURLY);
		accept(TokenKind.EOT);
	}
	
	private void parseStatement() throws SyntaxError {
		switch (currentToken.kind) {
		case LCURLY:
			acceptIt();
			while (startsStatement(currentToken.kind)) {
				parseStatement();
			}
			accept(TokenKind.RCURLY);
			break;
			
		case INT: case BOOLEAN:
			parseType();
			parseId();
			accept(TokenKind.EQUAL);
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
		
		case ID:
			acceptIt();
			
			switch (currentToken.kind) {
			// in Type
			case ID:
			acceptIt();
			accept(TokenKind.EQUAL);
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
			
			// in Reference
			case EQUAL:
			acceptIt();
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
			
			case LPAREN:
			acceptIt();
			if (currentToken.kind == TokenKind.RPAREN) {
				acceptIt();
			} else {
				parseArgumentList();
				accept(TokenKind.RPAREN);
			}
			accept(TokenKind.SEMICOLON);
			break;
			
			// both
			case LBRACKET: 
			acceptIt();
			// in Type
			if (currentToken.kind == TokenKind.RBRACKET) {
				acceptIt();
				accept(TokenKind.ID);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
			} else {
				// in Reference
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
			}
			break;
			
			case DOT:
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case EQUAL:
				acceptIt();
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LBRACKET: 
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
				}
				accept(TokenKind.SEMICOLON);
				break;
			
			default:
				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);
			}
			default:
				parseError("parsing statement, in subcase ID, current token is: " + currentToken);
			}
			break;
		
		case THIS:
			acceptIt();
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case EQUAL:
				acceptIt();
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LBRACKET:
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
				
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
					accept(TokenKind.SEMICOLON);
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
					accept(TokenKind.SEMICOLON);
				}
				break;
			
			default:
				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);
			}
			break;
			
		case RETURN:
			acceptIt();
			if (currentToken.kind == TokenKind.SEMICOLON) {
				acceptIt();
			} else {
				parseExpression();
				accept(TokenKind.SEMICOLON);
			}
			break;
		
		case IF:
			acceptIt();
			accept(TokenKind.LPAREN);
			parseExpression();
			accept(TokenKind.RPAREN);
			parseStatement();
			if (currentToken.kind == TokenKind.ELSE) {
				acceptIt();
				parseStatement();
			}
			break;
			
		case WHILE:
			acceptIt();
			accept(TokenKind.LPAREN);
			parseExpression();
			accept(TokenKind.RPAREN);
			parseStatement();
			break;
		
		default:
			parseError("parsing statement, current token is:" + currentToken);
		}
		return ;
		
	}


	private void parseArgumentList() {
		// TODO Auto-generated method stub
		parseExpression();
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			parseExpression();
		}
	}


	private void parseExpression() {
		// TODO Auto-generated method stub
		switch (currentToken.kind) {
		case ID: case THIS:
			acceptIt();
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case LBRACKET:
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				break;
			
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
				}
				break;
				
			// just reference
			default:
				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);
			}
			
		case UNOP: case MINUS:
			acceptIt();
			parseExpression();
			break;
		
		case LPAREN:
			acceptIt();
			parseExpression();
			accept(TokenKind.RPAREN);
			break;
		
		case NUM: case TRUE: case FALSE:
			acceptIt();
			break;
		
		case NEW:
			acceptIt();
			switch (currentToken.kind) {
			case ID:
				acceptIt();
				switch (currentToken.kind) {
				case LPAREN:
					acceptIt();
					accept(TokenKind.RPAREN);
					break;
				case LBRACKET:
					acceptIt();
					parseExpression();
					accept(TokenKind.RBRACKET);
					break;
				
				}
			
			case INT:
				acceptIt();
				accept(TokenKind.LBRACKET);
				parseExpression();
				accept(TokenKind.RBRACKET);
				break;
			
			default:
				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);
			}
			break;
		
		default:
			parseError("parsing expression, current token is: " + currentToken);
		}
		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {
			acceptIt();
			parseExpression();
		}
	}


	private boolean startsStatement(TokenKind kind) {
		return kind == TokenKind.LCURLY ||
				startsType(kind) ||
				 startsReference(kind) ||
				  kind == TokenKind.RETURN ||
				   kind == TokenKind.IF ||
					kind == TokenKind.WHILE;
	}


	private boolean startsReference(TokenKind kind) {
		return kind == TokenKind.ID ||
				kind == TokenKind.THIS;
	}


	private void parseParameterList() throws SyntaxError {
		parseType();
		parseId();
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			parseType();
			parseId();
		}
	}


	private void parseType() throws SyntaxError{
		switch (currentToken.kind) {
		case INT:
			acceptIt();
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
			}
			break;
		case BOOLEAN:
			acceptIt();
			break;
		case ID:
			parseId();
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
			}
			break;
		default:
			parseError("Wrong in parsing Type, currentToken is: " + currentToken);
		}
	}


	private void parseId() throws SyntaxError {
		accept(TokenKind.ID);
	}


	private void parseAccess() throws SyntaxError {
		if (currentToken.kind == TokenKind.STATIC) {
			accept(TokenKind.STATIC);
		}
	}


	private void parseVisibility() throws SyntaxError {
		if (currentToken.kind == TokenKind.PRIVATE) {
			accept(TokenKind.PRIVATE);
		} else if (currentToken.kind == TokenKind.PUBLIC) {
			accept(TokenKind.PUBLIC);
		}
	}


	private void parseClassDeclaration() throws SyntaxError {
		while (currentToken.kind == TokenKind.CLASS) {
			parseClassDeclaration();
		}
		accept(TokenKind.EOT);
	}

	/**
	 * accept current token and advance to next token
	 */
	private void acceptIt() throws SyntaxError {
		accept(currentToken.kind);
	}

	/**
	 * verify that current token in input matches expected token and advance to next token
	 * @param expectedToken
	 * @throws SyntaxError  if match fails
	 */
	private void accept(TokenKind expectedTokenKind) throws SyntaxError {
		if (currentToken.kind == expectedTokenKind) {
			currentToken = scanner.scan();
		}
		else
			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +
					"' but found '" + currentToken.kind + "'");
	}

	/**
	 * report parse error and unwind call stack to start of parse
	 * @param e  string with error detail
	 * @throws SyntaxError
	 */
	private void parseError(String e) throws SyntaxError {
		reporter.reportError("Parse error: " + e);
		throw new SyntaxError();
	}

	// show parse stack whenever terminal is  accepted
	private void pTrace() {
		StackTraceElement [] stl = Thread.currentThread().getStackTrace();
		for (int i = stl.length - 1; i > 0 ; i--) {
			if(stl[i].toString().contains("parse"))
				System.out.println(stl[i]);
		}
		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");
		System.out.println();
	}

}
]]></snapshot>
  </Command>
  <Command __id="383" _type="MoveCaretCommand" caretOffset="10489" date="Thu Feb 24 14:58:09 EST 2022" docOffset="10567" starttimestamp="1645728958172" timestamp="3731204" />
  <Command __id="384" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:58:22 EST 2022" docASTNodeCount="72" docActiveCodeLength="316" docExpressionCount="36" docLength="316" projectName="pa1" starttimestamp="1645728958172" timestamp="3744626">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\TokenKind.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

public enum TokenKind {NUM, CLASS, ID, LBRACKET, RBRACKET, VOID, LPAREN, RPAREN, EOT, EQUAL, THIS,
							PUBLIC, PRIVATE, STATIC, INT, BOOLEAN, COMMA, DOT, RETURN, SEMICOLON,
								IF, ELSE, WHILE, UNOP, BINOP, MINUS, TRUE, FALSE, NEW, LCURLY, RCURLY,
									ERROR}

]]></snapshot>
  </Command>
  <Command __id="385" _type="MoveCaretCommand" caretOffset="260" date="Thu Feb 24 14:58:23 EST 2022" docOffset="260" starttimestamp="1645728958172" timestamp="3745010" />
  <Command __id="386" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:58:25 EST 2022" docASTNodeCount="1049" docActiveCodeLength="7686" docExpressionCount="643" docLength="8416" projectName="pa1" starttimestamp="1645728958172" timestamp="3746959">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Scanner.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

import java.io.IOException;
import java.io.InputStream;

import miniJava.ErrorReporter;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Scanner {
	private boolean isComment;
	
//	comment state = 0 not comment
//			= 1 show /
//			= 2 show second /
//			= 12 show first *
//			= 13 show second *
//			= 3 show third /
//			= 4 show fourth / end of comment
//			= 14 show second / end of comment
	private int commentState;
	
	private InputStream inputStream;
	private ErrorReporter reporter;
	
	private char currentChar;
	private byte currentKind;
	private StringBuilder currentSpelling;
	
	// true when end of line is found
	private boolean eot = false; 
	
	public Scanner(InputStream inputStream, ErrorReporter reporter) {
		this.isComment = false;
		this.commentState = 0;
		this.inputStream = inputStream;
		this.reporter = reporter;

		// initialize scanner state
		readChar();
	}	
	
	/**
	 * skip whitespace and scan next token
	 */	
	
// ? SINGLE SLASH
//	comment state = 0 not comment
//	= 1 show /
//	= 2 show second /
//	= 12 show first *
//	= 13 show second *
//	= 14 show second / end of comment
	public void scanSeparator() {
		switch (commentState) {
			case 0:
				while (!eot && 
						(currentChar == ' ' ||
							currentChar == '\t' ||
								currentChar == '\n' ||
									currentChar == '\r')) {
					skipIt();
				}
				if (currentChar == '/') {
					commentState = 1;
					skipIt();
					scanSeparator();
				}
				break;
			
			case 1:
				if (currentChar == '/') {
					commentState = 2;
					isComment = true;
					skipIt();
					scanSeparator();
				} else if (currentChar == '*') {
					commentState = 12;
					isComment = true;
					skipIt();
					scanSeparator();
				} else {
					System.exit(4);
				}
				break;
			
			case 2:
				if (currentChar == '\r' || currentChar == '\n' || eot) {
					commentState = 0;
					isComment = false;
					scanSeparator();
				} else {
					skipIt();
					scanSeparator();		
				}
				break;
				
			case 12:
				if (eot) {
					System.exit(4);
				}
				if (currentChar != '*') {
					skipIt();
					scanSeparator();
				} else {
					commentState = 13;
					scanSeparator();
				}
				break;
			
			case 13:
				if (eot) {
					System.exit(4);
				}
				if (currentChar != '/') {
					skipIt();
					commentState = 12;
					scanSeparator();
				} else {
					commentState = 0;
					isComment = false;
					scanSeparator();
				}
				break;	
		}		
	}
	

	public Token scan() {
		// skip whitespace and comments
		scanSeparator();

		// start of a token: collect spelling and identify token kind
		currentSpelling = new StringBuilder();
		TokenKind kind = scanToken();
		String spelling = currentSpelling.toString();
		
		if (kind == TokenKind.ID) {
			switch (spelling) {
			case "class":
				kind = TokenKind.CLASS;
				break;
			case "public":
				kind = TokenKind.PUBLIC;
				break;
			case "private":
				kind = TokenKind.PRIVATE;
				break;
			case "static":
				kind = TokenKind.STATIC;
				break;
			case "int":
				kind = TokenKind.INT;
				break;
			case "boolean":
				kind = TokenKind.BOOLEAN;
				break;
			case "void":
				kind = TokenKind.VOID;
				break;
			case "this":
				kind = TokenKind.THIS;
				break;
			case "return":
				kind = TokenKind.RETURN;
				break;
			case "if":
				kind = TokenKind.IF;
				break;
			case "else":
				kind = TokenKind.ELSE;
				break;
			case "while":
				kind = TokenKind.WHILE;
				break;
			case "true":
				kind = TokenKind.TRUE;
				break;
			case "false":
				kind = TokenKind.FALSE;
				break;
			default:
				String[] ss = {"class","public","private","static","int","boolean","void","this","return","if","else","while","true","false"};
				for (String s : ss) {
					if (spelling.toLowerCase().equals(s)) {
						reporter.reportError("Key word should not be used as identifiers.");
						System.exit(4);
					}
				}
				break;
			}
		}

		// return new token
		return new Token(kind, spelling);
	}

	
	/**
	 * determine token kind
	 */
	public TokenKind scanToken() {
		if (eot) {
			return TokenKind.EOT; 
		}
			
		switch (currentChar) {
			case 'a':  case 'b':  case 'c':  case 'd':
			case 'e':  case 'f':  case 'g':  case 'h':
			case 'i':  case 'j':  case 'k':  case 'l':
			case 'm':  case 'n':  case 'o':  case 'p':
			case 'q':  case 'r':  case 's':  case 't':
	        case 'u':  case 'v':  case 'w':  case 'x':
	        case 'y':  case 'z':
	        
	        case 'A':  case 'B':  case 'C':  case 'D':
	        case 'E':  case 'F':  case 'G':  case 'H':
	        case 'I':  case 'J':  case 'K':  case 'L':
	        case 'M':  case 'N':  case 'O':	 case 'P':
	        case 'Q':  case 'R':  case 'S':  case 'T':
	        case 'U':  case 'V':  case 'W':  case 'X':
	        case 'Y':  case 'Z':
	        	takeIt();
	        	while(Character.isLetter(currentChar) 
	        			|| Character.isDigit(currentChar)
	        				|| currentChar == '_') {
	        		takeIt();
	        	}
	        	return TokenKind.ID;
	        
	        case '0':  case '1':  case '2':  case '3':  case '4':
	        case '5':  case '6':  case '7':  case '8':  case '9':
	            takeIt();
	            while(Character.isDigit(currentChar)) {
	            	takeIt();
	            }
	            return TokenKind.NUM;
	        
	        case '>': case '<': case '=':
	            takeIt();
	            if(currentChar == '=') {
	                takeIt();
	                return TokenKind.BINOP;
	            }
	            return TokenKind.BINOP;
	        
	        case '+': case '*': case '/':
	        	takeIt();
	        	return TokenKind.BINOP;
	        
	        case '&':
	            takeIt();
	            if(currentChar != '&') {
	                System.exit(4);
	            }
	            takeIt();
	            return TokenKind.BINOP;

	        case '|':
	            takeIt();
	            if(currentChar != '|')
	                System.exit(4);
	            takeIt();
	            return TokenKind.BINOP;
	        
	        case '!':
	            takeIt();
	            if(currentChar == '=') {
	                takeIt();
	                return TokenKind.BINOP;
	            }
	            return TokenKind.UNOP;
	            
	        case '-':
	            takeIt();
	            return TokenKind.MINUS;
	        
	        case '.':
	            takeIt();
	            return TokenKind.DOT;

	        case ',':
	            takeIt();
	            return TokenKind.COMMA;

	        case ';':
	            takeIt();
	            return TokenKind.SEMICOLON;

	        case '(':
	            takeIt();
	            return TokenKind.LPAREN;

	        case ')':
	            takeIt();
	            return TokenKind.RPAREN;

	        case '[':
	            takeIt();
	            return TokenKind.LBRACKET;

	        case ']':
	            takeIt();
	            return TokenKind.RBRACKET;

	        case '{':
	            takeIt();
	            return TokenKind.LCURLY;

	        case '}':
	            takeIt();
	            return TokenKind.RCURLY;
	        
	        default:
				scanError("Unrecognized character '" + currentChar + "' in input");
				return TokenKind.ERROR; 
		}
	}

	
	private void takeIt() {
		currentSpelling.append(currentChar);
		nextChar();
	}
	
	private void take(char expectedChar) {
		if (currentChar == expectedChar) {
			takeIt();
		}
	}

	private void skipIt() {
		nextChar();
	}


	private void scanError(String m) {
		reporter.reportError("Scan Error:  " + m);
	}


	private final static char eolUnix = '\n';
	private final static char eolWindows = '\r';

	/**
	 * advance to next char in inputstream
	 * detect end of file or end of line as end of input
	 */
	private void nextChar() {
		if (!eot)
			readChar();
	}

	private void readChar() {
		try {
			int c = inputStream.read();
			currentChar = (char) c;
			if (c == -1 || currentChar == eolUnix || currentChar == eolWindows) {
				eot = true;
			}
		} catch (IOException e) {
			scanError("I/O Exception!");
			eot = true;
		}
	}
	


}
]]></snapshot>
  </Command>
  <Command __id="387" _type="MoveCaretCommand" caretOffset="6451" date="Thu Feb 24 14:58:25 EST 2022" docOffset="6602" starttimestamp="1645728958172" timestamp="3747075" />
  <Command __id="388" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:58:35 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="3757769">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="395" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:58:54 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="3775925">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="396" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:59:02 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="3783876">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="390" _type="RunCommand" date="Thu Feb 24 14:58:38 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3760735" type="Run" />
  <Command __id="391" _type="RunCommand" date="Thu Feb 24 14:58:38 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3760735" type="Run" />
  <Command __id="392" _type="RunCommand" date="Thu Feb 24 14:58:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3760842" type="Run" />
  <Command __id="393" _type="RunCommand" date="Thu Feb 24 14:58:39 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3760842" type="Run" />
  <Command __id="394" _type="EHExceptionCommand" date="Thu Feb 24 14:58:39 EST 2022" starttimestamp="1645728958172" timestamp="3760889" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
Parse error: Parsing  and expecting 'RCURLY' but found 'EOT'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="397" _type="MoveCaretCommand" caretOffset="212" date="Thu Feb 24 14:59:02 EST 2022" docOffset="212" starttimestamp="1645728958172" timestamp="3783954" />
  <Command __id="399" _type="MoveCaretCommand" caretOffset="6451" date="Thu Feb 24 14:59:03 EST 2022" docOffset="6602" starttimestamp="1645728958172" timestamp="3785455" />
  <Command __id="401" _type="ShellCommand" date="Thu Feb 24 14:59:06 EST 2022" starttimestamp="1645728958172" timestamp="3788687" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="402" _type="ShellCommand" date="Thu Feb 24 14:59:07 EST 2022" starttimestamp="1645728958172" timestamp="3788929" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="403" _type="MoveCaretCommand" caretOffset="5843" date="Thu Feb 24 14:59:07 EST 2022" docOffset="5994" starttimestamp="1645728958172" timestamp="3789060" />
  <Command __id="405" _type="InsertStringCommand" date="Thu Feb 24 14:59:07 EST 2022" starttimestamp="1645728958172" timestamp="3789283" timestamp2="3789283">
    <data><![CDATA[E]]></data>
  </Command>
  <Command __id="407" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 14:59:08 EST 2022" starttimestamp="1645728958172" timestamp="3790064" />
  <Command __id="408" _type="ShellCommand" date="Thu Feb 24 14:59:10 EST 2022" starttimestamp="1645728958172" timestamp="3792192" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="409" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:59:11 EST 2022" forward="false" matchWord="true" offset="5994" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3793771" wrapSearch="false">
    <searchString><![CDATA[EOT]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="410" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:59:16 EST 2022" forward="false" matchWord="true" offset="4324" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3798324" wrapSearch="false">
    <searchString><![CDATA[EOT]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="411" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 14:59:17 EST 2022" forward="false" matchWord="true" offset="4324" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="3799011" wrapSearch="false">
    <searchString><![CDATA[EOT]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="412" _type="ShellCommand" date="Thu Feb 24 14:59:18 EST 2022" starttimestamp="1645728958172" timestamp="3800328" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="413" _type="MoveCaretCommand" caretOffset="8195" date="Thu Feb 24 14:59:58 EST 2022" docOffset="8346" starttimestamp="1645728958172" timestamp="3840712" />
  <Command __id="414" _type="MoveCaretCommand" caretOffset="7959" date="Thu Feb 24 15:00:17 EST 2022" docOffset="8110" starttimestamp="1645728958172" timestamp="3859264" />
  <Command __id="415" _type="SelectTextCommand" caretOffset="7963" date="Thu Feb 24 15:00:17 EST 2022" end="7963" start="7955" starttimestamp="1645728958172" timestamp="3859449" />
  <Command __id="398" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 14:59:03 EST 2022" docASTNodeCount="1049" docActiveCodeLength="7686" docExpressionCount="643" docLength="8416" projectName="pa1" starttimestamp="1645728958172" timestamp="3785377">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Scanner.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import java.io.IOException;¶import java.io.InputStream;¶¶import miniJava.ErrorReporter;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Scanner {¶	private boolean isComment;¶	¶//	comment state = 0 not comment¶//			= 1 show /¶//			= 2 show second /¶//			= 12 show first *¶//			= 13 show second *¶//			= 3 show third /¶//			= 4 show fourth / end of comment¶//			= 14 show second / end of comment¶	private int commentState;¶	¶	private InputStream inputStream;¶	private ErrorReporter reporter;¶	¶	private char currentChar;¶	private byte currentKind;¶	private StringBuilder currentSpelling;¶	¶	// true when end of line is found¶	private boolean eot = false; ¶	¶	public Scanner(InputStream inputStream, ErrorReporter reporter) {¶		this.isComment = false;¶		this.commentState = 0;¶		this.inputStream = inputStream;¶		this.reporter = reporter;¶¶		// initialize scanner state¶		readChar();¶	}	¶	¶	/**¶	 * skip whitespace and scan next token¶	 */	¶	¶// ? SINGLE SLASH¶//	comment state = 0 not comment¶//	= 1 show /¶//	= 2 show second /¶//	= 12 show first *¶//	= 13 show second *¶//	= 14 show second / end of comment¶	public void scanSeparator() {¶		switch (commentState) {¶			case 0:¶				while (!eot && ¶						(currentChar == ' ' ||¶							currentChar == '\t' ||¶								currentChar == '\n' ||¶									currentChar == '\r')) {¶					skipIt();¶				}¶				if (currentChar == '/') {¶					commentState = 1;¶					skipIt();¶					scanSeparator();¶				}¶				break;¶			¶			case 1:¶				if (currentChar == '/') {¶					commentState = 2;¶					isComment = true;¶					skipIt();¶					scanSeparator();¶				} else if (currentChar == '*') {¶					commentState = 12;¶					isComment = true;¶					skipIt();¶					scanSeparator();¶				} else {¶					System.exit(4);¶				}¶				break;¶			¶			case 2:¶				if (currentChar == '\r' || currentChar == '\n' || eot) {¶					commentState = 0;¶					isComment = false;¶					scanSeparator();¶				} else {¶					skipIt();¶					scanSeparator();		¶				}¶				break;¶				¶			case 12:¶				if (eot) {¶					System.exit(4);¶				}¶				if (currentChar != '*') {¶					skipIt();¶					scanSeparator();¶				} else {¶					commentState = 13;¶					scanSeparator();¶				}¶				break;¶			¶			case 13:¶				if (eot) {¶					System.exit(4);¶				}¶				if (currentChar != '/') {¶					skipIt();¶					commentState = 12;¶					scanSeparator();¶				} else {¶					commentState = 0;¶					isComment = false;¶					scanSeparator();¶				}¶				break;	¶		}		¶	}¶	¶¶	public Token scan() {¶		// skip whitespace and comments¶		scanSeparator();¶¶		// start of a token: collect spelling and identify token kind¶		currentSpelling = new StringBuilder();¶		TokenKind kind = scanToken();¶		String spelling = currentSpelling.toString();¶		¶		if (kind == TokenKind.ID) {¶			switch (spelling) {¶			case "class":¶				kind = TokenKind.CLASS;¶				break;¶			case "public":¶				kind = TokenKind.PUBLIC;¶				break;¶			case "private":¶				kind = TokenKind.PRIVATE;¶				break;¶			case "static":¶				kind = TokenKind.STATIC;¶				break;¶			case "int":¶				kind = TokenKind.INT;¶				break;¶			case "boolean":¶				kind = TokenKind.BOOLEAN;¶				break;¶			case "void":¶				kind = TokenKind.VOID;¶				break;¶			case "this":¶				kind = TokenKind.THIS;¶				break;¶			case "return":¶				kind = TokenKind.RETURN;¶				break;¶			case "if":¶				kind = TokenKind.IF;¶				break;¶			case "else":¶				kind = TokenKind.ELSE;¶				break;¶			case "while":¶				kind = TokenKind.WHILE;¶				break;¶			case "true":¶				kind = TokenKind.TRUE;¶				break;¶			case "false":¶				kind = TokenKind.FALSE;¶				break;¶			default:¶				String[] ss = {"class","public","private","static","int","boolean","void","this","return","if","else","while","true","false"};¶				for (String s : ss) {¶					if (spelling.toLowerCase().equals(s)) {¶						reporter.reportError("Key word should not be used as identifiers.");¶						System.exit(4);¶					}¶				}¶				break;¶			}¶		}¶¶		// return new token¶		return new Token(kind, spelling);¶	}¶¶	¶	/**¶	 * determine token kind¶	 */¶	public TokenKind scanToken() {¶		if (eot) {¶			return TokenKind.EOT; ¶		}¶			¶		switch (currentChar) {¶			case 'a':  case 'b':  case 'c':  case 'd':¶			case 'e':  case 'f':  case 'g':  case 'h':¶			case 'i':  case 'j':  case 'k':  case 'l':¶			case 'm':  case 'n':  case 'o':  case 'p':¶			case 'q':  case 'r':  case 's':  case 't':¶	        case 'u':  case 'v':  case 'w':  case 'x':¶	        case 'y':  case 'z':¶	        ¶	        case 'A':  case 'B':  case 'C':  case 'D':¶	        case 'E':  case 'F':  case 'G':  case 'H':¶	        case 'I':  case 'J':  case 'K':  case 'L':¶	        case 'M':  case 'N':  case 'O':	 case 'P':¶	        case 'Q':  case 'R':  case 'S':  case 'T':¶	        case 'U':  case 'V':  case 'W':  case 'X':¶	        case 'Y':  case 'Z':¶	        	takeIt();¶	        	while(Character.isLetter(currentChar) ¶	        			|| Character.isDigit(currentChar)¶	        				|| currentChar == '_') {¶	        		takeIt();¶	        	}¶	        	return TokenKind.ID;¶	        ¶	        case '0':  case '1':  case '2':  case '3':  case '4':¶	        case '5':  case '6':  case '7':  case '8':  case '9':¶	            takeIt();¶	            while(Character.isDigit(currentChar)) {¶	            	takeIt();¶	            }¶	            return TokenKind.NUM;¶	        ¶	        case '>': case '<': case '=':¶	            takeIt();¶	            if(currentChar == '=') {¶	                takeIt();¶	                return TokenKind.BINOP;¶	            }¶	            return TokenKind.BINOP;¶	        ¶	        case '+': case '*': case '/':¶	        	takeIt();¶	        	return TokenKind.BINOP;¶	        ¶	        case '&':¶	            takeIt();¶	            if(currentChar != '&') {¶	                System.exit(4);¶	            }¶	            takeIt();¶	            return TokenKind.BINOP;¶¶	        case '|':¶	            takeIt();¶	            if(currentChar != '|')¶	                System.exit(4);¶	            takeIt();¶	            return TokenKind.BINOP;¶	        ¶	        case '!':¶	            takeIt();¶	            if(currentChar == '=') {¶	                takeIt();¶	                return TokenKind.BINOP;¶	            }¶	            return TokenKind.UNOP;¶	            ¶	        case '-':¶	            takeIt();¶	            return TokenKind.MINUS;¶	        ¶	        case '.':¶	            takeIt();¶	            return TokenKind.DOT;¶¶	        case ',':¶	            takeIt();¶	            return TokenKind.COMMA;¶¶	        case ';':¶	            takeIt();¶	            return TokenKind.SEMICOLON;¶¶	        case '(':¶	            takeIt();¶	            return TokenKind.LPAREN;¶¶	        case ')':¶	            takeIt();¶	            return TokenKind.RPAREN;¶¶	        case '[':¶	            takeIt();¶	            return TokenKind.LBRACKET;¶¶	        case ']':¶	            takeIt();¶	            return TokenKind.RBRACKET;¶¶	        case '{':¶	            takeIt();¶	            return TokenKind.LCURLY;¶¶	        case '}':¶	            takeIt();¶	            return TokenKind.RCURLY;¶	        ¶	        default:¶				scanError("Unrecognized character '" + currentChar + "' in input");¶				return TokenKind.ERROR; ¶		}¶	}¶¶	¶	private void takeIt() {¶		currentSpelling.append(currentChar);¶		nextChar();¶	}¶	¶	private void take(char expectedChar) {¶		if (currentChar == expectedChar) {¶			takeIt();¶		}¶	}¶¶	private void skipIt() {¶		nextChar();¶	}¶¶¶	private void scanError(String m) {¶		reporter.reportError("Scan Error:  " + m);¶	}¶¶¶	private final static char eolUnix = '\n';¶	private final static char eolWindows = '\r';¶¶	/**¶	 * advance to next char in inputstream¶	 * detect end of file or end of line as end of input¶	 */¶	private void nextChar() {¶		if (!eot)¶			readChar();¶	}¶¶	private void readChar() {¶		try {¶			int c = inputStream.read();¶			currentChar = (char) c;¶			if (c == -1 || currentChar == eolUnix || currentChar == eolWindows) {¶				eot = true;¶			}¶		} catch (IOException e) {¶			scanError("I/O Exception!");¶			eot = true;¶		}¶	}¶	¶¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="404" _type="Insert" date="Thu Feb 24 14:59:07 EST 2022" docASTNodeCount="672" docActiveCodeLength="7687" docExpressionCount="409" docLength="8417" length="1" offset="5994" starttimestamp="1645728958172" timestamp="3789283">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <DocumentChange __id="406" _type="Delete" date="Thu Feb 24 14:59:08 EST 2022" docASTNodeCount="1049" docActiveCodeLength="7686" docExpressionCount="643" docLength="8416" endLine="252" length="1" offset="5994" startLine="252" starttimestamp="1645728958172" timestamp="3790064">
    <text><![CDATA[E]]></text>
  </DocumentChange>
  <DocumentChange __id="417" _type="Insert" date="Thu Feb 24 15:00:33 EST 2022" docASTNodeCount="1049" docActiveCodeLength="7691" docExpressionCount="643" docLength="8421" length="5" offset="8192" starttimestamp="1645728958172" timestamp="3874950">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <DocumentChange __id="419" _type="Insert" date="Thu Feb 24 15:00:35 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7692" docExpressionCount="643" docLength="8422" length="1" offset="8197" starttimestamp="1645728958172" timestamp="3877671">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="421" _type="Insert" date="Thu Feb 24 15:00:36 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7693" docExpressionCount="643" docLength="8423" length="1" offset="8198" starttimestamp="1645728958172" timestamp="3878056">
    <text><![CDATA[Y]]></text>
  </DocumentChange>
  <DocumentChange __id="423" _type="Delete" date="Thu Feb 24 15:00:36 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7692" docExpressionCount="643" docLength="8422" endLine="356" length="1" offset="8198" startLine="356" starttimestamp="1645728958172" timestamp="3878573">
    <text><![CDATA[Y]]></text>
  </DocumentChange>
  <DocumentChange __id="425" _type="Insert" date="Thu Feb 24 15:00:37 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7693" docExpressionCount="643" docLength="8423" length="1" offset="8198" starttimestamp="1645728958172" timestamp="3878849">
    <text><![CDATA[y]]></text>
  </DocumentChange>
  <DocumentChange __id="427" _type="Insert" date="Thu Feb 24 15:00:37 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7694" docExpressionCount="643" docLength="8424" length="1" offset="8199" starttimestamp="1645728958172" timestamp="3879059">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="429" _type="Insert" date="Thu Feb 24 15:00:37 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7695" docExpressionCount="643" docLength="8425" length="1" offset="8200" starttimestamp="1645728958172" timestamp="3879174">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="431" _type="Delete" date="Thu Feb 24 15:00:37 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7694" docExpressionCount="643" docLength="8424" endLine="356" length="1" offset="8200" startLine="356" starttimestamp="1645728958172" timestamp="3879529">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="433" _type="Delete" date="Thu Feb 24 15:00:37 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7693" docExpressionCount="643" docLength="8423" endLine="356" length="1" offset="8199" startLine="356" starttimestamp="1645728958172" timestamp="3879660">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="435" _type="Insert" date="Thu Feb 24 15:00:37 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7694" docExpressionCount="643" docLength="8424" length="1" offset="8199" starttimestamp="1645728958172" timestamp="3879707">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="437" _type="Insert" date="Thu Feb 24 15:00:38 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7695" docExpressionCount="643" docLength="8425" length="1" offset="8200" starttimestamp="1645728958172" timestamp="3879861">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="439" _type="Insert" date="Thu Feb 24 15:00:38 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7696" docExpressionCount="643" docLength="8426" length="1" offset="8201" starttimestamp="1645728958172" timestamp="3879961">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="441" _type="Insert" date="Thu Feb 24 15:00:38 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7697" docExpressionCount="643" docLength="8427" length="1" offset="8202" starttimestamp="1645728958172" timestamp="3880147">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="443" _type="Insert" date="Thu Feb 24 15:00:39 EST 2022" docASTNodeCount="1051" docActiveCodeLength="7698" docExpressionCount="645" docLength="8428" length="1" offset="8203" starttimestamp="1645728958172" timestamp="3880949">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="446" _type="Insert" date="Thu Feb 24 15:00:39 EST 2022" docASTNodeCount="1053" docActiveCodeLength="7699" docExpressionCount="645" docLength="8429" length="1" offset="8204" starttimestamp="1645728958172" timestamp="3881529">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="447" _type="Insert" date="Thu Feb 24 15:00:39 EST 2022" docASTNodeCount="1053" docActiveCodeLength="7700" docExpressionCount="645" docLength="8430" length="1" offset="8205" starttimestamp="1645728958172" timestamp="3881667">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="448" _type="Insert" date="Thu Feb 24 15:00:39 EST 2022" docASTNodeCount="1053" docActiveCodeLength="7701" docExpressionCount="645" docLength="8431" length="1" offset="8206" starttimestamp="1645728958172" timestamp="3881798">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="450" _type="Replace" date="Thu Feb 24 15:00:40 EST 2022" docASTNodeCount="1053" docActiveCodeLength="7702" docExpressionCount="647" docLength="8432" endLine="356" insertionLength="4" int_docASTNodeCount="1051" int_docActiveCodeLength="7698" int_docExpressionCount="645" int_docLength="8428" length="3" offset="8204" startLine="356" starttimestamp="1645728958172" timestamp="3882442">
    <deletedText><![CDATA[out]]></deletedText>
    <insertedText><![CDATA[out.]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="453" _type="Insert" date="Thu Feb 24 15:00:41 EST 2022" docASTNodeCount="1055" docActiveCodeLength="7703" docExpressionCount="647" docLength="8433" length="1" offset="8208" starttimestamp="1645728958172" timestamp="3882846">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="454" _type="Insert" date="Thu Feb 24 15:00:41 EST 2022" docASTNodeCount="1055" docActiveCodeLength="7704" docExpressionCount="647" docLength="8434" length="1" offset="8209" starttimestamp="1645728958172" timestamp="3882994">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="455" _type="Insert" date="Thu Feb 24 15:00:41 EST 2022" docASTNodeCount="1055" docActiveCodeLength="7705" docExpressionCount="647" docLength="8435" length="1" offset="8210" starttimestamp="1645728958172" timestamp="3883110">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="456" _type="Insert" date="Thu Feb 24 15:00:41 EST 2022" docASTNodeCount="1055" docActiveCodeLength="7706" docExpressionCount="647" docLength="8436" length="1" offset="8211" starttimestamp="1645728958172" timestamp="3883179">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="457" _type="Insert" date="Thu Feb 24 15:00:41 EST 2022" docASTNodeCount="1055" docActiveCodeLength="7707" docExpressionCount="647" docLength="8437" length="1" offset="8212" starttimestamp="1645728958172" timestamp="3883279">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="458" _type="Delete" date="Thu Feb 24 15:00:41 EST 2022" docASTNodeCount="1055" docActiveCodeLength="7706" docExpressionCount="647" docLength="8436" endLine="356" length="1" offset="8212" startLine="356" starttimestamp="1645728958172" timestamp="3883707">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="459" _type="Insert" date="Thu Feb 24 15:00:42 EST 2022" docASTNodeCount="1055" docActiveCodeLength="7707" docExpressionCount="647" docLength="8437" length="1" offset="8212" starttimestamp="1645728958172" timestamp="3884335">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="461" _type="Replace" date="Thu Feb 24 15:00:43 EST 2022" docASTNodeCount="1056" docActiveCodeLength="7711" docExpressionCount="649" docLength="8441" endLine="356" insertionLength="9" int_docASTNodeCount="1053" int_docActiveCodeLength="7702" int_docExpressionCount="647" int_docLength="8432" length="5" offset="8208" startLine="356" starttimestamp="1645728958172" timestamp="3885099">
    <deletedText><![CDATA[print]]></deletedText>
    <insertedText><![CDATA[print(b);]]></insertedText>
  </DocumentChange>
  <Command __id="416" _type="MoveCaretCommand" caretOffset="8041" date="Thu Feb 24 15:00:32 EST 2022" docOffset="8192" starttimestamp="1645728958172" timestamp="3874596" />
  <Command __id="418" _type="InsertStringCommand" date="Thu Feb 24 15:00:33 EST 2022" starttimestamp="1645728958172" timestamp="3874965" timestamp2="3874965">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="420" _type="InsertStringCommand" date="Thu Feb 24 15:00:35 EST 2022" starttimestamp="1645728958172" timestamp="3877671" timestamp2="3877671">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="422" _type="InsertStringCommand" date="Thu Feb 24 15:00:36 EST 2022" starttimestamp="1645728958172" timestamp="3878056" timestamp2="3878056">
    <data><![CDATA[Y]]></data>
  </Command>
  <Command __id="424" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 15:00:36 EST 2022" starttimestamp="1645728958172" timestamp="3878573" />
  <Command __id="426" _type="InsertStringCommand" date="Thu Feb 24 15:00:37 EST 2022" starttimestamp="1645728958172" timestamp="3878853" timestamp2="3878853">
    <data><![CDATA[y]]></data>
  </Command>
  <Command __id="428" _type="InsertStringCommand" date="Thu Feb 24 15:00:37 EST 2022" starttimestamp="1645728958172" timestamp="3879059" timestamp2="3879059">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="430" _type="InsertStringCommand" date="Thu Feb 24 15:00:37 EST 2022" starttimestamp="1645728958172" timestamp="3879174" timestamp2="3879174">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="432" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 15:00:37 EST 2022" starttimestamp="1645728958172" timestamp="3879529" />
  <Command __id="434" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Thu Feb 24 15:00:37 EST 2022" starttimestamp="1645728958172" timestamp="3879660" />
  <Command __id="436" _type="InsertStringCommand" date="Thu Feb 24 15:00:37 EST 2022" starttimestamp="1645728958172" timestamp="3879707" timestamp2="3879707">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="438" _type="InsertStringCommand" date="Thu Feb 24 15:00:38 EST 2022" starttimestamp="1645728958172" timestamp="3879861" timestamp2="3879861">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="440" _type="InsertStringCommand" date="Thu Feb 24 15:00:38 EST 2022" starttimestamp="1645728958172" timestamp="3879961" timestamp2="3879961">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="442" _type="InsertStringCommand" date="Thu Feb 24 15:00:38 EST 2022" starttimestamp="1645728958172" timestamp="3880147" timestamp2="3880147">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="444" _type="InsertStringCommand" date="Thu Feb 24 15:00:39 EST 2022" starttimestamp="1645728958172" timestamp="3880965" timestamp2="3880965">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="445" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 15:00:39 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="3880965" />
  <Command __id="449" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 15:00:40 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="3882442" />
  <Command __id="451" _type="InsertStringCommand" date="Thu Feb 24 15:00:40 EST 2022" starttimestamp="1645728958172" timestamp="3882458" timestamp2="3882458">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="452" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 15:00:40 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="3882473" />
  <Command __id="460" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 15:00:43 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="3885099" />
  <Command __id="462" _type="InsertStringCommand" date="Thu Feb 24 15:00:43 EST 2022" starttimestamp="1645728958172" timestamp="3885149" timestamp2="3885149">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="464" _type="InsertStringCommand" date="Thu Feb 24 15:00:44 EST 2022" starttimestamp="1645728958172" timestamp="3886810" timestamp2="3886810">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="463" _type="Replace" date="Thu Feb 24 15:00:44 EST 2022" docASTNodeCount="1056" docActiveCodeLength="7711" docExpressionCount="649" docLength="8441" endLine="356" insertionLength="1" int_docASTNodeCount="1055" int_docActiveCodeLength="7710" int_docExpressionCount="648" int_docLength="8440" length="1" offset="8214" startLine="356" starttimestamp="1645728958172" timestamp="3886810">
    <deletedText><![CDATA[b]]></deletedText>
    <insertedText><![CDATA[c]]></insertedText>
  </DocumentChange>
  <Command __id="465" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Feb 24 15:00:46 EST 2022" starttimestamp="1645728958172" timestamp="3887997" />
  <Command __id="466" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 15:00:46 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="3888028" />
  <Command __id="467" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:00:46 EST 2022" starttimestamp="1645728958172" timestamp="3888113" />
  <Command __id="468" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:00:46 EST 2022" starttimestamp="1645728958172" timestamp="3888129" />
  <Command __id="469" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:00:48 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="3890655">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="471" _type="RunCommand" date="Thu Feb 24 15:00:50 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3892191" type="Run" />
  <Command __id="472" _type="RunCommand" date="Thu Feb 24 15:00:50 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3892191" type="Run" />
  <Command __id="473" _type="RunCommand" date="Thu Feb 24 15:00:50 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3892291" type="Run" />
  <Command __id="474" _type="RunCommand" date="Thu Feb 24 15:00:50 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="3892291" type="Run" />
  <Command __id="475" _type="EHExceptionCommand" date="Thu Feb 24 15:00:50 EST 2022" starttimestamp="1645728958172" timestamp="3892344" type="Exception">
    <outputString><![CDATA[99Syntactic analysis ... 
108971151153269114114111114821011121111141161011143212313Parse error: Parsing  and expecting 'RCURLY' but found 'EOT'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="477" _type="MoveCaretCommand" caretOffset="8064" date="Thu Feb 24 15:00:56 EST 2022" docOffset="8215" starttimestamp="1645728958172" timestamp="3898231" />
  <Command __id="478" _type="MoveCaretCommand" caretOffset="8066" date="Thu Feb 24 15:01:23 EST 2022" docOffset="8217" starttimestamp="1645728958172" timestamp="3924832" />
  <Command __id="480" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.delete.line" date="Thu Feb 24 15:01:23 EST 2022" starttimestamp="1645728958172" timestamp="3925327" />
  <Command __id="481" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Feb 24 15:01:24 EST 2022" starttimestamp="1645728958172" timestamp="3926649" />
  <Command __id="482" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:01:24 EST 2022" starttimestamp="1645728958172" timestamp="3926750" />
  <Command __id="483" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:01:24 EST 2022" starttimestamp="1645728958172" timestamp="3926765" />
  <Command __id="484" _type="MoveCaretCommand" caretOffset="8160" date="Thu Feb 24 15:01:25 EST 2022" docOffset="8311" starttimestamp="1645728958172" timestamp="3927648" />
  <Command __id="485" _type="ShellCommand" date="Thu Feb 24 15:02:30 EST 2022" starttimestamp="1645728958172" timestamp="3992488" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="486" _type="ShellCommand" date="Thu Feb 24 15:02:31 EST 2022" starttimestamp="1645728958172" timestamp="3993019" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="487" _type="ShellCommand" date="Thu Feb 24 15:02:32 EST 2022" starttimestamp="1645728958172" timestamp="3994475" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="476" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:00:56 EST 2022" docASTNodeCount="1056" docActiveCodeLength="7711" docExpressionCount="649" docLength="8441" projectName="pa1" starttimestamp="1645728958172" timestamp="3898162">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Scanner.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import java.io.IOException;¶import java.io.InputStream;¶¶import miniJava.ErrorReporter;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Scanner {¶	private boolean isComment;¶	¶//	comment state = 0 not comment¶//			= 1 show /¶//			= 2 show second /¶//			= 12 show first *¶//			= 13 show second *¶//			= 3 show third /¶//			= 4 show fourth / end of comment¶//			= 14 show second / end of comment¶	private int commentState;¶	¶	private InputStream inputStream;¶	private ErrorReporter reporter;¶	¶	private char currentChar;¶	private byte currentKind;¶	private StringBuilder currentSpelling;¶	¶	// true when end of line is found¶	private boolean eot = false; ¶	¶	public Scanner(InputStream inputStream, ErrorReporter reporter) {¶		this.isComment = false;¶		this.commentState = 0;¶		this.inputStream = inputStream;¶		this.reporter = reporter;¶¶		// initialize scanner state¶		readChar();¶	}	¶	¶	/**¶	 * skip whitespace and scan next token¶	 */	¶	¶// ? SINGLE SLASH¶//	comment state = 0 not comment¶//	= 1 show /¶//	= 2 show second /¶//	= 12 show first *¶//	= 13 show second *¶//	= 14 show second / end of comment¶	public void scanSeparator() {¶		switch (commentState) {¶			case 0:¶				while (!eot && ¶						(currentChar == ' ' ||¶							currentChar == '\t' ||¶								currentChar == '\n' ||¶									currentChar == '\r')) {¶					skipIt();¶				}¶				if (currentChar == '/') {¶					commentState = 1;¶					skipIt();¶					scanSeparator();¶				}¶				break;¶			¶			case 1:¶				if (currentChar == '/') {¶					commentState = 2;¶					isComment = true;¶					skipIt();¶					scanSeparator();¶				} else if (currentChar == '*') {¶					commentState = 12;¶					isComment = true;¶					skipIt();¶					scanSeparator();¶				} else {¶					System.exit(4);¶				}¶				break;¶			¶			case 2:¶				if (currentChar == '\r' || currentChar == '\n' || eot) {¶					commentState = 0;¶					isComment = false;¶					scanSeparator();¶				} else {¶					skipIt();¶					scanSeparator();		¶				}¶				break;¶				¶			case 12:¶				if (eot) {¶					System.exit(4);¶				}¶				if (currentChar != '*') {¶					skipIt();¶					scanSeparator();¶				} else {¶					commentState = 13;¶					scanSeparator();¶				}¶				break;¶			¶			case 13:¶				if (eot) {¶					System.exit(4);¶				}¶				if (currentChar != '/') {¶					skipIt();¶					commentState = 12;¶					scanSeparator();¶				} else {¶					commentState = 0;¶					isComment = false;¶					scanSeparator();¶				}¶				break;	¶		}		¶	}¶	¶¶	public Token scan() {¶		// skip whitespace and comments¶		scanSeparator();¶¶		// start of a token: collect spelling and identify token kind¶		currentSpelling = new StringBuilder();¶		TokenKind kind = scanToken();¶		String spelling = currentSpelling.toString();¶		¶		if (kind == TokenKind.ID) {¶			switch (spelling) {¶			case "class":¶				kind = TokenKind.CLASS;¶				break;¶			case "public":¶				kind = TokenKind.PUBLIC;¶				break;¶			case "private":¶				kind = TokenKind.PRIVATE;¶				break;¶			case "static":¶				kind = TokenKind.STATIC;¶				break;¶			case "int":¶				kind = TokenKind.INT;¶				break;¶			case "boolean":¶				kind = TokenKind.BOOLEAN;¶				break;¶			case "void":¶				kind = TokenKind.VOID;¶				break;¶			case "this":¶				kind = TokenKind.THIS;¶				break;¶			case "return":¶				kind = TokenKind.RETURN;¶				break;¶			case "if":¶				kind = TokenKind.IF;¶				break;¶			case "else":¶				kind = TokenKind.ELSE;¶				break;¶			case "while":¶				kind = TokenKind.WHILE;¶				break;¶			case "true":¶				kind = TokenKind.TRUE;¶				break;¶			case "false":¶				kind = TokenKind.FALSE;¶				break;¶			default:¶				String[] ss = {"class","public","private","static","int","boolean","void","this","return","if","else","while","true","false"};¶				for (String s : ss) {¶					if (spelling.toLowerCase().equals(s)) {¶						reporter.reportError("Key word should not be used as identifiers.");¶						System.exit(4);¶					}¶				}¶				break;¶			}¶		}¶¶		// return new token¶		return new Token(kind, spelling);¶	}¶¶	¶	/**¶	 * determine token kind¶	 */¶	public TokenKind scanToken() {¶		if (eot) {¶			return TokenKind.EOT; ¶		}¶			¶		switch (currentChar) {¶			case 'a':  case 'b':  case 'c':  case 'd':¶			case 'e':  case 'f':  case 'g':  case 'h':¶			case 'i':  case 'j':  case 'k':  case 'l':¶			case 'm':  case 'n':  case 'o':  case 'p':¶			case 'q':  case 'r':  case 's':  case 't':¶	        case 'u':  case 'v':  case 'w':  case 'x':¶	        case 'y':  case 'z':¶	        ¶	        case 'A':  case 'B':  case 'C':  case 'D':¶	        case 'E':  case 'F':  case 'G':  case 'H':¶	        case 'I':  case 'J':  case 'K':  case 'L':¶	        case 'M':  case 'N':  case 'O':	 case 'P':¶	        case 'Q':  case 'R':  case 'S':  case 'T':¶	        case 'U':  case 'V':  case 'W':  case 'X':¶	        case 'Y':  case 'Z':¶	        	takeIt();¶	        	while(Character.isLetter(currentChar) ¶	        			|| Character.isDigit(currentChar)¶	        				|| currentChar == '_') {¶	        		takeIt();¶	        	}¶	        	return TokenKind.ID;¶	        ¶	        case '0':  case '1':  case '2':  case '3':  case '4':¶	        case '5':  case '6':  case '7':  case '8':  case '9':¶	            takeIt();¶	            while(Character.isDigit(currentChar)) {¶	            	takeIt();¶	            }¶	            return TokenKind.NUM;¶	        ¶	        case '>': case '<': case '=':¶	            takeIt();¶	            if(currentChar == '=') {¶	                takeIt();¶	                return TokenKind.BINOP;¶	            }¶	            return TokenKind.BINOP;¶	        ¶	        case '+': case '*': case '/':¶	        	takeIt();¶	        	return TokenKind.BINOP;¶	        ¶	        case '&':¶	            takeIt();¶	            if(currentChar != '&') {¶	                System.exit(4);¶	            }¶	            takeIt();¶	            return TokenKind.BINOP;¶¶	        case '|':¶	            takeIt();¶	            if(currentChar != '|')¶	                System.exit(4);¶	            takeIt();¶	            return TokenKind.BINOP;¶	        ¶	        case '!':¶	            takeIt();¶	            if(currentChar == '=') {¶	                takeIt();¶	                return TokenKind.BINOP;¶	            }¶	            return TokenKind.UNOP;¶	            ¶	        case '-':¶	            takeIt();¶	            return TokenKind.MINUS;¶	        ¶	        case '.':¶	            takeIt();¶	            return TokenKind.DOT;¶¶	        case ',':¶	            takeIt();¶	            return TokenKind.COMMA;¶¶	        case ';':¶	            takeIt();¶	            return TokenKind.SEMICOLON;¶¶	        case '(':¶	            takeIt();¶	            return TokenKind.LPAREN;¶¶	        case ')':¶	            takeIt();¶	            return TokenKind.RPAREN;¶¶	        case '[':¶	            takeIt();¶	            return TokenKind.LBRACKET;¶¶	        case ']':¶	            takeIt();¶	            return TokenKind.RBRACKET;¶¶	        case '{':¶	            takeIt();¶	            return TokenKind.LCURLY;¶¶	        case '}':¶	            takeIt();¶	            return TokenKind.RCURLY;¶	        ¶	        default:¶				scanError("Unrecognized character '" + currentChar + "' in input");¶				return TokenKind.ERROR; ¶		}¶	}¶¶	¶	private void takeIt() {¶		currentSpelling.append(currentChar);¶		nextChar();¶	}¶	¶	private void take(char expectedChar) {¶		if (currentChar == expectedChar) {¶			takeIt();¶		}¶	}¶¶	private void skipIt() {¶		nextChar();¶	}¶¶¶	private void scanError(String m) {¶		reporter.reportError("Scan Error:  " + m);¶	}¶¶¶	private final static char eolUnix = '\n';¶	private final static char eolWindows = '\r';¶¶	/**¶	 * advance to next char in inputstream¶	 * detect end of file or end of line as end of input¶	 */¶	private void nextChar() {¶		if (!eot)¶			readChar();¶	}¶¶	private void readChar() {¶		try {¶			int c = inputStream.read();¶			"), Diff(INSERT,"System.out.print(c);¶			"), Diff(EQUAL,"currentChar = (char) c;¶			if (c == -1 || currentChar == eolUnix || currentChar == eolWindows) {¶				eot = true;¶			}¶		} catch (IOException e) {¶			scanError("I/O Exception!");¶			eot = true;¶		}¶	}¶	¶¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

import java.io.IOException;
import java.io.InputStream;

import miniJava.ErrorReporter;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Scanner {
	private boolean isComment;
	
//	comment state = 0 not comment
//			= 1 show /
//			= 2 show second /
//			= 12 show first *
//			= 13 show second *
//			= 3 show third /
//			= 4 show fourth / end of comment
//			= 14 show second / end of comment
	private int commentState;
	
	private InputStream inputStream;
	private ErrorReporter reporter;
	
	private char currentChar;
	private byte currentKind;
	private StringBuilder currentSpelling;
	
	// true when end of line is found
	private boolean eot = false; 
	
	public Scanner(InputStream inputStream, ErrorReporter reporter) {
		this.isComment = false;
		this.commentState = 0;
		this.inputStream = inputStream;
		this.reporter = reporter;

		// initialize scanner state
		readChar();
	}	
	
	/**
	 * skip whitespace and scan next token
	 */	
	
// ? SINGLE SLASH
//	comment state = 0 not comment
//	= 1 show /
//	= 2 show second /
//	= 12 show first *
//	= 13 show second *
//	= 14 show second / end of comment
	public void scanSeparator() {
		switch (commentState) {
			case 0:
				while (!eot && 
						(currentChar == ' ' ||
							currentChar == '\t' ||
								currentChar == '\n' ||
									currentChar == '\r')) {
					skipIt();
				}
				if (currentChar == '/') {
					commentState = 1;
					skipIt();
					scanSeparator();
				}
				break;
			
			case 1:
				if (currentChar == '/') {
					commentState = 2;
					isComment = true;
					skipIt();
					scanSeparator();
				} else if (currentChar == '*') {
					commentState = 12;
					isComment = true;
					skipIt();
					scanSeparator();
				} else {
					System.exit(4);
				}
				break;
			
			case 2:
				if (currentChar == '\r' || currentChar == '\n' || eot) {
					commentState = 0;
					isComment = false;
					scanSeparator();
				} else {
					skipIt();
					scanSeparator();		
				}
				break;
				
			case 12:
				if (eot) {
					System.exit(4);
				}
				if (currentChar != '*') {
					skipIt();
					scanSeparator();
				} else {
					commentState = 13;
					scanSeparator();
				}
				break;
			
			case 13:
				if (eot) {
					System.exit(4);
				}
				if (currentChar != '/') {
					skipIt();
					commentState = 12;
					scanSeparator();
				} else {
					commentState = 0;
					isComment = false;
					scanSeparator();
				}
				break;	
		}		
	}
	

	public Token scan() {
		// skip whitespace and comments
		scanSeparator();

		// start of a token: collect spelling and identify token kind
		currentSpelling = new StringBuilder();
		TokenKind kind = scanToken();
		String spelling = currentSpelling.toString();
		
		if (kind == TokenKind.ID) {
			switch (spelling) {
			case "class":
				kind = TokenKind.CLASS;
				break;
			case "public":
				kind = TokenKind.PUBLIC;
				break;
			case "private":
				kind = TokenKind.PRIVATE;
				break;
			case "static":
				kind = TokenKind.STATIC;
				break;
			case "int":
				kind = TokenKind.INT;
				break;
			case "boolean":
				kind = TokenKind.BOOLEAN;
				break;
			case "void":
				kind = TokenKind.VOID;
				break;
			case "this":
				kind = TokenKind.THIS;
				break;
			case "return":
				kind = TokenKind.RETURN;
				break;
			case "if":
				kind = TokenKind.IF;
				break;
			case "else":
				kind = TokenKind.ELSE;
				break;
			case "while":
				kind = TokenKind.WHILE;
				break;
			case "true":
				kind = TokenKind.TRUE;
				break;
			case "false":
				kind = TokenKind.FALSE;
				break;
			default:
				String[] ss = {"class","public","private","static","int","boolean","void","this","return","if","else","while","true","false"};
				for (String s : ss) {
					if (spelling.toLowerCase().equals(s)) {
						reporter.reportError("Key word should not be used as identifiers.");
						System.exit(4);
					}
				}
				break;
			}
		}

		// return new token
		return new Token(kind, spelling);
	}

	
	/**
	 * determine token kind
	 */
	public TokenKind scanToken() {
		if (eot) {
			return TokenKind.EOT; 
		}
			
		switch (currentChar) {
			case 'a':  case 'b':  case 'c':  case 'd':
			case 'e':  case 'f':  case 'g':  case 'h':
			case 'i':  case 'j':  case 'k':  case 'l':
			case 'm':  case 'n':  case 'o':  case 'p':
			case 'q':  case 'r':  case 's':  case 't':
	        case 'u':  case 'v':  case 'w':  case 'x':
	        case 'y':  case 'z':
	        
	        case 'A':  case 'B':  case 'C':  case 'D':
	        case 'E':  case 'F':  case 'G':  case 'H':
	        case 'I':  case 'J':  case 'K':  case 'L':
	        case 'M':  case 'N':  case 'O':	 case 'P':
	        case 'Q':  case 'R':  case 'S':  case 'T':
	        case 'U':  case 'V':  case 'W':  case 'X':
	        case 'Y':  case 'Z':
	        	takeIt();
	        	while(Character.isLetter(currentChar) 
	        			|| Character.isDigit(currentChar)
	        				|| currentChar == '_') {
	        		takeIt();
	        	}
	        	return TokenKind.ID;
	        
	        case '0':  case '1':  case '2':  case '3':  case '4':
	        case '5':  case '6':  case '7':  case '8':  case '9':
	            takeIt();
	            while(Character.isDigit(currentChar)) {
	            	takeIt();
	            }
	            return TokenKind.NUM;
	        
	        case '>': case '<': case '=':
	            takeIt();
	            if(currentChar == '=') {
	                takeIt();
	                return TokenKind.BINOP;
	            }
	            return TokenKind.BINOP;
	        
	        case '+': case '*': case '/':
	        	takeIt();
	        	return TokenKind.BINOP;
	        
	        case '&':
	            takeIt();
	            if(currentChar != '&') {
	                System.exit(4);
	            }
	            takeIt();
	            return TokenKind.BINOP;

	        case '|':
	            takeIt();
	            if(currentChar != '|')
	                System.exit(4);
	            takeIt();
	            return TokenKind.BINOP;
	        
	        case '!':
	            takeIt();
	            if(currentChar == '=') {
	                takeIt();
	                return TokenKind.BINOP;
	            }
	            return TokenKind.UNOP;
	            
	        case '-':
	            takeIt();
	            return TokenKind.MINUS;
	        
	        case '.':
	            takeIt();
	            return TokenKind.DOT;

	        case ',':
	            takeIt();
	            return TokenKind.COMMA;

	        case ';':
	            takeIt();
	            return TokenKind.SEMICOLON;

	        case '(':
	            takeIt();
	            return TokenKind.LPAREN;

	        case ')':
	            takeIt();
	            return TokenKind.RPAREN;

	        case '[':
	            takeIt();
	            return TokenKind.LBRACKET;

	        case ']':
	            takeIt();
	            return TokenKind.RBRACKET;

	        case '{':
	            takeIt();
	            return TokenKind.LCURLY;

	        case '}':
	            takeIt();
	            return TokenKind.RCURLY;
	        
	        default:
				scanError("Unrecognized character '" + currentChar + "' in input");
				return TokenKind.ERROR; 
		}
	}

	
	private void takeIt() {
		currentSpelling.append(currentChar);
		nextChar();
	}
	
	private void take(char expectedChar) {
		if (currentChar == expectedChar) {
			takeIt();
		}
	}

	private void skipIt() {
		nextChar();
	}


	private void scanError(String m) {
		reporter.reportError("Scan Error:  " + m);
	}


	private final static char eolUnix = '\n';
	private final static char eolWindows = '\r';

	/**
	 * advance to next char in inputstream
	 * detect end of file or end of line as end of input
	 */
	private void nextChar() {
		if (!eot)
			readChar();
	}

	private void readChar() {
		try {
			int c = inputStream.read();
			System.out.print(c);
			currentChar = (char) c;
			if (c == -1 || currentChar == eolUnix || currentChar == eolWindows) {
				eot = true;
			}
		} catch (IOException e) {
			scanError("I/O Exception!");
			eot = true;
		}
	}
	


}
]]></snapshot>
  </Command>
  <DocumentChange __id="479" _type="Delete" date="Thu Feb 24 15:01:23 EST 2022" docASTNodeCount="1049" docActiveCodeLength="7686" docExpressionCount="643" docLength="8416" endLine="357" length="25" offset="8194" startLine="356" starttimestamp="1645728958172" timestamp="3925311">
    <text><![CDATA[			System.out.print(c);
]]></text>
  </DocumentChange>
  <Command __id="488" _type="ShellCommand" date="Thu Feb 24 15:03:35 EST 2022" starttimestamp="1645728958172" timestamp="4057728" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="490" _type="MoveCaretCommand" caretOffset="212" date="Thu Feb 24 15:03:49 EST 2022" docOffset="212" starttimestamp="1645728958172" timestamp="4070887" />
  <Command __id="489" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:03:48 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="4070818">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="493" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:03:54 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4076101">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="494" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:03:55 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4077652">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="495" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:03:56 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="4078132">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="496" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:03:56 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4078179">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="497" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:03:56 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4078195">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="499" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:04:07 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="4089293">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="506" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:04:10 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4092284">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="507" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:04:33 EST 2022" docASTNodeCount="1049" docActiveCodeLength="7686" docExpressionCount="643" docLength="8416" projectName="pa1" starttimestamp="1645728958172" timestamp="4115695">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Scanner.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import java.io.IOException;¶import java.io.InputStream;¶¶import miniJava.ErrorReporter;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Scanner {¶	private boolean isComment;¶	¶//	comment state = 0 not comment¶//			= 1 show /¶//			= 2 show second /¶//			= 12 show first *¶//			= 13 show second *¶//			= 3 show third /¶//			= 4 show fourth / end of comment¶//			= 14 show second / end of comment¶	private int commentState;¶	¶	private InputStream inputStream;¶	private ErrorReporter reporter;¶	¶	private char currentChar;¶	private byte currentKind;¶	private StringBuilder currentSpelling;¶	¶	// true when end of line is found¶	private boolean eot = false; ¶	¶	public Scanner(InputStream inputStream, ErrorReporter reporter) {¶		this.isComment = false;¶		this.commentState = 0;¶		this.inputStream = inputStream;¶		this.reporter = reporter;¶¶		// initialize scanner state¶		readChar();¶	}	¶	¶	/**¶	 * skip whitespace and scan next token¶	 */	¶	¶// ? SINGLE SLASH¶//	comment state = 0 not comment¶//	= 1 show /¶//	= 2 show second /¶//	= 12 show first *¶//	= 13 show second *¶//	= 14 show second / end of comment¶	public void scanSeparator() {¶		switch (commentState) {¶			case 0:¶				while (!eot && ¶						(currentChar == ' ' ||¶							currentChar == '\t' ||¶								currentChar == '\n' ||¶									currentChar == '\r')) {¶					skipIt();¶				}¶				if (currentChar == '/') {¶					commentState = 1;¶					skipIt();¶					scanSeparator();¶				}¶				break;¶			¶			case 1:¶				if (currentChar == '/') {¶					commentState = 2;¶					isComment = true;¶					skipIt();¶					scanSeparator();¶				} else if (currentChar == '*') {¶					commentState = 12;¶					isComment = true;¶					skipIt();¶					scanSeparator();¶				} else {¶					System.exit(4);¶				}¶				break;¶			¶			case 2:¶				if (currentChar == '\r' || currentChar == '\n' || eot) {¶					commentState = 0;¶					isComment = false;¶					scanSeparator();¶				} else {¶					skipIt();¶					scanSeparator();		¶				}¶				break;¶				¶			case 12:¶				if (eot) {¶					System.exit(4);¶				}¶				if (currentChar != '*') {¶					skipIt();¶					scanSeparator();¶				} else {¶					commentState = 13;¶					scanSeparator();¶				}¶				break;¶			¶			case 13:¶				if (eot) {¶					System.exit(4);¶				}¶				if (currentChar != '/') {¶					skipIt();¶					commentState = 12;¶					scanSeparator();¶				} else {¶					commentState = 0;¶					isComment = false;¶					scanSeparator();¶				}¶				break;	¶		}		¶	}¶	¶¶	public Token scan() {¶		// skip whitespace and comments¶		scanSeparator();¶¶		// start of a token: collect spelling and identify token kind¶		currentSpelling = new StringBuilder();¶		TokenKind kind = scanToken();¶		String spelling = currentSpelling.toString();¶		¶		if (kind == TokenKind.ID) {¶			switch (spelling) {¶			case "class":¶				kind = TokenKind.CLASS;¶				break;¶			case "public":¶				kind = TokenKind.PUBLIC;¶				break;¶			case "private":¶				kind = TokenKind.PRIVATE;¶				break;¶			case "static":¶				kind = TokenKind.STATIC;¶				break;¶			case "int":¶				kind = TokenKind.INT;¶				break;¶			case "boolean":¶				kind = TokenKind.BOOLEAN;¶				break;¶			case "void":¶				kind = TokenKind.VOID;¶				break;¶			case "this":¶				kind = TokenKind.THIS;¶				break;¶			case "return":¶				kind = TokenKind.RETURN;¶				break;¶			case "if":¶				kind = TokenKind.IF;¶				break;¶			case "else":¶				kind = TokenKind.ELSE;¶				break;¶			case "while":¶				kind = TokenKind.WHILE;¶				break;¶			case "true":¶				kind = TokenKind.TRUE;¶				break;¶			case "false":¶				kind = TokenKind.FALSE;¶				break;¶			default:¶				String[] ss = {"class","public","private","static","int","boolean","void","this","return","if","else","while","true","false"};¶				for (String s : ss) {¶					if (spelling.toLowerCase().equals(s)) {¶						reporter.reportError("Key word should not be used as identifiers.");¶						System.exit(4);¶					}¶				}¶				break;¶			}¶		}¶¶		// return new token¶		return new Token(kind, spelling);¶	}¶¶	¶	/**¶	 * determine token kind¶	 */¶	public TokenKind scanToken() {¶		if (eot) {¶			return TokenKind.EOT; ¶		}¶			¶		switch (currentChar) {¶			case 'a':  case 'b':  case 'c':  case 'd':¶			case 'e':  case 'f':  case 'g':  case 'h':¶			case 'i':  case 'j':  case 'k':  case 'l':¶			case 'm':  case 'n':  case 'o':  case 'p':¶			case 'q':  case 'r':  case 's':  case 't':¶	        case 'u':  case 'v':  case 'w':  case 'x':¶	        case 'y':  case 'z':¶	        ¶	        case 'A':  case 'B':  case 'C':  case 'D':¶	        case 'E':  case 'F':  case 'G':  case 'H':¶	        case 'I':  case 'J':  case 'K':  case 'L':¶	        case 'M':  case 'N':  case 'O':	 case 'P':¶	        case 'Q':  case 'R':  case 'S':  case 'T':¶	        case 'U':  case 'V':  case 'W':  case 'X':¶	        case 'Y':  case 'Z':¶	        	takeIt();¶	        	while(Character.isLetter(currentChar) ¶	        			|| Character.isDigit(currentChar)¶	        				|| currentChar == '_') {¶	        		takeIt();¶	        	}¶	        	return TokenKind.ID;¶	        ¶	        case '0':  case '1':  case '2':  case '3':  case '4':¶	        case '5':  case '6':  case '7':  case '8':  case '9':¶	            takeIt();¶	            while(Character.isDigit(currentChar)) {¶	            	takeIt();¶	            }¶	            return TokenKind.NUM;¶	        ¶	        case '>': case '<': case '=':¶	            takeIt();¶	            if(currentChar == '=') {¶	                takeIt();¶	                return TokenKind.BINOP;¶	            }¶	            return TokenKind.BINOP;¶	        ¶	        case '+': case '*': case '/':¶	        	takeIt();¶	        	return TokenKind.BINOP;¶	        ¶	        case '&':¶	            takeIt();¶	            if(currentChar != '&') {¶	                System.exit(4);¶	            }¶	            takeIt();¶	            return TokenKind.BINOP;¶¶	        case '|':¶	            takeIt();¶	            if(currentChar != '|')¶	                System.exit(4);¶	            takeIt();¶	            return TokenKind.BINOP;¶	        ¶	        case '!':¶	            takeIt();¶	            if(currentChar == '=') {¶	                takeIt();¶	                return TokenKind.BINOP;¶	            }¶	            return TokenKind.UNOP;¶	            ¶	        case '-':¶	            takeIt();¶	            return TokenKind.MINUS;¶	        ¶	        case '.':¶	            takeIt();¶	            return TokenKind.DOT;¶¶	        case ',':¶	            takeIt();¶	            return TokenKind.COMMA;¶¶	        case ';':¶	            takeIt();¶	            return TokenKind.SEMICOLON;¶¶	        case '(':¶	            takeIt();¶	            return TokenKind.LPAREN;¶¶	        case ')':¶	            takeIt();¶	            return TokenKind.RPAREN;¶¶	        case '[':¶	            takeIt();¶	            return TokenKind.LBRACKET;¶¶	        case ']':¶	            takeIt();¶	            return TokenKind.RBRACKET;¶¶	        case '{':¶	            takeIt();¶	            return TokenKind.LCURLY;¶¶	        case '}':¶	            takeIt();¶	            return TokenKind.RCURLY;¶	        ¶	        default:¶				scanError("Unrecognized character '" + currentChar + "' in input");¶				return TokenKind.ERROR; ¶		}¶	}¶¶	¶	private void takeIt() {¶		currentSpelling.append(currentChar);¶		nextChar();¶	}¶	¶	private void take(char expectedChar) {¶		if (currentChar == expectedChar) {¶			takeIt();¶		}¶	}¶¶	private void skipIt() {¶		nextChar();¶	}¶¶¶	private void scanError(String m) {¶		reporter.reportError("Scan Error:  " + m);¶	}¶¶¶	private final static char eolUnix = '\n';¶	private final static char eolWindows = '\r';¶¶	/**¶	 * advance to next char in inputstream¶	 * detect end of file or end of line as end of input¶	 */¶	private void nextChar() {¶		if (!eot)¶			readChar();¶	}¶¶	private void readChar() {¶		try {¶			int c = inputStream.read();¶			"), Diff(DELETE,"System.out.print(c);¶			"), Diff(EQUAL,"currentChar = (char) c;¶			if (c == -1 || currentChar == eolUnix || currentChar == eolWindows) {¶				eot = true;¶			}¶		} catch (IOException e) {¶			scanError("I/O Exception!");¶			eot = true;¶		}¶	}¶	¶¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

import java.io.IOException;
import java.io.InputStream;

import miniJava.ErrorReporter;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Scanner {
	private boolean isComment;
	
//	comment state = 0 not comment
//			= 1 show /
//			= 2 show second /
//			= 12 show first *
//			= 13 show second *
//			= 3 show third /
//			= 4 show fourth / end of comment
//			= 14 show second / end of comment
	private int commentState;
	
	private InputStream inputStream;
	private ErrorReporter reporter;
	
	private char currentChar;
	private byte currentKind;
	private StringBuilder currentSpelling;
	
	// true when end of line is found
	private boolean eot = false; 
	
	public Scanner(InputStream inputStream, ErrorReporter reporter) {
		this.isComment = false;
		this.commentState = 0;
		this.inputStream = inputStream;
		this.reporter = reporter;

		// initialize scanner state
		readChar();
	}	
	
	/**
	 * skip whitespace and scan next token
	 */	
	
// ? SINGLE SLASH
//	comment state = 0 not comment
//	= 1 show /
//	= 2 show second /
//	= 12 show first *
//	= 13 show second *
//	= 14 show second / end of comment
	public void scanSeparator() {
		switch (commentState) {
			case 0:
				while (!eot && 
						(currentChar == ' ' ||
							currentChar == '\t' ||
								currentChar == '\n' ||
									currentChar == '\r')) {
					skipIt();
				}
				if (currentChar == '/') {
					commentState = 1;
					skipIt();
					scanSeparator();
				}
				break;
			
			case 1:
				if (currentChar == '/') {
					commentState = 2;
					isComment = true;
					skipIt();
					scanSeparator();
				} else if (currentChar == '*') {
					commentState = 12;
					isComment = true;
					skipIt();
					scanSeparator();
				} else {
					System.exit(4);
				}
				break;
			
			case 2:
				if (currentChar == '\r' || currentChar == '\n' || eot) {
					commentState = 0;
					isComment = false;
					scanSeparator();
				} else {
					skipIt();
					scanSeparator();		
				}
				break;
				
			case 12:
				if (eot) {
					System.exit(4);
				}
				if (currentChar != '*') {
					skipIt();
					scanSeparator();
				} else {
					commentState = 13;
					scanSeparator();
				}
				break;
			
			case 13:
				if (eot) {
					System.exit(4);
				}
				if (currentChar != '/') {
					skipIt();
					commentState = 12;
					scanSeparator();
				} else {
					commentState = 0;
					isComment = false;
					scanSeparator();
				}
				break;	
		}		
	}
	

	public Token scan() {
		// skip whitespace and comments
		scanSeparator();

		// start of a token: collect spelling and identify token kind
		currentSpelling = new StringBuilder();
		TokenKind kind = scanToken();
		String spelling = currentSpelling.toString();
		
		if (kind == TokenKind.ID) {
			switch (spelling) {
			case "class":
				kind = TokenKind.CLASS;
				break;
			case "public":
				kind = TokenKind.PUBLIC;
				break;
			case "private":
				kind = TokenKind.PRIVATE;
				break;
			case "static":
				kind = TokenKind.STATIC;
				break;
			case "int":
				kind = TokenKind.INT;
				break;
			case "boolean":
				kind = TokenKind.BOOLEAN;
				break;
			case "void":
				kind = TokenKind.VOID;
				break;
			case "this":
				kind = TokenKind.THIS;
				break;
			case "return":
				kind = TokenKind.RETURN;
				break;
			case "if":
				kind = TokenKind.IF;
				break;
			case "else":
				kind = TokenKind.ELSE;
				break;
			case "while":
				kind = TokenKind.WHILE;
				break;
			case "true":
				kind = TokenKind.TRUE;
				break;
			case "false":
				kind = TokenKind.FALSE;
				break;
			default:
				String[] ss = {"class","public","private","static","int","boolean","void","this","return","if","else","while","true","false"};
				for (String s : ss) {
					if (spelling.toLowerCase().equals(s)) {
						reporter.reportError("Key word should not be used as identifiers.");
						System.exit(4);
					}
				}
				break;
			}
		}

		// return new token
		return new Token(kind, spelling);
	}

	
	/**
	 * determine token kind
	 */
	public TokenKind scanToken() {
		if (eot) {
			return TokenKind.EOT; 
		}
			
		switch (currentChar) {
			case 'a':  case 'b':  case 'c':  case 'd':
			case 'e':  case 'f':  case 'g':  case 'h':
			case 'i':  case 'j':  case 'k':  case 'l':
			case 'm':  case 'n':  case 'o':  case 'p':
			case 'q':  case 'r':  case 's':  case 't':
	        case 'u':  case 'v':  case 'w':  case 'x':
	        case 'y':  case 'z':
	        
	        case 'A':  case 'B':  case 'C':  case 'D':
	        case 'E':  case 'F':  case 'G':  case 'H':
	        case 'I':  case 'J':  case 'K':  case 'L':
	        case 'M':  case 'N':  case 'O':	 case 'P':
	        case 'Q':  case 'R':  case 'S':  case 'T':
	        case 'U':  case 'V':  case 'W':  case 'X':
	        case 'Y':  case 'Z':
	        	takeIt();
	        	while(Character.isLetter(currentChar) 
	        			|| Character.isDigit(currentChar)
	        				|| currentChar == '_') {
	        		takeIt();
	        	}
	        	return TokenKind.ID;
	        
	        case '0':  case '1':  case '2':  case '3':  case '4':
	        case '5':  case '6':  case '7':  case '8':  case '9':
	            takeIt();
	            while(Character.isDigit(currentChar)) {
	            	takeIt();
	            }
	            return TokenKind.NUM;
	        
	        case '>': case '<': case '=':
	            takeIt();
	            if(currentChar == '=') {
	                takeIt();
	                return TokenKind.BINOP;
	            }
	            return TokenKind.BINOP;
	        
	        case '+': case '*': case '/':
	        	takeIt();
	        	return TokenKind.BINOP;
	        
	        case '&':
	            takeIt();
	            if(currentChar != '&') {
	                System.exit(4);
	            }
	            takeIt();
	            return TokenKind.BINOP;

	        case '|':
	            takeIt();
	            if(currentChar != '|')
	                System.exit(4);
	            takeIt();
	            return TokenKind.BINOP;
	        
	        case '!':
	            takeIt();
	            if(currentChar == '=') {
	                takeIt();
	                return TokenKind.BINOP;
	            }
	            return TokenKind.UNOP;
	            
	        case '-':
	            takeIt();
	            return TokenKind.MINUS;
	        
	        case '.':
	            takeIt();
	            return TokenKind.DOT;

	        case ',':
	            takeIt();
	            return TokenKind.COMMA;

	        case ';':
	            takeIt();
	            return TokenKind.SEMICOLON;

	        case '(':
	            takeIt();
	            return TokenKind.LPAREN;

	        case ')':
	            takeIt();
	            return TokenKind.RPAREN;

	        case '[':
	            takeIt();
	            return TokenKind.LBRACKET;

	        case ']':
	            takeIt();
	            return TokenKind.RBRACKET;

	        case '{':
	            takeIt();
	            return TokenKind.LCURLY;

	        case '}':
	            takeIt();
	            return TokenKind.RCURLY;
	        
	        default:
				scanError("Unrecognized character '" + currentChar + "' in input");
				return TokenKind.ERROR; 
		}
	}

	
	private void takeIt() {
		currentSpelling.append(currentChar);
		nextChar();
	}
	
	private void take(char expectedChar) {
		if (currentChar == expectedChar) {
			takeIt();
		}
	}

	private void skipIt() {
		nextChar();
	}


	private void scanError(String m) {
		reporter.reportError("Scan Error:  " + m);
	}


	private final static char eolUnix = '\n';
	private final static char eolWindows = '\r';

	/**
	 * advance to next char in inputstream
	 * detect end of file or end of line as end of input
	 */
	private void nextChar() {
		if (!eot)
			readChar();
	}

	private void readChar() {
		try {
			int c = inputStream.read();
			currentChar = (char) c;
			if (c == -1 || currentChar == eolUnix || currentChar == eolWindows) {
				eot = true;
			}
		} catch (IOException e) {
			scanError("I/O Exception!");
			eot = true;
		}
	}
	


}
]]></snapshot>
  </Command>
  <Command __id="509" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:04:35 EST 2022" docASTNodeCount="72" docActiveCodeLength="316" docExpressionCount="36" docLength="316" projectName="pa1" starttimestamp="1645728958172" timestamp="4116911">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\TokenKind.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶public enum TokenKind {NUM, CLASS, ID, LBRACKET, RBRACKET, VOID, LPAREN, RPAREN, EOT, EQUAL, THIS,¶							PUBLIC, PRIVATE, STATIC, INT, BOOLEAN, COMMA, DOT, RETURN, SEMICOLON,¶								IF, ELSE, WHILE, UNOP, BINOP, MINUS, TRUE, FALSE, NEW, LCURLY, RCURLY,¶									ERROR}¶¶")]]]></diff>
  </Command>
  <Command __id="501" _type="RunCommand" date="Thu Feb 24 15:04:09 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4091099" type="Run" />
  <Command __id="502" _type="RunCommand" date="Thu Feb 24 15:04:09 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4091099" type="Run" />
  <Command __id="503" _type="RunCommand" date="Thu Feb 24 15:04:09 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4091210" type="Run" />
  <Command __id="504" _type="RunCommand" date="Thu Feb 24 15:04:09 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4091210" type="Run" />
  <Command __id="505" _type="EHExceptionCommand" date="Thu Feb 24 15:04:09 EST 2022" starttimestamp="1645728958172" timestamp="4091252" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
Parse error: Parsing  and expecting 'RCURLY' but found 'EOT'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="508" _type="MoveCaretCommand" caretOffset="8160" date="Thu Feb 24 15:04:33 EST 2022" docOffset="8311" starttimestamp="1645728958172" timestamp="4115795" />
  <Command __id="510" _type="MoveCaretCommand" caretOffset="260" date="Thu Feb 24 15:04:35 EST 2022" docOffset="260" starttimestamp="1645728958172" timestamp="4116980" />
  <Command __id="512" _type="MoveCaretCommand" caretOffset="10489" date="Thu Feb 24 15:04:36 EST 2022" docOffset="10567" starttimestamp="1645728958172" timestamp="4118729" />
  <Command __id="514" _type="ShellCommand" date="Thu Feb 24 15:04:38 EST 2022" starttimestamp="1645728958172" timestamp="4119879" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="515" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:04:41 EST 2022" forward="false" matchWord="true" offset="10567" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4123141" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="511" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:04:36 EST 2022" docASTNodeCount="1522" docActiveCodeLength="10648" docExpressionCount="1057" docLength="11264" projectName="pa1" starttimestamp="1645728958172" timestamp="4118651">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶import miniJava.ErrorReporter;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public void parse() {¶		currentToken = scanner.scan();¶		try {¶			parseProgram();¶		}¶		catch (SyntaxError e) { }¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) {¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	//   ¶	private void parseProgram() throws SyntaxError {¶		accept(TokenKind.CLASS);¶		parseId();¶		accept(TokenKind.LCURLY);¶		¶		while (startsDeclaration(currentToken.kind)) {¶			parseVisibility();¶			parseAccess();¶			switch(currentToken.kind) {¶				case VOID:¶					parseId();¶					accept(TokenKind.LPAREN);¶					if (startsType(currentToken.kind)) {¶						parseParameterList();¶					}¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.LCURLY);¶					¶					while (startsStatement(currentToken.kind)) {¶						parseStatement();¶					}¶					accept(TokenKind.RCURLY);¶					break;¶					¶				default:¶					if (startsType(currentToken.kind)) {¶						parseType();¶						parseId();¶						switch(currentToken.kind) {¶						case SEMICOLON:¶							accept(TokenKind.SEMICOLON);¶							break;¶						case ID:¶							parseId();¶							accept(TokenKind.LPAREN);¶							if (startsType(currentToken.kind)) {¶								parseParameterList();¶							}¶							accept(TokenKind.RPAREN);¶							accept(TokenKind.LCURLY);¶							¶							while (startsStatement(currentToken.kind)) {¶								parseStatement();¶							}¶							accept(TokenKind.RCURLY);¶							break;¶						}¶					}¶					else {¶						parseError("Parsing wrong in declarations");¶					}¶					¶			}¶		}¶		¶		accept(TokenKind.RCURLY);¶		accept(TokenKind.EOT);¶	}¶	¶	private void parseStatement() throws SyntaxError {¶		switch (currentToken.kind) {¶		case LCURLY:¶			acceptIt();¶			while (startsStatement(currentToken.kind)) {¶				parseStatement();¶			}¶			accept(TokenKind.RCURLY);¶			break;¶			¶		case INT: case BOOLEAN:¶			parseType();¶			parseId();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶		¶		case ID:¶			acceptIt();¶			¶			switch (currentToken.kind) {¶			// in Type¶			case ID:¶			acceptIt();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// in Reference¶			case EQUAL:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			case LPAREN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.RPAREN) {¶				acceptIt();¶			} else {¶				parseArgumentList();¶				accept(TokenKind.RPAREN);¶			}¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// both¶			case LBRACKET: ¶			acceptIt();¶			// in Type¶			if (currentToken.kind == TokenKind.RBRACKET) {¶				acceptIt();¶				accept(TokenKind.ID);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			} else {¶				// in Reference¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶			¶			case DOT:¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET: ¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);¶			}¶			default:¶				parseError("parsing statement, in subcase ID, current token is: " + currentToken);¶			}¶			break;¶		¶		case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶				¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶					accept(TokenKind.SEMICOLON);¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.SEMICOLON);¶				}¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶			}¶			break;¶			¶		case RETURN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.SEMICOLON) {¶				acceptIt();¶			} else {¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶		¶		case IF:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			if (currentToken.kind == TokenKind.ELSE) {¶				acceptIt();¶				parseStatement();¶			}¶			break;¶			¶		case WHILE:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			break;¶		¶		default:¶			parseError("parsing statement, current token is:" + currentToken);¶		}¶		return ;¶		¶	}¶¶¶	private void parseArgumentList() {¶		// TODO Auto-generated method stub¶		parseExpression();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private void parseExpression() {¶		// TODO Auto-generated method stub¶		switch (currentToken.kind) {¶		case ID: case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				break;¶				¶			// just reference¶			default:¶				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);¶			}¶			¶		case UNOP: case MINUS:¶			acceptIt();¶			parseExpression();¶			break;¶		¶		case LPAREN:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		case NUM: case TRUE: case FALSE:¶			acceptIt();¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶			case ID:¶				acceptIt();¶				switch (currentToken.kind) {¶				case LPAREN:¶					acceptIt();¶					accept(TokenKind.RPAREN);¶					break;¶				case LBRACKET:¶					acceptIt();¶					parseExpression();¶					accept(TokenKind.RBRACKET);¶					break;¶				¶				}¶			¶			case INT:¶				acceptIt();¶				accept(TokenKind.LBRACKET);¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			default:¶				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);¶			}¶			break;¶		¶		default:¶			parseError("parsing expression, current token is: " + currentToken);¶		}¶		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private boolean startsStatement(TokenKind kind) {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private void parseParameterList() throws SyntaxError {¶		parseType();¶		parseId();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseType();¶			parseId();¶		}¶	}¶¶¶	private void parseType() throws SyntaxError{¶		switch (currentToken.kind) {¶		case INT:¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		case BOOLEAN:¶			acceptIt();¶			break;¶		case ID:¶			parseId();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶	}¶¶¶	private void parseId() throws SyntaxError {¶		accept(TokenKind.ID);¶	}¶¶¶	private void parseAccess() throws SyntaxError {¶		if (currentToken.kind == TokenKind.STATIC) {¶			accept(TokenKind.STATIC);¶		}¶	}¶¶¶	private void parseVisibility() throws SyntaxError {¶		if (currentToken.kind == TokenKind.PRIVATE) {¶			accept(TokenKind.PRIVATE);¶		} else if (currentToken.kind == TokenKind.PUBLIC) {¶			accept(TokenKind.PUBLIC);¶		}¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="519" _type="Insert" date="Thu Feb 24 15:05:04 EST 2022" docASTNodeCount="1522" docActiveCodeLength="10653" docExpressionCount="1057" docLength="11269" length="5" offset="2522" starttimestamp="1645728958172" timestamp="4146180">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <DocumentChange __id="521" _type="Insert" date="Thu Feb 24 15:05:05 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10654" docExpressionCount="1058" docLength="11270" length="1" offset="2527" starttimestamp="1645728958172" timestamp="4147618">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="523" _type="Insert" date="Thu Feb 24 15:05:06 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10655" docExpressionCount="1058" docLength="11271" length="1" offset="2528" starttimestamp="1645728958172" timestamp="4147864">
    <text><![CDATA[y]]></text>
  </DocumentChange>
  <DocumentChange __id="525" _type="Insert" date="Thu Feb 24 15:05:06 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10656" docExpressionCount="1058" docLength="11272" length="1" offset="2529" starttimestamp="1645728958172" timestamp="4147952">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="527" _type="Insert" date="Thu Feb 24 15:05:06 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10657" docExpressionCount="1058" docLength="11273" length="1" offset="2530" starttimestamp="1645728958172" timestamp="4148152">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="529" _type="Insert" date="Thu Feb 24 15:05:06 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10658" docExpressionCount="1058" docLength="11274" length="1" offset="2531" starttimestamp="1645728958172" timestamp="4148306">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="531" _type="Insert" date="Thu Feb 24 15:05:06 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10659" docExpressionCount="1058" docLength="11275" length="1" offset="2532" starttimestamp="1645728958172" timestamp="4148390">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="533" _type="Insert" date="Thu Feb 24 15:05:07 EST 2022" docASTNodeCount="1523" docActiveCodeLength="10660" docExpressionCount="1058" docLength="11276" length="1" offset="2533" starttimestamp="1645728958172" timestamp="4149507">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="536" _type="Insert" date="Thu Feb 24 15:05:07 EST 2022" docASTNodeCount="1527" docActiveCodeLength="10661" docExpressionCount="1060" docLength="11277" length="1" offset="2534" starttimestamp="1645728958172" timestamp="4149824">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="537" _type="Insert" date="Thu Feb 24 15:05:08 EST 2022" docASTNodeCount="1527" docActiveCodeLength="10662" docExpressionCount="1060" docLength="11278" length="1" offset="2535" starttimestamp="1645728958172" timestamp="4149924">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="538" _type="Insert" date="Thu Feb 24 15:05:08 EST 2022" docASTNodeCount="1527" docActiveCodeLength="10663" docExpressionCount="1060" docLength="11279" length="1" offset="2536" starttimestamp="1645728958172" timestamp="4150040">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="540" _type="Replace" date="Thu Feb 24 15:05:08 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10664" docExpressionCount="1060" docLength="11280" endLine="110" insertionLength="4" int_docASTNodeCount="1523" int_docActiveCodeLength="10660" int_docExpressionCount="1058" int_docLength="11276" length="3" offset="2534" startLine="110" starttimestamp="1645728958172" timestamp="4150324">
    <deletedText><![CDATA[out]]></deletedText>
    <insertedText><![CDATA[out.]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="543" _type="Insert" date="Thu Feb 24 15:05:08 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10665" docExpressionCount="1062" docLength="11281" length="1" offset="2538" starttimestamp="1645728958172" timestamp="4150625">
    <text><![CDATA[P]]></text>
  </DocumentChange>
  <DocumentChange __id="544" _type="Insert" date="Thu Feb 24 15:05:08 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10666" docExpressionCount="1062" docLength="11282" length="1" offset="2539" starttimestamp="1645728958172" timestamp="4150741">
    <text><![CDATA[R]]></text>
  </DocumentChange>
  <DocumentChange __id="545" _type="Insert" date="Thu Feb 24 15:05:08 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10667" docExpressionCount="1062" docLength="11283" length="1" offset="2540" starttimestamp="1645728958172" timestamp="4150810">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="546" _type="Insert" date="Thu Feb 24 15:05:09 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10668" docExpressionCount="1062" docLength="11284" length="1" offset="2541" starttimestamp="1645728958172" timestamp="4150926">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="547" _type="Insert" date="Thu Feb 24 15:05:09 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10669" docExpressionCount="1062" docLength="11285" length="1" offset="2542" starttimestamp="1645728958172" timestamp="4150973">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="548" _type="Delete" date="Thu Feb 24 15:05:09 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10668" docExpressionCount="1062" docLength="11284" endLine="110" length="1" offset="2542" startLine="110" starttimestamp="1645728958172" timestamp="4151542">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="549" _type="Delete" date="Thu Feb 24 15:05:09 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10667" docExpressionCount="1062" docLength="11283" endLine="110" length="1" offset="2541" startLine="110" starttimestamp="1645728958172" timestamp="4151680">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="550" _type="Delete" date="Thu Feb 24 15:05:10 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10666" docExpressionCount="1062" docLength="11282" endLine="110" length="1" offset="2540" startLine="110" starttimestamp="1645728958172" timestamp="4151843">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="551" _type="Delete" date="Thu Feb 24 15:05:10 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10665" docExpressionCount="1062" docLength="11281" endLine="110" length="1" offset="2539" startLine="110" starttimestamp="1645728958172" timestamp="4152012">
    <text><![CDATA[R]]></text>
  </DocumentChange>
  <DocumentChange __id="552" _type="Delete" date="Thu Feb 24 15:05:10 EST 2022" docASTNodeCount="1525" docActiveCodeLength="10664" docExpressionCount="1060" docLength="11280" endLine="110" length="1" offset="2538" startLine="110" starttimestamp="1645728958172" timestamp="4152159">
    <text><![CDATA[P]]></text>
  </DocumentChange>
  <DocumentChange __id="553" _type="Insert" date="Thu Feb 24 15:05:10 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10665" docExpressionCount="1062" docLength="11281" length="1" offset="2538" starttimestamp="1645728958172" timestamp="4152582">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="554" _type="Insert" date="Thu Feb 24 15:05:10 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10666" docExpressionCount="1062" docLength="11282" length="1" offset="2539" starttimestamp="1645728958172" timestamp="4152713">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="555" _type="Insert" date="Thu Feb 24 15:05:10 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10667" docExpressionCount="1062" docLength="11283" length="1" offset="2540" starttimestamp="1645728958172" timestamp="4152760">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="556" _type="Insert" date="Thu Feb 24 15:05:11 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10668" docExpressionCount="1062" docLength="11284" length="1" offset="2541" starttimestamp="1645728958172" timestamp="4152882">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="557" _type="Insert" date="Thu Feb 24 15:05:11 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10669" docExpressionCount="1062" docLength="11285" length="1" offset="2542" starttimestamp="1645728958172" timestamp="4152960">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="558" _type="Insert" date="Thu Feb 24 15:05:11 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10670" docExpressionCount="1062" docLength="11286" length="1" offset="2543" starttimestamp="1645728958172" timestamp="4153498">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="559" _type="Insert" date="Thu Feb 24 15:05:11 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10671" docExpressionCount="1062" docLength="11287" length="1" offset="2544" starttimestamp="1645728958172" timestamp="4153629">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="560" _type="Insert" date="Thu Feb 24 15:05:12 EST 2022" docASTNodeCount="1528" docActiveCodeLength="10673" docExpressionCount="1062" docLength="11289" length="2" offset="2545" starttimestamp="1645728958172" timestamp="4154334">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="561" _type="Insert" date="Thu Feb 24 15:05:13 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10674" docExpressionCount="1063" docLength="11290" length="1" offset="2546" starttimestamp="1645728958172" timestamp="4154845">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="516" _type="ShellCommand" date="Thu Feb 24 15:05:02 EST 2022" starttimestamp="1645728958172" timestamp="4144187" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="517" _type="MoveCaretCommand" caretOffset="2438" date="Thu Feb 24 15:05:03 EST 2022" docOffset="2516" starttimestamp="1645728958172" timestamp="4145064" />
  <Command __id="518" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.LINE_DOWN" date="Thu Feb 24 15:05:03 EST 2022" starttimestamp="1645728958172" timestamp="4145801" />
  <Command __id="520" _type="InsertStringCommand" date="Thu Feb 24 15:05:04 EST 2022" starttimestamp="1645728958172" timestamp="4146195" timestamp2="4146195">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="522" _type="InsertStringCommand" date="Thu Feb 24 15:05:05 EST 2022" starttimestamp="1645728958172" timestamp="4147634" timestamp2="4147634">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="524" _type="InsertStringCommand" date="Thu Feb 24 15:05:06 EST 2022" starttimestamp="1645728958172" timestamp="4147874" timestamp2="4147874">
    <data><![CDATA[y]]></data>
  </Command>
  <Command __id="526" _type="InsertStringCommand" date="Thu Feb 24 15:05:06 EST 2022" starttimestamp="1645728958172" timestamp="4147952" timestamp2="4147952">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="528" _type="InsertStringCommand" date="Thu Feb 24 15:05:06 EST 2022" starttimestamp="1645728958172" timestamp="4148168" timestamp2="4148168">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="530" _type="InsertStringCommand" date="Thu Feb 24 15:05:06 EST 2022" starttimestamp="1645728958172" timestamp="4148306" timestamp2="4148306">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="532" _type="InsertStringCommand" date="Thu Feb 24 15:05:06 EST 2022" starttimestamp="1645728958172" timestamp="4148390" timestamp2="4148390">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="534" _type="InsertStringCommand" date="Thu Feb 24 15:05:07 EST 2022" starttimestamp="1645728958172" timestamp="4149523" timestamp2="4149523">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="535" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 15:05:07 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="4149523" />
  <Command __id="539" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 15:05:08 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="4150309" />
  <Command __id="541" _type="InsertStringCommand" date="Thu Feb 24 15:05:08 EST 2022" starttimestamp="1645728958172" timestamp="4150324" timestamp2="4150324">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="542" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 15:05:08 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="4150324" />
  <Command __id="563" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 15:05:13 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="4154983" />
  <Command __id="565" _type="InsertStringCommand" date="Thu Feb 24 15:05:13 EST 2022" starttimestamp="1645728958172" timestamp="4155083" timestamp2="4155083">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="567" _type="InsertStringCommand" date="Thu Feb 24 15:05:13 EST 2022" starttimestamp="1645728958172" timestamp="4155245" timestamp2="4155245">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="569" _type="InsertStringCommand" date="Thu Feb 24 15:05:13 EST 2022" starttimestamp="1645728958172" timestamp="4155546" timestamp2="4155546">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="571" _type="InsertStringCommand" date="Thu Feb 24 15:05:13 EST 2022" starttimestamp="1645728958172" timestamp="4155683" timestamp2="4155683">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="573" _type="InsertStringCommand" date="Thu Feb 24 15:05:13 EST 2022" starttimestamp="1645728958172" timestamp="4155800" timestamp2="4155800">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="575" _type="InsertStringCommand" date="Thu Feb 24 15:05:14 EST 2022" starttimestamp="1645728958172" timestamp="4156186" timestamp2="4156186">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="577" _type="InsertStringCommand" date="Thu Feb 24 15:05:14 EST 2022" starttimestamp="1645728958172" timestamp="4156302" timestamp2="4156302">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="579" _type="InsertStringCommand" date="Thu Feb 24 15:05:14 EST 2022" starttimestamp="1645728958172" timestamp="4156464" timestamp2="4156464">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="581" _type="InsertStringCommand" date="Thu Feb 24 15:05:14 EST 2022" starttimestamp="1645728958172" timestamp="4156565" timestamp2="4156565">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="583" _type="InsertStringCommand" date="Thu Feb 24 15:05:14 EST 2022" starttimestamp="1645728958172" timestamp="4156665" timestamp2="4156665">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="585" _type="InsertStringCommand" date="Thu Feb 24 15:05:15 EST 2022" starttimestamp="1645728958172" timestamp="4157004" timestamp2="4157004">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="586" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 15:05:15 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="4157004" />
  <Command __id="588" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 15:05:15 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="4157723" />
  <Command __id="590" _type="InsertStringCommand" date="Thu Feb 24 15:05:16 EST 2022" starttimestamp="1645728958172" timestamp="4158072" timestamp2="4158072">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="591" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Feb 24 15:05:17 EST 2022" starttimestamp="1645728958172" timestamp="4159347" />
  <Command __id="592" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:05:17 EST 2022" starttimestamp="1645728958172" timestamp="4159516" />
  <Command __id="593" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:05:17 EST 2022" starttimestamp="1645728958172" timestamp="4159547" />
  <DocumentChange __id="562" _type="Insert" date="Thu Feb 24 15:05:13 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10675" docExpressionCount="1063" docLength="11291" length="1" offset="2547" starttimestamp="1645728958172" timestamp="4154945">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="564" _type="Insert" date="Thu Feb 24 15:05:13 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10676" docExpressionCount="1063" docLength="11292" length="1" offset="2548" starttimestamp="1645728958172" timestamp="4155083">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="566" _type="Insert" date="Thu Feb 24 15:05:13 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10677" docExpressionCount="1063" docLength="11293" length="1" offset="2549" starttimestamp="1645728958172" timestamp="4155245">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="568" _type="Insert" date="Thu Feb 24 15:05:13 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10678" docExpressionCount="1063" docLength="11294" length="1" offset="2550" starttimestamp="1645728958172" timestamp="4155546">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="570" _type="Insert" date="Thu Feb 24 15:05:13 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10679" docExpressionCount="1063" docLength="11295" length="1" offset="2551" starttimestamp="1645728958172" timestamp="4155683">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="572" _type="Insert" date="Thu Feb 24 15:05:13 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10680" docExpressionCount="1063" docLength="11296" length="1" offset="2552" starttimestamp="1645728958172" timestamp="4155800">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="574" _type="Insert" date="Thu Feb 24 15:05:14 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10681" docExpressionCount="1063" docLength="11297" length="1" offset="2553" starttimestamp="1645728958172" timestamp="4156186">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="576" _type="Insert" date="Thu Feb 24 15:05:14 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10682" docExpressionCount="1063" docLength="11298" length="1" offset="2554" starttimestamp="1645728958172" timestamp="4156302">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="578" _type="Insert" date="Thu Feb 24 15:05:14 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10683" docExpressionCount="1063" docLength="11299" length="1" offset="2555" starttimestamp="1645728958172" timestamp="4156464">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <DocumentChange __id="580" _type="Insert" date="Thu Feb 24 15:05:14 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10684" docExpressionCount="1063" docLength="11300" length="1" offset="2556" starttimestamp="1645728958172" timestamp="4156549">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="582" _type="Insert" date="Thu Feb 24 15:05:14 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10685" docExpressionCount="1063" docLength="11301" length="1" offset="2557" starttimestamp="1645728958172" timestamp="4156665">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="584" _type="Insert" date="Thu Feb 24 15:05:15 EST 2022" docASTNodeCount="1528" docActiveCodeLength="10686" docExpressionCount="1063" docLength="11302" length="1" offset="2558" starttimestamp="1645728958172" timestamp="4157004">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="587" _type="Delete" date="Thu Feb 24 15:05:15 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10685" docExpressionCount="1063" docLength="11301" endLine="110" length="1" offset="2558" startLine="110" starttimestamp="1645728958172" timestamp="4157342">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="589" _type="Insert" date="Thu Feb 24 15:05:16 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10686" docExpressionCount="1063" docLength="11302" length="1" offset="2559" starttimestamp="1645728958172" timestamp="4158041">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="595" _type="Insert" date="Thu Feb 24 15:05:20 EST 2022" docASTNodeCount="990" docActiveCodeLength="10687" docExpressionCount="679" docLength="11303" length="1" offset="2546" starttimestamp="1645728958172" timestamp="4161870">
    <text><![CDATA["]]></text>
  </DocumentChange>
  <DocumentChange __id="597" _type="Insert" date="Thu Feb 24 15:05:20 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10688" docExpressionCount="1063" docLength="11304" length="1" offset="2547" starttimestamp="1645728958172" timestamp="4162008">
    <text><![CDATA["]]></text>
  </DocumentChange>
  <DocumentChange __id="600" _type="Insert" date="Thu Feb 24 15:05:20 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10689" docExpressionCount="1063" docLength="11305" length="1" offset="2547" starttimestamp="1645728958172" timestamp="4162784">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="602" _type="Delete" date="Thu Feb 24 15:05:21 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10688" docExpressionCount="1063" docLength="11304" endLine="110" length="1" offset="2547" startLine="110" starttimestamp="1645728958172" timestamp="4163150">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="604" _type="Insert" date="Thu Feb 24 15:05:21 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10689" docExpressionCount="1063" docLength="11305" length="1" offset="2547" starttimestamp="1645728958172" timestamp="4163381">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="606" _type="Insert" date="Thu Feb 24 15:05:21 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10690" docExpressionCount="1063" docLength="11306" length="1" offset="2548" starttimestamp="1645728958172" timestamp="4163481">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="608" _type="Insert" date="Thu Feb 24 15:05:21 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10691" docExpressionCount="1063" docLength="11307" length="1" offset="2549" starttimestamp="1645728958172" timestamp="4163650">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="610" _type="Insert" date="Thu Feb 24 15:05:21 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10692" docExpressionCount="1063" docLength="11308" length="1" offset="2550" starttimestamp="1645728958172" timestamp="4163819">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <DocumentChange __id="612" _type="Insert" date="Thu Feb 24 15:05:22 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10693" docExpressionCount="1063" docLength="11309" length="1" offset="2551" starttimestamp="1645728958172" timestamp="4163904">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="614" _type="Insert" date="Thu Feb 24 15:05:22 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10694" docExpressionCount="1063" docLength="11310" length="1" offset="2552" starttimestamp="1645728958172" timestamp="4164067">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="616" _type="Insert" date="Thu Feb 24 15:05:22 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10695" docExpressionCount="1063" docLength="11311" length="1" offset="2553" starttimestamp="1645728958172" timestamp="4164152">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="618" _type="Insert" date="Thu Feb 24 15:05:22 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10696" docExpressionCount="1063" docLength="11312" length="1" offset="2554" starttimestamp="1645728958172" timestamp="4164485">
    <text><![CDATA[:]]></text>
  </DocumentChange>
  <DocumentChange __id="620" _type="Insert" date="Thu Feb 24 15:05:22 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10697" docExpressionCount="1063" docLength="11313" length="1" offset="2555" starttimestamp="1645728958172" timestamp="4164669">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="623" _type="Insert" date="Thu Feb 24 15:05:23 EST 2022" docASTNodeCount="1529" docActiveCodeLength="10698" docExpressionCount="1063" docLength="11314" length="1" offset="2557" starttimestamp="1645728958172" timestamp="4165238">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="625" _type="Insert" date="Thu Feb 24 15:05:24 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10699" docExpressionCount="1065" docLength="11315" length="1" offset="2558" starttimestamp="1645728958172" timestamp="4165923">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <DocumentChange __id="627" _type="Insert" date="Thu Feb 24 15:05:24 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10700" docExpressionCount="1065" docLength="11316" length="1" offset="2559" starttimestamp="1645728958172" timestamp="4166254">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="633" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:05:28 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="4170128">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="635" _type="RunCommand" date="Thu Feb 24 15:05:30 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4172378" type="Run" />
  <Command __id="636" _type="RunCommand" date="Thu Feb 24 15:05:30 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4172393" type="Run" />
  <Command __id="637" _type="RunCommand" date="Thu Feb 24 15:05:30 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4172520" type="Run" />
  <Command __id="638" _type="RunCommand" date="Thu Feb 24 15:05:30 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4172520" type="Run" />
  <Command __id="639" _type="EHExceptionCommand" date="Thu Feb 24 15:05:30 EST 2022" starttimestamp="1645728958172" timestamp="4172560" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
Parse error: Parsing  and expecting 'RCURLY' but found 'EOT'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="641" _type="MoveCaretCommand" caretOffset="2483" date="Thu Feb 24 15:05:34 EST 2022" docOffset="2561" starttimestamp="1645728958172" timestamp="4176523" />
  <Command __id="642" _type="MoveCaretCommand" caretOffset="2496" date="Thu Feb 24 15:05:36 EST 2022" docOffset="2574" starttimestamp="1645728958172" timestamp="4178338" />
  <Command __id="644" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.toggle.comment" date="Thu Feb 24 15:05:37 EST 2022" starttimestamp="1645728958172" timestamp="4179039" />
  <Command __id="645" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Feb 24 15:05:38 EST 2022" starttimestamp="1645728958172" timestamp="4180412" />
  <Command __id="646" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:05:38 EST 2022" starttimestamp="1645728958172" timestamp="4180512" />
  <Command __id="647" _type="EclipseCommand" commandID="" date="Thu Feb 24 15:05:38 EST 2022" starttimestamp="1645728958172" timestamp="4180527" />
  <Command __id="649" _type="ShellCommand" date="Thu Feb 24 15:05:39 EST 2022" starttimestamp="1645728958172" timestamp="4181575" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="650" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:42 EST 2022" forward="false" matchWord="true" offset="2576" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4184050" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="651" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:42 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4184751" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="652" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:45 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4187022" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="653" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:45 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4187538" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="654" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:45 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4187639" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="655" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:46 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4187855" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="656" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:46 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4187955" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="657" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:46 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4188171" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="658" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:46 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4188287" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="659" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:46 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4188488" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="660" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:46 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4188588" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="661" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:46 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4188811" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="662" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:47 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4188911" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="663" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:47 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4189169" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="664" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:49 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4191596" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="665" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:49 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4191681" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="666" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:50 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4191896" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="667" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:50 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4191981" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="668" _type="FindCommand" caseSensitive="true" date="Thu Feb 24 15:05:50 EST 2022" forward="false" matchWord="true" offset="2604" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1645728958172" timestamp="4192235" wrapSearch="false">
    <searchString><![CDATA[RCURLY]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="669" _type="ShellCommand" date="Thu Feb 24 15:05:51 EST 2022" starttimestamp="1645728958172" timestamp="4193570" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="670" _type="MoveCaretCommand" caretOffset="2498" date="Thu Feb 24 15:06:14 EST 2022" docOffset="2576" starttimestamp="1645728958172" timestamp="4216583" />
  <Command __id="671" _type="MoveCaretCommand" caretOffset="2498" date="Thu Feb 24 15:06:15 EST 2022" docOffset="2576" starttimestamp="1645728958172" timestamp="4216899" />
  <Command __id="672" _type="SelectTextCommand" caretOffset="2500" date="Thu Feb 24 15:06:15 EST 2022" end="2500" start="2446" starttimestamp="1645728958172" timestamp="4217084" />
  <Command __id="673" _type="CopyCommand" date="Thu Feb 24 15:06:16 EST 2022" starttimestamp="1645728958172" timestamp="4218534" />
  <Command __id="674" _type="MoveCaretCommand" caretOffset="2187" date="Thu Feb 24 15:06:19 EST 2022" docOffset="2265" starttimestamp="1645728958172" timestamp="4221125" />
  <Command __id="676" _type="PasteCommand" date="Thu Feb 24 15:06:19 EST 2022" starttimestamp="1645728958172" timestamp="4221494" />
  <Command __id="677" _type="MoveCaretCommand" caretOffset="2236" date="Thu Feb 24 15:06:21 EST 2022" docOffset="2314" starttimestamp="1645728958172" timestamp="4223186" />
  <Command __id="679" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.toggle.comment" date="Thu Feb 24 15:06:21 EST 2022" starttimestamp="1645728958172" timestamp="4223736" />
  <Command __id="640" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:05:34 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10700" docExpressionCount="1065" docLength="11316" projectName="pa1" starttimestamp="1645728958172" timestamp="4176454">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶import miniJava.ErrorReporter;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public void parse() {¶		currentToken = scanner.scan();¶		try {¶			parseProgram();¶		}¶		catch (SyntaxError e) { }¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) {¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	//   ¶	private void parseProgram() throws SyntaxError {¶		accept(TokenKind.CLASS);¶		parseId();¶		accept(TokenKind.LCURLY);¶		¶		while (startsDeclaration(currentToken.kind)) {¶			parseVisibility();¶			parseAccess();¶			switch(currentToken.kind) {¶				case VOID:¶					parseId();¶					accept(TokenKind.LPAREN);¶					if (startsType(currentToken.kind)) {¶						parseParameterList();¶					}¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.LCURLY);¶					¶					while (startsStatement(currentToken.kind)) {¶						parseStatement();¶					}¶					accept(TokenKind.RCURLY);¶					break;¶					¶				default:¶					if (startsType(currentToken.kind)) {¶						parseType();¶						parseId();¶						switch(currentToken.kind) {¶						case SEMICOLON:¶							accept(TokenKind.SEMICOLON);¶							break;¶						case ID:¶							parseId();¶							accept(TokenKind.LPAREN);¶							if (startsType(currentToken.kind)) {¶								parseParameterList();¶							}¶							accept(TokenKind.RPAREN);¶							accept(TokenKind.LCURLY);¶							¶							while (startsStatement(currentToken.kind)) {¶								parseStatement();¶							}¶							accept(TokenKind.RCURLY);¶							break;¶						}¶					}¶					else {¶						parseError("Parsing wrong in declarations");¶					}¶					¶			}¶		}¶		¶		accept(TokenKind.RCURLY);¶		accept(TokenKind.EOT);¶	}¶	¶	private void parseStatement() throws SyntaxError {¶		switch (currentToken.kind) {¶		case LCURLY:¶			acceptIt();¶			while (startsStatement(currentToken.kind)) {¶				parseStatement();¶			}¶			"), Diff(INSERT,"System.out.println("in here: " + currentToken);¶			"), Diff(EQUAL,"accept(TokenKind.RCURLY);¶			break;¶			¶		case INT: case BOOLEAN:¶			parseType();¶			parseId();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶		¶		case ID:¶			acceptIt();¶			¶			switch (currentToken.kind) {¶			// in Type¶			case ID:¶			acceptIt();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// in Reference¶			case EQUAL:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			case LPAREN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.RPAREN) {¶				acceptIt();¶			} else {¶				parseArgumentList();¶				accept(TokenKind.RPAREN);¶			}¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// both¶			case LBRACKET: ¶			acceptIt();¶			// in Type¶			if (currentToken.kind == TokenKind.RBRACKET) {¶				acceptIt();¶				accept(TokenKind.ID);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			} else {¶				// in Reference¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶			¶			case DOT:¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET: ¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);¶			}¶			default:¶				parseError("parsing statement, in subcase ID, current token is: " + currentToken);¶			}¶			break;¶		¶		case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶				¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶					accept(TokenKind.SEMICOLON);¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.SEMICOLON);¶				}¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶			}¶			break;¶			¶		case RETURN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.SEMICOLON) {¶				acceptIt();¶			} else {¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶		¶		case IF:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			if (currentToken.kind == TokenKind.ELSE) {¶				acceptIt();¶				parseStatement();¶			}¶			break;¶			¶		case WHILE:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			break;¶		¶		default:¶			parseError("parsing statement, current token is:" + currentToken);¶		}¶		return ;¶		¶	}¶¶¶	private void parseArgumentList() {¶		// TODO Auto-generated method stub¶		parseExpression();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private void parseExpression() {¶		// TODO Auto-generated method stub¶		switch (currentToken.kind) {¶		case ID: case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				break;¶				¶			// just reference¶			default:¶				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);¶			}¶			¶		case UNOP: case MINUS:¶			acceptIt();¶			parseExpression();¶			break;¶		¶		case LPAREN:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		case NUM: case TRUE: case FALSE:¶			acceptIt();¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶			case ID:¶				acceptIt();¶				switch (currentToken.kind) {¶				case LPAREN:¶					acceptIt();¶					accept(TokenKind.RPAREN);¶					break;¶				case LBRACKET:¶					acceptIt();¶					parseExpression();¶					accept(TokenKind.RBRACKET);¶					break;¶				¶				}¶			¶			case INT:¶				acceptIt();¶				accept(TokenKind.LBRACKET);¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			default:¶				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);¶			}¶			break;¶		¶		default:¶			parseError("parsing expression, current token is: " + currentToken);¶		}¶		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private boolean startsStatement(TokenKind kind) {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private void parseParameterList() throws SyntaxError {¶		parseType();¶		parseId();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseType();¶			parseId();¶		}¶	}¶¶¶	private void parseType() throws SyntaxError{¶		switch (currentToken.kind) {¶		case INT:¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		case BOOLEAN:¶			acceptIt();¶			break;¶		case ID:¶			parseId();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶	}¶¶¶	private void parseId() throws SyntaxError {¶		accept(TokenKind.ID);¶	}¶¶¶	private void parseAccess() throws SyntaxError {¶		if (currentToken.kind == TokenKind.STATIC) {¶			accept(TokenKind.STATIC);¶		}¶	}¶¶¶	private void parseVisibility() throws SyntaxError {¶		if (currentToken.kind == TokenKind.PRIVATE) {¶			accept(TokenKind.PRIVATE);¶		} else if (currentToken.kind == TokenKind.PUBLIC) {¶			accept(TokenKind.PUBLIC);¶		}¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

import miniJava.SyntacticAnalyzer.Scanner;
import miniJava.SyntacticAnalyzer.TokenKind;
import miniJava.ErrorReporter;

public class Parser {
	private Scanner scanner;
	private ErrorReporter reporter;
	private Token currentToken;

	public Parser(Scanner scanner, ErrorReporter reporter) {
		this.scanner = scanner;
		this.reporter = reporter;
	}


	/**
	 *  parse input, catch possible parse error
	 */
	public void parse() {
		currentToken = scanner.scan();
		try {
			parseProgram();
		}
		catch (SyntaxError e) { }
	}
	
	private boolean startsDeclaration(TokenKind kind) {
		return kind == TokenKind.PUBLIC ||
				kind == TokenKind.PRIVATE ||
				 kind == TokenKind.STATIC ||
				  startsType(kind) ||
					 kind == TokenKind.VOID;
	}
	
	private boolean startsType(TokenKind kind) {
		return kind == TokenKind.INT ||
				   kind == TokenKind.BOOLEAN ||
					kind == TokenKind.ID;
	}

	
	//   
	private void parseProgram() throws SyntaxError {
		accept(TokenKind.CLASS);
		parseId();
		accept(TokenKind.LCURLY);
		
		while (startsDeclaration(currentToken.kind)) {
			parseVisibility();
			parseAccess();
			switch(currentToken.kind) {
				case VOID:
					parseId();
					accept(TokenKind.LPAREN);
					if (startsType(currentToken.kind)) {
						parseParameterList();
					}
					accept(TokenKind.RPAREN);
					accept(TokenKind.LCURLY);
					
					while (startsStatement(currentToken.kind)) {
						parseStatement();
					}
					accept(TokenKind.RCURLY);
					break;
					
				default:
					if (startsType(currentToken.kind)) {
						parseType();
						parseId();
						switch(currentToken.kind) {
						case SEMICOLON:
							accept(TokenKind.SEMICOLON);
							break;
						case ID:
							parseId();
							accept(TokenKind.LPAREN);
							if (startsType(currentToken.kind)) {
								parseParameterList();
							}
							accept(TokenKind.RPAREN);
							accept(TokenKind.LCURLY);
							
							while (startsStatement(currentToken.kind)) {
								parseStatement();
							}
							accept(TokenKind.RCURLY);
							break;
						}
					}
					else {
						parseError("Parsing wrong in declarations");
					}
					
			}
		}
		
		accept(TokenKind.RCURLY);
		accept(TokenKind.EOT);
	}
	
	private void parseStatement() throws SyntaxError {
		switch (currentToken.kind) {
		case LCURLY:
			acceptIt();
			while (startsStatement(currentToken.kind)) {
				parseStatement();
			}
			System.out.println("in here: " + currentToken);
			accept(TokenKind.RCURLY);
			break;
			
		case INT: case BOOLEAN:
			parseType();
			parseId();
			accept(TokenKind.EQUAL);
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
		
		case ID:
			acceptIt();
			
			switch (currentToken.kind) {
			// in Type
			case ID:
			acceptIt();
			accept(TokenKind.EQUAL);
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
			
			// in Reference
			case EQUAL:
			acceptIt();
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
			
			case LPAREN:
			acceptIt();
			if (currentToken.kind == TokenKind.RPAREN) {
				acceptIt();
			} else {
				parseArgumentList();
				accept(TokenKind.RPAREN);
			}
			accept(TokenKind.SEMICOLON);
			break;
			
			// both
			case LBRACKET: 
			acceptIt();
			// in Type
			if (currentToken.kind == TokenKind.RBRACKET) {
				acceptIt();
				accept(TokenKind.ID);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
			} else {
				// in Reference
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
			}
			break;
			
			case DOT:
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case EQUAL:
				acceptIt();
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LBRACKET: 
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
				}
				accept(TokenKind.SEMICOLON);
				break;
			
			default:
				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);
			}
			default:
				parseError("parsing statement, in subcase ID, current token is: " + currentToken);
			}
			break;
		
		case THIS:
			acceptIt();
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case EQUAL:
				acceptIt();
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LBRACKET:
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
				
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
					accept(TokenKind.SEMICOLON);
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
					accept(TokenKind.SEMICOLON);
				}
				break;
			
			default:
				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);
			}
			break;
			
		case RETURN:
			acceptIt();
			if (currentToken.kind == TokenKind.SEMICOLON) {
				acceptIt();
			} else {
				parseExpression();
				accept(TokenKind.SEMICOLON);
			}
			break;
		
		case IF:
			acceptIt();
			accept(TokenKind.LPAREN);
			parseExpression();
			accept(TokenKind.RPAREN);
			parseStatement();
			if (currentToken.kind == TokenKind.ELSE) {
				acceptIt();
				parseStatement();
			}
			break;
			
		case WHILE:
			acceptIt();
			accept(TokenKind.LPAREN);
			parseExpression();
			accept(TokenKind.RPAREN);
			parseStatement();
			break;
		
		default:
			parseError("parsing statement, current token is:" + currentToken);
		}
		return ;
		
	}


	private void parseArgumentList() {
		// TODO Auto-generated method stub
		parseExpression();
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			parseExpression();
		}
	}


	private void parseExpression() {
		// TODO Auto-generated method stub
		switch (currentToken.kind) {
		case ID: case THIS:
			acceptIt();
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case LBRACKET:
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				break;
			
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
				}
				break;
				
			// just reference
			default:
				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);
			}
			
		case UNOP: case MINUS:
			acceptIt();
			parseExpression();
			break;
		
		case LPAREN:
			acceptIt();
			parseExpression();
			accept(TokenKind.RPAREN);
			break;
		
		case NUM: case TRUE: case FALSE:
			acceptIt();
			break;
		
		case NEW:
			acceptIt();
			switch (currentToken.kind) {
			case ID:
				acceptIt();
				switch (currentToken.kind) {
				case LPAREN:
					acceptIt();
					accept(TokenKind.RPAREN);
					break;
				case LBRACKET:
					acceptIt();
					parseExpression();
					accept(TokenKind.RBRACKET);
					break;
				
				}
			
			case INT:
				acceptIt();
				accept(TokenKind.LBRACKET);
				parseExpression();
				accept(TokenKind.RBRACKET);
				break;
			
			default:
				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);
			}
			break;
		
		default:
			parseError("parsing expression, current token is: " + currentToken);
		}
		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {
			acceptIt();
			parseExpression();
		}
	}


	private boolean startsStatement(TokenKind kind) {
		return kind == TokenKind.LCURLY ||
				startsType(kind) ||
				 startsReference(kind) ||
				  kind == TokenKind.RETURN ||
				   kind == TokenKind.IF ||
					kind == TokenKind.WHILE;
	}


	private boolean startsReference(TokenKind kind) {
		return kind == TokenKind.ID ||
				kind == TokenKind.THIS;
	}


	private void parseParameterList() throws SyntaxError {
		parseType();
		parseId();
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			parseType();
			parseId();
		}
	}


	private void parseType() throws SyntaxError{
		switch (currentToken.kind) {
		case INT:
			acceptIt();
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
			}
			break;
		case BOOLEAN:
			acceptIt();
			break;
		case ID:
			parseId();
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
			}
			break;
		default:
			parseError("Wrong in parsing Type, currentToken is: " + currentToken);
		}
	}


	private void parseId() throws SyntaxError {
		accept(TokenKind.ID);
	}


	private void parseAccess() throws SyntaxError {
		if (currentToken.kind == TokenKind.STATIC) {
			accept(TokenKind.STATIC);
		}
	}


	private void parseVisibility() throws SyntaxError {
		if (currentToken.kind == TokenKind.PRIVATE) {
			accept(TokenKind.PRIVATE);
		} else if (currentToken.kind == TokenKind.PUBLIC) {
			accept(TokenKind.PUBLIC);
		}
	}


	private void parseClassDeclaration() throws SyntaxError {
		while (currentToken.kind == TokenKind.CLASS) {
			parseClassDeclaration();
		}
		accept(TokenKind.EOT);
	}

	/**
	 * accept current token and advance to next token
	 */
	private void acceptIt() throws SyntaxError {
		accept(currentToken.kind);
	}

	/**
	 * verify that current token in input matches expected token and advance to next token
	 * @param expectedToken
	 * @throws SyntaxError  if match fails
	 */
	private void accept(TokenKind expectedTokenKind) throws SyntaxError {
		if (currentToken.kind == expectedTokenKind) {
			currentToken = scanner.scan();
		}
		else
			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +
					"' but found '" + currentToken.kind + "'");
	}

	/**
	 * report parse error and unwind call stack to start of parse
	 * @param e  string with error detail
	 * @throws SyntaxError
	 */
	private void parseError(String e) throws SyntaxError {
		reporter.reportError("Parse error: " + e);
		throw new SyntaxError();
	}

	// show parse stack whenever terminal is  accepted
	private void pTrace() {
		StackTraceElement [] stl = Thread.currentThread().getStackTrace();
		for (int i = stl.length - 1; i > 0 ; i--) {
			if(stl[i].toString().contains("parse"))
				System.out.println(stl[i]);
		}
		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");
		System.out.println();
	}

}
]]></snapshot>
  </Command>
  <DocumentChange __id="643" _type="Insert" date="Thu Feb 24 15:05:37 EST 2022" docASTNodeCount="1522" docActiveCodeLength="10650" docExpressionCount="1057" docLength="11318" length="2" offset="2524" starttimestamp="1645728958172" timestamp="4179017">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="675" _type="Replace" date="Thu Feb 24 15:06:19 EST 2022" docASTNodeCount="1522" docActiveCodeLength="10650" docExpressionCount="1057" docLength="11369" endLine="98" insertionLength="53" int_docASTNodeCount="1522" int_docActiveCodeLength="10648" int_docExpressionCount="1057" int_docLength="11316" length="2" offset="2263" startLine="98" starttimestamp="1645728958172" timestamp="4221478">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[//		System.out.println("in here: " + currentToken);
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="678" _type="Delete" date="Thu Feb 24 15:06:21 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10699" docExpressionCount="1065" docLength="11367" endLine="98" length="2" offset="2263" startLine="98" starttimestamp="1645728958172" timestamp="4223720">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="683" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:25 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4226951">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="684" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:27 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="4229639">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="686" _type="RunCommand" date="Thu Feb 24 15:06:29 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4231074" type="Run" />
  <Command __id="687" _type="RunCommand" date="Thu Feb 24 15:06:29 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4231074" type="Run" />
  <Command __id="688" _type="RunCommand" date="Thu Feb 24 15:06:29 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4231189" type="Run" />
  <Command __id="689" _type="RunCommand" date="Thu Feb 24 15:06:29 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4231189" type="Run" />
  <Command __id="690" _type="EHExceptionCommand" date="Thu Feb 24 15:06:29 EST 2022" starttimestamp="1645728958172" timestamp="4231243" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
in here: miniJava.SyntacticAnalyzer.Token@15db9742
Parse error: Parsing  and expecting 'RCURLY' but found 'EOT'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="691" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:31 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10699" docExpressionCount="1065" docLength="11367" projectName="pa1" starttimestamp="1645728958172" timestamp="4233581">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶import miniJava.ErrorReporter;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public void parse() {¶		currentToken = scanner.scan();¶		try {¶			parseProgram();¶		}¶		catch (SyntaxError e) { }¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) {¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	//   ¶	private void parseProgram() throws SyntaxError {¶		accept(TokenKind.CLASS);¶		parseId();¶		accept(TokenKind.LCURLY);¶		¶		while (startsDeclaration(currentToken.kind)) {¶			parseVisibility();¶			parseAccess();¶			switch(currentToken.kind) {¶				case VOID:¶					parseId();¶					accept(TokenKind.LPAREN);¶					if (startsType(currentToken.kind)) {¶						parseParameterList();¶					}¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.LCURLY);¶					¶					while (startsStatement(currentToken.kind)) {¶						parseStatement();¶					}¶					accept(TokenKind.RCURLY);¶					break;¶					¶				default:¶					if (startsType(currentToken.kind)) {¶						parseType();¶						parseId();¶						switch(currentToken.kind) {¶						case SEMICOLON:¶							accept(TokenKind.SEMICOLON);¶							break;¶						case ID:¶							parseId();¶							accept(TokenKind.LPAREN);¶							if (startsType(currentToken.kind)) {¶								parseParameterList();¶							}¶							accept(TokenKind.RPAREN);¶							accept(TokenKind.LCURLY);¶							¶							while (startsStatement(currentToken.kind)) {¶								parseStatement();¶							}¶							accept(TokenKind.RCURLY);¶							break;¶						}¶					}¶					else {¶						parseError("Parsing wrong in declarations");¶					}¶					¶			}¶		}¶		"), Diff(INSERT,"System.out.println("in here: " + currentToken);¶"), Diff(EQUAL,"¶		accept(TokenKind.RCURLY);¶		accept(TokenKind.EOT);¶	}¶	¶	private void parseStatement() throws SyntaxError {¶		switch (currentToken.kind) {¶		case LCURLY:¶			acceptIt();¶			while (startsStatement(currentToken.kind)) {¶				parseStatement();¶			}¶"), Diff(INSERT,"//"), Diff(EQUAL,"			System.out.println("in here: " + currentToken);¶			accept(TokenKind.RCURLY);¶			break;¶			¶		case INT: case BOOLEAN:¶			parseType();¶			parseId();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶		¶		case ID:¶			acceptIt();¶			¶			switch (currentToken.kind) {¶			// in Type¶			case ID:¶			acceptIt();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// in Reference¶			case EQUAL:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			case LPAREN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.RPAREN) {¶				acceptIt();¶			} else {¶				parseArgumentList();¶				accept(TokenKind.RPAREN);¶			}¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// both¶			case LBRACKET: ¶			acceptIt();¶			// in Type¶			if (currentToken.kind == TokenKind.RBRACKET) {¶				acceptIt();¶				accept(TokenKind.ID);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			} else {¶				// in Reference¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶			¶			case DOT:¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET: ¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);¶			}¶			default:¶				parseError("parsing statement, in subcase ID, current token is: " + currentToken);¶			}¶			break;¶		¶		case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶				¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶					accept(TokenKind.SEMICOLON);¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.SEMICOLON);¶				}¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶			}¶			break;¶			¶		case RETURN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.SEMICOLON) {¶				acceptIt();¶			} else {¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶		¶		case IF:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			if (currentToken.kind == TokenKind.ELSE) {¶				acceptIt();¶				parseStatement();¶			}¶			break;¶			¶		case WHILE:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			break;¶		¶		default:¶			parseError("parsing statement, current token is:" + currentToken);¶		}¶		return ;¶		¶	}¶¶¶	private void parseArgumentList() {¶		// TODO Auto-generated method stub¶		parseExpression();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private void parseExpression() {¶		// TODO Auto-generated method stub¶		switch (currentToken.kind) {¶		case ID: case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				break;¶				¶			// just reference¶			default:¶				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);¶			}¶			¶		case UNOP: case MINUS:¶			acceptIt();¶			parseExpression();¶			break;¶		¶		case LPAREN:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		case NUM: case TRUE: case FALSE:¶			acceptIt();¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶			case ID:¶				acceptIt();¶				switch (currentToken.kind) {¶				case LPAREN:¶					acceptIt();¶					accept(TokenKind.RPAREN);¶					break;¶				case LBRACKET:¶					acceptIt();¶					parseExpression();¶					accept(TokenKind.RBRACKET);¶					break;¶				¶				}¶			¶			case INT:¶				acceptIt();¶				accept(TokenKind.LBRACKET);¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			default:¶				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);¶			}¶			break;¶		¶		default:¶			parseError("parsing expression, current token is: " + currentToken);¶		}¶		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private boolean startsStatement(TokenKind kind) {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private void parseParameterList() throws SyntaxError {¶		parseType();¶		parseId();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseType();¶			parseId();¶		}¶	}¶¶¶	private void parseType() throws SyntaxError{¶		switch (currentToken.kind) {¶		case INT:¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		case BOOLEAN:¶			acceptIt();¶			break;¶		case ID:¶			parseId();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶	}¶¶¶	private void parseId() throws SyntaxError {¶		accept(TokenKind.ID);¶	}¶¶¶	private void parseAccess() throws SyntaxError {¶		if (currentToken.kind == TokenKind.STATIC) {¶			accept(TokenKind.STATIC);¶		}¶	}¶¶¶	private void parseVisibility() throws SyntaxError {¶		if (currentToken.kind == TokenKind.PRIVATE) {¶			accept(TokenKind.PRIVATE);¶		} else if (currentToken.kind == TokenKind.PUBLIC) {¶			accept(TokenKind.PUBLIC);¶		}¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

import miniJava.SyntacticAnalyzer.Scanner;
import miniJava.SyntacticAnalyzer.TokenKind;
import miniJava.ErrorReporter;

public class Parser {
	private Scanner scanner;
	private ErrorReporter reporter;
	private Token currentToken;

	public Parser(Scanner scanner, ErrorReporter reporter) {
		this.scanner = scanner;
		this.reporter = reporter;
	}


	/**
	 *  parse input, catch possible parse error
	 */
	public void parse() {
		currentToken = scanner.scan();
		try {
			parseProgram();
		}
		catch (SyntaxError e) { }
	}
	
	private boolean startsDeclaration(TokenKind kind) {
		return kind == TokenKind.PUBLIC ||
				kind == TokenKind.PRIVATE ||
				 kind == TokenKind.STATIC ||
				  startsType(kind) ||
					 kind == TokenKind.VOID;
	}
	
	private boolean startsType(TokenKind kind) {
		return kind == TokenKind.INT ||
				   kind == TokenKind.BOOLEAN ||
					kind == TokenKind.ID;
	}

	
	//   
	private void parseProgram() throws SyntaxError {
		accept(TokenKind.CLASS);
		parseId();
		accept(TokenKind.LCURLY);
		
		while (startsDeclaration(currentToken.kind)) {
			parseVisibility();
			parseAccess();
			switch(currentToken.kind) {
				case VOID:
					parseId();
					accept(TokenKind.LPAREN);
					if (startsType(currentToken.kind)) {
						parseParameterList();
					}
					accept(TokenKind.RPAREN);
					accept(TokenKind.LCURLY);
					
					while (startsStatement(currentToken.kind)) {
						parseStatement();
					}
					accept(TokenKind.RCURLY);
					break;
					
				default:
					if (startsType(currentToken.kind)) {
						parseType();
						parseId();
						switch(currentToken.kind) {
						case SEMICOLON:
							accept(TokenKind.SEMICOLON);
							break;
						case ID:
							parseId();
							accept(TokenKind.LPAREN);
							if (startsType(currentToken.kind)) {
								parseParameterList();
							}
							accept(TokenKind.RPAREN);
							accept(TokenKind.LCURLY);
							
							while (startsStatement(currentToken.kind)) {
								parseStatement();
							}
							accept(TokenKind.RCURLY);
							break;
						}
					}
					else {
						parseError("Parsing wrong in declarations");
					}
					
			}
		}
		System.out.println("in here: " + currentToken);

		accept(TokenKind.RCURLY);
		accept(TokenKind.EOT);
	}
	
	private void parseStatement() throws SyntaxError {
		switch (currentToken.kind) {
		case LCURLY:
			acceptIt();
			while (startsStatement(currentToken.kind)) {
				parseStatement();
			}
//			System.out.println("in here: " + currentToken);
			accept(TokenKind.RCURLY);
			break;
			
		case INT: case BOOLEAN:
			parseType();
			parseId();
			accept(TokenKind.EQUAL);
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
		
		case ID:
			acceptIt();
			
			switch (currentToken.kind) {
			// in Type
			case ID:
			acceptIt();
			accept(TokenKind.EQUAL);
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
			
			// in Reference
			case EQUAL:
			acceptIt();
			parseExpression();
			accept(TokenKind.SEMICOLON);
			break;
			
			case LPAREN:
			acceptIt();
			if (currentToken.kind == TokenKind.RPAREN) {
				acceptIt();
			} else {
				parseArgumentList();
				accept(TokenKind.RPAREN);
			}
			accept(TokenKind.SEMICOLON);
			break;
			
			// both
			case LBRACKET: 
			acceptIt();
			// in Type
			if (currentToken.kind == TokenKind.RBRACKET) {
				acceptIt();
				accept(TokenKind.ID);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
			} else {
				// in Reference
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
			}
			break;
			
			case DOT:
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case EQUAL:
				acceptIt();
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LBRACKET: 
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
				}
				accept(TokenKind.SEMICOLON);
				break;
			
			default:
				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);
			}
			default:
				parseError("parsing statement, in subcase ID, current token is: " + currentToken);
			}
			break;
		
		case THIS:
			acceptIt();
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case EQUAL:
				acceptIt();
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
			
			case LBRACKET:
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				accept(TokenKind.EQUAL);
				parseExpression();
				accept(TokenKind.SEMICOLON);
				break;
				
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
					accept(TokenKind.SEMICOLON);
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
					accept(TokenKind.SEMICOLON);
				}
				break;
			
			default:
				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);
			}
			break;
			
		case RETURN:
			acceptIt();
			if (currentToken.kind == TokenKind.SEMICOLON) {
				acceptIt();
			} else {
				parseExpression();
				accept(TokenKind.SEMICOLON);
			}
			break;
		
		case IF:
			acceptIt();
			accept(TokenKind.LPAREN);
			parseExpression();
			accept(TokenKind.RPAREN);
			parseStatement();
			if (currentToken.kind == TokenKind.ELSE) {
				acceptIt();
				parseStatement();
			}
			break;
			
		case WHILE:
			acceptIt();
			accept(TokenKind.LPAREN);
			parseExpression();
			accept(TokenKind.RPAREN);
			parseStatement();
			break;
		
		default:
			parseError("parsing statement, current token is:" + currentToken);
		}
		return ;
		
	}


	private void parseArgumentList() {
		// TODO Auto-generated method stub
		parseExpression();
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			parseExpression();
		}
	}


	private void parseExpression() {
		// TODO Auto-generated method stub
		switch (currentToken.kind) {
		case ID: case THIS:
			acceptIt();
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				accept(TokenKind.ID);
			}
			switch (currentToken.kind) {
			case LBRACKET:
				acceptIt();
				parseExpression();
				accept(TokenKind.RBRACKET);
				break;
			
			case LPAREN:
				acceptIt();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
				} else {
					parseArgumentList();
					accept(TokenKind.RPAREN);
				}
				break;
				
			// just reference
			default:
				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);
			}
			
		case UNOP: case MINUS:
			acceptIt();
			parseExpression();
			break;
		
		case LPAREN:
			acceptIt();
			parseExpression();
			accept(TokenKind.RPAREN);
			break;
		
		case NUM: case TRUE: case FALSE:
			acceptIt();
			break;
		
		case NEW:
			acceptIt();
			switch (currentToken.kind) {
			case ID:
				acceptIt();
				switch (currentToken.kind) {
				case LPAREN:
					acceptIt();
					accept(TokenKind.RPAREN);
					break;
				case LBRACKET:
					acceptIt();
					parseExpression();
					accept(TokenKind.RBRACKET);
					break;
				
				}
			
			case INT:
				acceptIt();
				accept(TokenKind.LBRACKET);
				parseExpression();
				accept(TokenKind.RBRACKET);
				break;
			
			default:
				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);
			}
			break;
		
		default:
			parseError("parsing expression, current token is: " + currentToken);
		}
		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {
			acceptIt();
			parseExpression();
		}
	}


	private boolean startsStatement(TokenKind kind) {
		return kind == TokenKind.LCURLY ||
				startsType(kind) ||
				 startsReference(kind) ||
				  kind == TokenKind.RETURN ||
				   kind == TokenKind.IF ||
					kind == TokenKind.WHILE;
	}


	private boolean startsReference(TokenKind kind) {
		return kind == TokenKind.ID ||
				kind == TokenKind.THIS;
	}


	private void parseParameterList() throws SyntaxError {
		parseType();
		parseId();
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			parseType();
			parseId();
		}
	}


	private void parseType() throws SyntaxError{
		switch (currentToken.kind) {
		case INT:
			acceptIt();
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
			}
			break;
		case BOOLEAN:
			acceptIt();
			break;
		case ID:
			parseId();
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
			}
			break;
		default:
			parseError("Wrong in parsing Type, currentToken is: " + currentToken);
		}
	}


	private void parseId() throws SyntaxError {
		accept(TokenKind.ID);
	}


	private void parseAccess() throws SyntaxError {
		if (currentToken.kind == TokenKind.STATIC) {
			accept(TokenKind.STATIC);
		}
	}


	private void parseVisibility() throws SyntaxError {
		if (currentToken.kind == TokenKind.PRIVATE) {
			accept(TokenKind.PRIVATE);
		} else if (currentToken.kind == TokenKind.PUBLIC) {
			accept(TokenKind.PUBLIC);
		}
	}


	private void parseClassDeclaration() throws SyntaxError {
		while (currentToken.kind == TokenKind.CLASS) {
			parseClassDeclaration();
		}
		accept(TokenKind.EOT);
	}

	/**
	 * accept current token and advance to next token
	 */
	private void acceptIt() throws SyntaxError {
		accept(currentToken.kind);
	}

	/**
	 * verify that current token in input matches expected token and advance to next token
	 * @param expectedToken
	 * @throws SyntaxError  if match fails
	 */
	private void accept(TokenKind expectedTokenKind) throws SyntaxError {
		if (currentToken.kind == expectedTokenKind) {
			currentToken = scanner.scan();
		}
		else
			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +
					"' but found '" + currentToken.kind + "'");
	}

	/**
	 * report parse error and unwind call stack to start of parse
	 * @param e  string with error detail
	 * @throws SyntaxError
	 */
	private void parseError(String e) throws SyntaxError {
		reporter.reportError("Parse error: " + e);
		throw new SyntaxError();
	}

	// show parse stack whenever terminal is  accepted
	private void pTrace() {
		StackTraceElement [] stl = Thread.currentThread().getStackTrace();
		for (int i = stl.length - 1; i > 0 ; i--) {
			if(stl[i].toString().contains("parse"))
				System.out.println(stl[i]);
		}
		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");
		System.out.println();
	}

}
]]></snapshot>
  </Command>
  <Command __id="692" _type="MoveCaretCommand" caretOffset="2234" date="Thu Feb 24 15:06:31 EST 2022" docOffset="2312" starttimestamp="1645728958172" timestamp="4233650" />
  <Command __id="693" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:43 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="4245135">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="695" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:45 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4247392">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="696" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:49 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10699" docExpressionCount="1065" docLength="11367" projectName="pa1" starttimestamp="1645728958172" timestamp="4251774">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶import miniJava.ErrorReporter;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public void parse() {¶		currentToken = scanner.scan();¶		try {¶			parseProgram();¶		}¶		catch (SyntaxError e) { }¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) {¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	//   ¶	private void parseProgram() throws SyntaxError {¶		accept(TokenKind.CLASS);¶		parseId();¶		accept(TokenKind.LCURLY);¶		¶		while (startsDeclaration(currentToken.kind)) {¶			parseVisibility();¶			parseAccess();¶			switch(currentToken.kind) {¶				case VOID:¶					parseId();¶					accept(TokenKind.LPAREN);¶					if (startsType(currentToken.kind)) {¶						parseParameterList();¶					}¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.LCURLY);¶					¶					while (startsStatement(currentToken.kind)) {¶						parseStatement();¶					}¶					accept(TokenKind.RCURLY);¶					break;¶					¶				default:¶					if (startsType(currentToken.kind)) {¶						parseType();¶						parseId();¶						switch(currentToken.kind) {¶						case SEMICOLON:¶							accept(TokenKind.SEMICOLON);¶							break;¶						case ID:¶							parseId();¶							accept(TokenKind.LPAREN);¶							if (startsType(currentToken.kind)) {¶								parseParameterList();¶							}¶							accept(TokenKind.RPAREN);¶							accept(TokenKind.LCURLY);¶							¶							while (startsStatement(currentToken.kind)) {¶								parseStatement();¶							}¶							accept(TokenKind.RCURLY);¶							break;¶						}¶					}¶					else {¶						parseError("Parsing wrong in declarations");¶					}¶					¶			}¶		}¶		System.out.println("in here: " + currentToken);¶¶		accept(TokenKind.RCURLY);¶		accept(TokenKind.EOT);¶	}¶	¶	private void parseStatement() throws SyntaxError {¶		switch (currentToken.kind) {¶		case LCURLY:¶			acceptIt();¶			while (startsStatement(currentToken.kind)) {¶				parseStatement();¶			}¶//			System.out.println("in here: " + currentToken);¶			accept(TokenKind.RCURLY);¶			break;¶			¶		case INT: case BOOLEAN:¶			parseType();¶			parseId();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶		¶		case ID:¶			acceptIt();¶			¶			switch (currentToken.kind) {¶			// in Type¶			case ID:¶			acceptIt();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// in Reference¶			case EQUAL:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			case LPAREN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.RPAREN) {¶				acceptIt();¶			} else {¶				parseArgumentList();¶				accept(TokenKind.RPAREN);¶			}¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// both¶			case LBRACKET: ¶			acceptIt();¶			// in Type¶			if (currentToken.kind == TokenKind.RBRACKET) {¶				acceptIt();¶				accept(TokenKind.ID);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			} else {¶				// in Reference¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶			¶			case DOT:¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET: ¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);¶			}¶			default:¶				parseError("parsing statement, in subcase ID, current token is: " + currentToken);¶			}¶			break;¶		¶		case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶				¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶					accept(TokenKind.SEMICOLON);¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.SEMICOLON);¶				}¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶			}¶			break;¶			¶		case RETURN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.SEMICOLON) {¶				acceptIt();¶			} else {¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶		¶		case IF:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			if (currentToken.kind == TokenKind.ELSE) {¶				acceptIt();¶				parseStatement();¶			}¶			break;¶			¶		case WHILE:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			break;¶		¶		default:¶			parseError("parsing statement, current token is:" + currentToken);¶		}¶		return ;¶		¶	}¶¶¶	private void parseArgumentList() {¶		// TODO Auto-generated method stub¶		parseExpression();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private void parseExpression() {¶		// TODO Auto-generated method stub¶		switch (currentToken.kind) {¶		case ID: case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				break;¶				¶			// just reference¶			default:¶				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);¶			}¶			¶		case UNOP: case MINUS:¶			acceptIt();¶			parseExpression();¶			break;¶		¶		case LPAREN:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		case NUM: case TRUE: case FALSE:¶			acceptIt();¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶			case ID:¶				acceptIt();¶				switch (currentToken.kind) {¶				case LPAREN:¶					acceptIt();¶					accept(TokenKind.RPAREN);¶					break;¶				case LBRACKET:¶					acceptIt();¶					parseExpression();¶					accept(TokenKind.RBRACKET);¶					break;¶				¶				}¶			¶			case INT:¶				acceptIt();¶				accept(TokenKind.LBRACKET);¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			default:¶				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);¶			}¶			break;¶		¶		default:¶			parseError("parsing expression, current token is: " + currentToken);¶		}¶		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private boolean startsStatement(TokenKind kind) {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private void parseParameterList() throws SyntaxError {¶		parseType();¶		parseId();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseType();¶			parseId();¶		}¶	}¶¶¶	private void parseType() throws SyntaxError{¶		switch (currentToken.kind) {¶		case INT:¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		case BOOLEAN:¶			acceptIt();¶			break;¶		case ID:¶			parseId();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶	}¶¶¶	private void parseId() throws SyntaxError {¶		accept(TokenKind.ID);¶	}¶¶¶	private void parseAccess() throws SyntaxError {¶		if (currentToken.kind == TokenKind.STATIC) {¶			accept(TokenKind.STATIC);¶		}¶	}¶¶¶	private void parseVisibility() throws SyntaxError {¶		if (currentToken.kind == TokenKind.PRIVATE) {¶			accept(TokenKind.PRIVATE);¶		} else if (currentToken.kind == TokenKind.PUBLIC) {¶			accept(TokenKind.PUBLIC);¶		}¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="698" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:53 EST 2022" docASTNodeCount="46" docActiveCodeLength="297" docExpressionCount="21" docLength="297" projectName="pa1" starttimestamp="1645728958172" timestamp="4254997">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\testfile]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"class ErrorReporter {¶¶		private int numErrors;¶		public static kill;¶¶		static ErrorReporter() {¶			numErrors = 0;¶		}¶¶		public boolean hasErrors() {¶			return numErrors > 0;¶		}¶¶		public void reportError(String message) {¶			System.out.println(message);¶			numErrors++;¶		}	¶}")]]]></diff>
  </Command>
  <Command __id="699" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:53 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10699" docExpressionCount="1065" docLength="11367" projectName="pa1" starttimestamp="1645728958172" timestamp="4255081">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶import miniJava.ErrorReporter;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public void parse() {¶		currentToken = scanner.scan();¶		try {¶			parseProgram();¶		}¶		catch (SyntaxError e) { }¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) {¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	//   ¶	private void parseProgram() throws SyntaxError {¶		accept(TokenKind.CLASS);¶		parseId();¶		accept(TokenKind.LCURLY);¶		¶		while (startsDeclaration(currentToken.kind)) {¶			parseVisibility();¶			parseAccess();¶			switch(currentToken.kind) {¶				case VOID:¶					parseId();¶					accept(TokenKind.LPAREN);¶					if (startsType(currentToken.kind)) {¶						parseParameterList();¶					}¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.LCURLY);¶					¶					while (startsStatement(currentToken.kind)) {¶						parseStatement();¶					}¶					accept(TokenKind.RCURLY);¶					break;¶					¶				default:¶					if (startsType(currentToken.kind)) {¶						parseType();¶						parseId();¶						switch(currentToken.kind) {¶						case SEMICOLON:¶							accept(TokenKind.SEMICOLON);¶							break;¶						case ID:¶							parseId();¶							accept(TokenKind.LPAREN);¶							if (startsType(currentToken.kind)) {¶								parseParameterList();¶							}¶							accept(TokenKind.RPAREN);¶							accept(TokenKind.LCURLY);¶							¶							while (startsStatement(currentToken.kind)) {¶								parseStatement();¶							}¶							accept(TokenKind.RCURLY);¶							break;¶						}¶					}¶					else {¶						parseError("Parsing wrong in declarations");¶					}¶					¶			}¶		}¶		System.out.println("in here: " + currentToken);¶¶		accept(TokenKind.RCURLY);¶		accept(TokenKind.EOT);¶	}¶	¶	private void parseStatement() throws SyntaxError {¶		switch (currentToken.kind) {¶		case LCURLY:¶			acceptIt();¶			while (startsStatement(currentToken.kind)) {¶				parseStatement();¶			}¶//			System.out.println("in here: " + currentToken);¶			accept(TokenKind.RCURLY);¶			break;¶			¶		case INT: case BOOLEAN:¶			parseType();¶			parseId();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶		¶		case ID:¶			acceptIt();¶			¶			switch (currentToken.kind) {¶			// in Type¶			case ID:¶			acceptIt();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// in Reference¶			case EQUAL:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			case LPAREN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.RPAREN) {¶				acceptIt();¶			} else {¶				parseArgumentList();¶				accept(TokenKind.RPAREN);¶			}¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// both¶			case LBRACKET: ¶			acceptIt();¶			// in Type¶			if (currentToken.kind == TokenKind.RBRACKET) {¶				acceptIt();¶				accept(TokenKind.ID);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			} else {¶				// in Reference¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶			¶			case DOT:¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET: ¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);¶			}¶			default:¶				parseError("parsing statement, in subcase ID, current token is: " + currentToken);¶			}¶			break;¶		¶		case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶				¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶					accept(TokenKind.SEMICOLON);¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.SEMICOLON);¶				}¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶			}¶			break;¶			¶		case RETURN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.SEMICOLON) {¶				acceptIt();¶			} else {¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶		¶		case IF:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			if (currentToken.kind == TokenKind.ELSE) {¶				acceptIt();¶				parseStatement();¶			}¶			break;¶			¶		case WHILE:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			break;¶		¶		default:¶			parseError("parsing statement, current token is:" + currentToken);¶		}¶		return ;¶		¶	}¶¶¶	private void parseArgumentList() {¶		// TODO Auto-generated method stub¶		parseExpression();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private void parseExpression() {¶		// TODO Auto-generated method stub¶		switch (currentToken.kind) {¶		case ID: case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				break;¶				¶			// just reference¶			default:¶				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);¶			}¶			¶		case UNOP: case MINUS:¶			acceptIt();¶			parseExpression();¶			break;¶		¶		case LPAREN:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		case NUM: case TRUE: case FALSE:¶			acceptIt();¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶			case ID:¶				acceptIt();¶				switch (currentToken.kind) {¶				case LPAREN:¶					acceptIt();¶					accept(TokenKind.RPAREN);¶					break;¶				case LBRACKET:¶					acceptIt();¶					parseExpression();¶					accept(TokenKind.RBRACKET);¶					break;¶				¶				}¶			¶			case INT:¶				acceptIt();¶				accept(TokenKind.LBRACKET);¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			default:¶				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);¶			}¶			break;¶		¶		default:¶			parseError("parsing expression, current token is: " + currentToken);¶		}¶		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private boolean startsStatement(TokenKind kind) {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private void parseParameterList() throws SyntaxError {¶		parseType();¶		parseId();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseType();¶			parseId();¶		}¶	}¶¶¶	private void parseType() throws SyntaxError{¶		switch (currentToken.kind) {¶		case INT:¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		case BOOLEAN:¶			acceptIt();¶			break;¶		case ID:¶			parseId();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶	}¶¶¶	private void parseId() throws SyntaxError {¶		accept(TokenKind.ID);¶	}¶¶¶	private void parseAccess() throws SyntaxError {¶		if (currentToken.kind == TokenKind.STATIC) {¶			accept(TokenKind.STATIC);¶		}¶	}¶¶¶	private void parseVisibility() throws SyntaxError {¶		if (currentToken.kind == TokenKind.PRIVATE) {¶			accept(TokenKind.PRIVATE);¶		} else if (currentToken.kind == TokenKind.PUBLIC) {¶			accept(TokenKind.PUBLIC);¶		}¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="701" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:56 EST 2022" docASTNodeCount="38" docActiveCodeLength="219" docExpressionCount="17" docLength="219" projectName="pa1" starttimestamp="1645728958172" timestamp="4258362">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\test.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶public class test {¶	public static void main(String[] args) {¶		String[] b = {"F:\\eclipse2018-09\\workspace\\pa1\\src\\miniJava\\testfile"};¶		Compiler a = new Compiler();¶		a.main(b);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="694" _type="MoveCaretCommand" caretOffset="210" date="Thu Feb 24 15:06:43 EST 2022" docOffset="210" starttimestamp="1645728958172" timestamp="4245204" />
  <Command __id="697" _type="MoveCaretCommand" caretOffset="2234" date="Thu Feb 24 15:06:50 EST 2022" docOffset="2312" starttimestamp="1645728958172" timestamp="4251874" />
  <Command __id="700" _type="MoveCaretCommand" caretOffset="2234" date="Thu Feb 24 15:06:53 EST 2022" docOffset="2312" starttimestamp="1645728958172" timestamp="4255282" />
  <Command __id="702" _type="MoveCaretCommand" caretOffset="210" date="Thu Feb 24 15:06:56 EST 2022" docOffset="210" starttimestamp="1645728958172" timestamp="4258431" />
  <Command __id="704" _type="MoveCaretCommand" caretOffset="2234" date="Thu Feb 24 15:06:58 EST 2022" docOffset="2312" starttimestamp="1645728958172" timestamp="4259903" />
  <Command __id="703" _type="DiffBasedFileOpenCommand" date="Thu Feb 24 15:06:58 EST 2022" docASTNodeCount="1531" docActiveCodeLength="10699" docExpressionCount="1065" docLength="11367" projectName="pa1" starttimestamp="1645728958172" timestamp="4259834">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa1\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶import miniJava.ErrorReporter;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public void parse() {¶		currentToken = scanner.scan();¶		try {¶			parseProgram();¶		}¶		catch (SyntaxError e) { }¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) {¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	//   ¶	private void parseProgram() throws SyntaxError {¶		accept(TokenKind.CLASS);¶		parseId();¶		accept(TokenKind.LCURLY);¶		¶		while (startsDeclaration(currentToken.kind)) {¶			parseVisibility();¶			parseAccess();¶			switch(currentToken.kind) {¶				case VOID:¶					parseId();¶					accept(TokenKind.LPAREN);¶					if (startsType(currentToken.kind)) {¶						parseParameterList();¶					}¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.LCURLY);¶					¶					while (startsStatement(currentToken.kind)) {¶						parseStatement();¶					}¶					accept(TokenKind.RCURLY);¶					break;¶					¶				default:¶					if (startsType(currentToken.kind)) {¶						parseType();¶						parseId();¶						switch(currentToken.kind) {¶						case SEMICOLON:¶							accept(TokenKind.SEMICOLON);¶							break;¶						case ID:¶							parseId();¶							accept(TokenKind.LPAREN);¶							if (startsType(currentToken.kind)) {¶								parseParameterList();¶							}¶							accept(TokenKind.RPAREN);¶							accept(TokenKind.LCURLY);¶							¶							while (startsStatement(currentToken.kind)) {¶								parseStatement();¶							}¶							accept(TokenKind.RCURLY);¶							break;¶						}¶					}¶					else {¶						parseError("Parsing wrong in declarations");¶					}¶					¶			}¶		}¶		System.out.println("in here: " + currentToken);¶¶		accept(TokenKind.RCURLY);¶		accept(TokenKind.EOT);¶	}¶	¶	private void parseStatement() throws SyntaxError {¶		switch (currentToken.kind) {¶		case LCURLY:¶			acceptIt();¶			while (startsStatement(currentToken.kind)) {¶				parseStatement();¶			}¶//			System.out.println("in here: " + currentToken);¶			accept(TokenKind.RCURLY);¶			break;¶			¶		case INT: case BOOLEAN:¶			parseType();¶			parseId();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶		¶		case ID:¶			acceptIt();¶			¶			switch (currentToken.kind) {¶			// in Type¶			case ID:¶			acceptIt();¶			accept(TokenKind.EQUAL);¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// in Reference¶			case EQUAL:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			case LPAREN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.RPAREN) {¶				acceptIt();¶			} else {¶				parseArgumentList();¶				accept(TokenKind.RPAREN);¶			}¶			accept(TokenKind.SEMICOLON);¶			break;¶			¶			// both¶			case LBRACKET: ¶			acceptIt();¶			// in Type¶			if (currentToken.kind == TokenKind.RBRACKET) {¶				acceptIt();¶				accept(TokenKind.ID);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			} else {¶				// in Reference¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶			¶			case DOT:¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET: ¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken);¶			}¶			default:¶				parseError("parsing statement, in subcase ID, current token is: " + currentToken);¶			}¶			break;¶		¶		case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case EQUAL:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶			¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				accept(TokenKind.EQUAL);¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶				break;¶				¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶					accept(TokenKind.SEMICOLON);¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶					accept(TokenKind.SEMICOLON);¶				}¶				break;¶			¶			default:¶				parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶			}¶			break;¶			¶		case RETURN:¶			acceptIt();¶			if (currentToken.kind == TokenKind.SEMICOLON) {¶				acceptIt();¶			} else {¶				parseExpression();¶				accept(TokenKind.SEMICOLON);¶			}¶			break;¶		¶		case IF:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			if (currentToken.kind == TokenKind.ELSE) {¶				acceptIt();¶				parseStatement();¶			}¶			break;¶			¶		case WHILE:¶			acceptIt();¶			accept(TokenKind.LPAREN);¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			parseStatement();¶			break;¶		¶		default:¶			parseError("parsing statement, current token is:" + currentToken);¶		}¶		return ;¶		¶	}¶¶¶	private void parseArgumentList() {¶		// TODO Auto-generated method stub¶		parseExpression();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private void parseExpression() {¶		// TODO Auto-generated method stub¶		switch (currentToken.kind) {¶		case ID: case THIS:¶			acceptIt();¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				accept(TokenKind.ID);¶			}¶			switch (currentToken.kind) {¶			case LBRACKET:¶				acceptIt();¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			case LPAREN:¶				acceptIt();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				break;¶				¶			// just reference¶			default:¶				parseError("parsing expressiong, in subcase ID/THIS, current token is: " + currentToken);¶			}¶			¶		case UNOP: case MINUS:¶			acceptIt();¶			parseExpression();¶			break;¶		¶		case LPAREN:¶			acceptIt();¶			parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		case NUM: case TRUE: case FALSE:¶			acceptIt();¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶			case ID:¶				acceptIt();¶				switch (currentToken.kind) {¶				case LPAREN:¶					acceptIt();¶					accept(TokenKind.RPAREN);¶					break;¶				case LBRACKET:¶					acceptIt();¶					parseExpression();¶					accept(TokenKind.RBRACKET);¶					break;¶				¶				}¶			¶			case INT:¶				acceptIt();¶				accept(TokenKind.LBRACKET);¶				parseExpression();¶				accept(TokenKind.RBRACKET);¶				break;¶			¶			default:¶				parseError("parsing expression, in subcase NEW, current token is: " + currentToken);¶			}¶			break;¶		¶		default:¶			parseError("parsing expression, current token is: " + currentToken);¶		}¶		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS) {¶			acceptIt();¶			parseExpression();¶		}¶	}¶¶¶	private boolean startsStatement(TokenKind kind) {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private void parseParameterList() throws SyntaxError {¶		parseType();¶		parseId();¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			parseType();¶			parseId();¶		}¶	}¶¶¶	private void parseType() throws SyntaxError{¶		switch (currentToken.kind) {¶		case INT:¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		case BOOLEAN:¶			acceptIt();¶			break;¶		case ID:¶			parseId();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶	}¶¶¶	private void parseId() throws SyntaxError {¶		accept(TokenKind.ID);¶	}¶¶¶	private void parseAccess() throws SyntaxError {¶		if (currentToken.kind == TokenKind.STATIC) {¶			accept(TokenKind.STATIC);¶		}¶	}¶¶¶	private void parseVisibility() throws SyntaxError {¶		if (currentToken.kind == TokenKind.PRIVATE) {¶			accept(TokenKind.PRIVATE);¶		} else if (currentToken.kind == TokenKind.PUBLIC) {¶			accept(TokenKind.PUBLIC);¶		}¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="705" _type="MoveCaretCommand" caretOffset="2232" date="Thu Feb 24 15:07:16 EST 2022" docOffset="2310" starttimestamp="1645728958172" timestamp="4278778" />
  <Command __id="706" _type="SelectTextCommand" caretOffset="2232" date="Thu Feb 24 15:07:17 EST 2022" end="2232" start="2206" starttimestamp="1645728958172" timestamp="4278962" />
  <Command __id="707" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Thu Feb 24 15:07:17 EST 2022" starttimestamp="1645728958172" timestamp="4279644" />
  <Command __id="709" _type="InsertStringCommand" date="Thu Feb 24 15:07:19 EST 2022" starttimestamp="1645728958172" timestamp="4281232" timestamp2="4281232">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="710" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Thu Feb 24 15:07:19 EST 2022" start_end="START" starttimestamp="1645728958172" timestamp="4281247" />
  <Command __id="711" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Thu Feb 24 15:07:21 EST 2022" start_end="END" starttimestamp="1645728958172" timestamp="4283136" />
  <Command __id="713" _type="InsertStringCommand" date="Thu Feb 24 15:07:21 EST 2022" starttimestamp="1645728958172" timestamp="4283151" timestamp2="4283151">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="721" _type="RunCommand" date="Thu Feb 24 15:07:27 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4289031" type="Run" />
  <Command __id="722" _type="RunCommand" date="Thu Feb 24 15:07:27 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4289031" type="Run" />
  <Command __id="723" _type="RunCommand" date="Thu Feb 24 15:07:27 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4289153" type="Run" />
  <Command __id="724" _type="RunCommand" date="Thu Feb 24 15:07:27 EST 2022" kind="HitBreakPoint" projectName="pa1" starttimestamp="1645728958172" timestamp="4289153" type="Run" />
  <Command __id="725" _type="EHExceptionCommand" date="Thu Feb 24 15:07:27 EST 2022" starttimestamp="1645728958172" timestamp="4289184" type="Exception">
    <outputString><![CDATA[Syntactic analysis ... 
in here: 
Parse error: Parsing  and expecting 'RCURLY' but found 'EOT'
Sytactic analysis complete: Invalid miniJava program
]]></outputString>
  </Command>
  <Command __id="726" _type="ShellCommand" date="Thu Feb 24 15:08:07 EST 2022" starttimestamp="1645728958172" timestamp="4329516" type="ECLIPSE_LOST_FOCUS" />
</Events>
