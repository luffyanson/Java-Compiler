<Events startTimestamp="1650226882502" logVersion="1.0.0.202009141527">
  <Command __id="1" _type="MoveCaretCommand" caretOffset="2218" date="Sun Apr 17 16:21:25 EDT 2022" docOffset="4176" starttimestamp="1650226882502" timestamp="3382" />
  <Command __id="2" _type="ShellCommand" date="Sun Apr 17 16:21:46 EDT 2022" starttimestamp="1650226882502" timestamp="24209" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3" _type="ShellCommand" date="Sun Apr 17 16:30:21 EDT 2022" starttimestamp="1650226882502" timestamp="539246" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4" _type="ShellCommand" date="Sun Apr 17 16:30:23 EDT 2022" starttimestamp="1650226882502" timestamp="540689" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5" _type="ShellCommand" date="Sun Apr 17 16:30:23 EDT 2022" starttimestamp="1650226882502" timestamp="540791" type="ECLIPSE_MINIMIZED" />
  <Command __id="0" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:21:24 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6403" docExpressionCount="649" docLength="7491" projectName="pa3" starttimestamp="1650226882502" timestamp="2165">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="6" _type="ShellCommand" date="Sun Apr 17 16:30:32 EDT 2022" starttimestamp="1650226882502" timestamp="549513" type="ECLIPSE_MAXIMIZED" />
  <Command __id="7" _type="ShellCommand" date="Sun Apr 17 16:30:32 EDT 2022" starttimestamp="1650226882502" timestamp="549777" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:30:49 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="566708">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;

public class IdentificationTable {
	public Stack<HashMap<String, Declaration>> table;
	
	public IdentificationTable(ErrorReporter reporter) {
		// TODO Auto-generated constructor stub
		table = new Stack<HashMap<String, Declaration>>();
	}

	public void openScope() {
		// TODO Auto-generated method stub
		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();
		table.push(newScope);
	}

	public void closeScope() {
		// TODO Auto-generated method stub
		table.pop();
	}

	public void enter(Declaration decl) {
		// TODO Auto-generated method stub
		HashMap<String, Declaration> currScope = table.peek();
		String name = decl.name;
		if (currScope.containsKey(name)) {
			// position ?
			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");
			System.exit(4);
		} else {
			currScope.put(name, decl);
		}
		return;
	}

}
]]></snapshot>
  </Command>
  <Command __id="9" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:30:49 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="566859" />
  <Command __id="11" _type="MoveCaretCommand" caretOffset="2218" date="Sun Apr 17 16:30:49 EDT 2022" docOffset="4176" starttimestamp="1650226882502" timestamp="567302" />
  <Command __id="10" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:30:49 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6403" docExpressionCount="649" docLength="7491" projectName="pa3" starttimestamp="1650226882502" timestamp="567206">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="13" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:30:53 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="571230">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="12" _type="MoveCaretCommand" caretOffset="36" date="Sun Apr 17 16:30:53 EDT 2022" docOffset="36" starttimestamp="1650226882502" timestamp="570629" />
  <Command __id="14" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:30:53 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="571312" />
  <Command __id="16" _type="SelectTextCommand" caretOffset="199" date="Sun Apr 17 16:31:01 EDT 2022" end="199" start="171" starttimestamp="1650226882502" timestamp="578936" />
  <Command __id="17" _type="ShellCommand" date="Sun Apr 17 16:31:03 EDT 2022" starttimestamp="1650226882502" timestamp="581114" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="15" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:31:01 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="578864">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.Token;

public class Identifier extends Terminal {
  public Declaration decl;

  public Identifier (Token t) {
    super (t);
  }

  public <A,R> R visit(Visitor<A,R> v, A o) {
      return v.visitIdentifier(this, o);
  }

}
]]></snapshot>
  </Command>
  <Command __id="19" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:32:30 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="668360">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="21" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:32:34 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="671725">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="23" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:32:35 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="672684">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="25" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:32:35 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6403" docExpressionCount="649" docLength="7491" projectName="pa3" starttimestamp="1650226882502" timestamp="673177">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="18" _type="ShellCommand" date="Sun Apr 17 16:32:30 EDT 2022" starttimestamp="1650226882502" timestamp="668270" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="20" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:32:30 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="668494" />
  <Command __id="22" _type="SelectTextCommand" caretOffset="199" date="Sun Apr 17 16:32:34 EDT 2022" end="199" start="171" starttimestamp="1650226882502" timestamp="671775" />
  <Command __id="24" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:32:35 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="672738" />
  <Command __id="26" _type="MoveCaretCommand" caretOffset="36" date="Sun Apr 17 16:32:35 EDT 2022" docOffset="36" starttimestamp="1650226882502" timestamp="673237" />
  <Command __id="28" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 16:32:49 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="687355" />
  <Command __id="29" _type="ShellCommand" date="Sun Apr 17 16:32:50 EDT 2022" starttimestamp="1650226882502" timestamp="688059" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="30" _type="ShellCommand" date="Sun Apr 17 16:32:57 EDT 2022" starttimestamp="1650226882502" timestamp="695310" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="31" _type="MoveCaretCommand" caretOffset="689" date="Sun Apr 17 16:32:57 EDT 2022" docOffset="937" starttimestamp="1650226882502" timestamp="695389" />
  <Command __id="27" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:32:49 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1144" docExpressionCount="128" docLength="1144" projectName="pa3" starttimestamp="1650226882502" timestamp="687132">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ASTDisplay;
import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(3);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		AST ast = parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			new ASTDisplay().showTree(ast);
			System.exit(0);
		}
	}
}
]]></snapshot>
  </Command>
  <Command __id="32" _type="MoveCaretCommand" caretOffset="826" date="Sun Apr 17 16:33:06 EDT 2022" docOffset="1074" starttimestamp="1650226882502" timestamp="704004" />
  <Command __id="34" _type="InsertStringCommand" date="Sun Apr 17 16:33:08 EDT 2022" starttimestamp="1650226882502" timestamp="705706" timestamp2="705706">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="35" _type="ShellCommand" date="Sun Apr 17 16:34:16 EDT 2022" starttimestamp="1650226882502" timestamp="773742" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="33" _type="Insert" date="Sun Apr 17 16:33:08 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1149" docExpressionCount="128" docLength="1149" length="5" offset="1074" starttimestamp="1650226882502" timestamp="705700">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="36" _type="ShellCommand" date="Sun Apr 17 16:35:52 EDT 2022" starttimestamp="1650226882502" timestamp="870203" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="37" _type="MoveCaretCommand" caretOffset="831" date="Sun Apr 17 16:35:52 EDT 2022" docOffset="1079" starttimestamp="1650226882502" timestamp="870285" />
  <DocumentChange __id="38" _type="Delete" date="Sun Apr 17 16:35:54 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1148" docExpressionCount="128" docLength="1148" endLine="34" length="1" offset="1078" startLine="34" starttimestamp="1650226882502" timestamp="872466">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="39" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:35:54 EDT 2022" starttimestamp="1650226882502" timestamp="872470" />
  <DocumentChange __id="40" _type="Delete" date="Sun Apr 17 16:35:55 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1147" docExpressionCount="128" docLength="1147" endLine="34" length="1" offset="1077" startLine="34" starttimestamp="1650226882502" timestamp="872679">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="41" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:35:55 EDT 2022" starttimestamp="1650226882502" timestamp="872699" />
  <DocumentChange __id="42" _type="Delete" date="Sun Apr 17 16:35:55 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1146" docExpressionCount="128" docLength="1146" endLine="34" length="1" offset="1076" startLine="34" starttimestamp="1650226882502" timestamp="873214">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="43" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:35:55 EDT 2022" starttimestamp="1650226882502" timestamp="873216" />
  <DocumentChange __id="44" _type="Delete" date="Sun Apr 17 16:35:56 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1144" docExpressionCount="128" docLength="1144" endLine="34" length="2" offset="1074" startLine="33" starttimestamp="1650226882502" timestamp="873631">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="45" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:35:56 EDT 2022" starttimestamp="1650226882502" timestamp="873634" />
  <DocumentChange __id="46" _type="Insert" date="Sun Apr 17 16:36:09 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1149" docExpressionCount="128" docLength="1149" length="5" offset="1074" starttimestamp="1650226882502" timestamp="886517">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="47" _type="InsertStringCommand" date="Sun Apr 17 16:36:09 EDT 2022" starttimestamp="1650226882502" timestamp="886520" timestamp2="886520">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="48" _type="Delete" date="Sun Apr 17 16:36:11 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1148" docExpressionCount="128" docLength="1148" endLine="34" length="1" offset="1078" startLine="34" starttimestamp="1650226882502" timestamp="889159">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="49" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:11 EDT 2022" starttimestamp="1650226882502" timestamp="889161" />
  <DocumentChange __id="50" _type="Delete" date="Sun Apr 17 16:36:11 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1147" docExpressionCount="128" docLength="1147" endLine="34" length="1" offset="1077" startLine="34" starttimestamp="1650226882502" timestamp="889340">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="51" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:11 EDT 2022" starttimestamp="1650226882502" timestamp="889343" />
  <DocumentChange __id="52" _type="Delete" date="Sun Apr 17 16:36:12 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1146" docExpressionCount="128" docLength="1146" endLine="34" length="1" offset="1076" startLine="34" starttimestamp="1650226882502" timestamp="889654">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="53" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:12 EDT 2022" starttimestamp="1650226882502" timestamp="889656" />
  <DocumentChange __id="54" _type="Delete" date="Sun Apr 17 16:36:12 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1144" docExpressionCount="128" docLength="1144" endLine="34" length="2" offset="1074" startLine="33" starttimestamp="1650226882502" timestamp="889943">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="55" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:12 EDT 2022" starttimestamp="1650226882502" timestamp="889946" />
  <Command __id="56" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.LINE_DOWN" date="Sun Apr 17 16:36:13 EDT 2022" starttimestamp="1650226882502" timestamp="890699" />
  <DocumentChange __id="57" _type="Insert" date="Sun Apr 17 16:36:13 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1149" docExpressionCount="128" docLength="1149" length="5" offset="1110" starttimestamp="1650226882502" timestamp="891068">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="58" _type="InsertStringCommand" date="Sun Apr 17 16:36:13 EDT 2022" starttimestamp="1650226882502" timestamp="891072" timestamp2="891072">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="59" _type="Insert" date="Sun Apr 17 16:36:19 EDT 2022" docASTNodeCount="186" docActiveCodeLength="1154" docExpressionCount="128" docLength="1154" length="5" offset="1115" starttimestamp="1650226882502" timestamp="897484">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="60" _type="InsertStringCommand" date="Sun Apr 17 16:36:19 EDT 2022" starttimestamp="1650226882502" timestamp="897487" timestamp2="897487">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="61" _type="Insert" date="Sun Apr 17 16:36:20 EDT 2022" docASTNodeCount="190" docActiveCodeLength="1155" docExpressionCount="129" docLength="1155" length="1" offset="1120" starttimestamp="1650226882502" timestamp="898100">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <Command __id="62" _type="InsertStringCommand" date="Sun Apr 17 16:36:20 EDT 2022" starttimestamp="1650226882502" timestamp="898102" timestamp2="898102">
    <data><![CDATA[S]]></data>
  </Command>
  <DocumentChange __id="63" _type="Insert" date="Sun Apr 17 16:36:20 EDT 2022" docASTNodeCount="190" docActiveCodeLength="1156" docExpressionCount="129" docLength="1156" length="1" offset="1121" starttimestamp="1650226882502" timestamp="898458">
    <text><![CDATA[y]]></text>
  </DocumentChange>
  <Command __id="64" _type="InsertStringCommand" date="Sun Apr 17 16:36:20 EDT 2022" starttimestamp="1650226882502" timestamp="898460" timestamp2="898460">
    <data><![CDATA[y]]></data>
  </Command>
  <DocumentChange __id="65" _type="Insert" date="Sun Apr 17 16:36:21 EDT 2022" docASTNodeCount="190" docActiveCodeLength="1157" docExpressionCount="129" docLength="1157" length="1" offset="1122" starttimestamp="1650226882502" timestamp="898566">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="66" _type="InsertStringCommand" date="Sun Apr 17 16:36:21 EDT 2022" starttimestamp="1650226882502" timestamp="898569" timestamp2="898569">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="67" _type="Insert" date="Sun Apr 17 16:36:21 EDT 2022" docASTNodeCount="190" docActiveCodeLength="1158" docExpressionCount="129" docLength="1158" length="1" offset="1123" starttimestamp="1650226882502" timestamp="898720">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="68" _type="InsertStringCommand" date="Sun Apr 17 16:36:21 EDT 2022" starttimestamp="1650226882502" timestamp="898723" timestamp2="898723">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="69" _type="Insert" date="Sun Apr 17 16:36:21 EDT 2022" docASTNodeCount="190" docActiveCodeLength="1159" docExpressionCount="129" docLength="1159" length="1" offset="1124" starttimestamp="1650226882502" timestamp="898836">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="70" _type="InsertStringCommand" date="Sun Apr 17 16:36:21 EDT 2022" starttimestamp="1650226882502" timestamp="898838" timestamp2="898838">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="71" _type="Insert" date="Sun Apr 17 16:36:21 EDT 2022" docASTNodeCount="190" docActiveCodeLength="1160" docExpressionCount="129" docLength="1160" length="1" offset="1125" starttimestamp="1650226882502" timestamp="898943">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="72" _type="InsertStringCommand" date="Sun Apr 17 16:36:21 EDT 2022" starttimestamp="1650226882502" timestamp="898946" timestamp2="898946">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="74" _type="InsertStringCommand" date="Sun Apr 17 16:36:22 EDT 2022" starttimestamp="1650226882502" timestamp="899675" timestamp2="899675">
    <data><![CDATA[.]]></data>
  </Command>
  <DocumentChange __id="73" _type="Insert" date="Sun Apr 17 16:36:22 EDT 2022" docASTNodeCount="188" docActiveCodeLength="1161" docExpressionCount="130" docLength="1161" length="1" offset="1126" starttimestamp="1650226882502" timestamp="899673">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="76" _type="Insert" date="Sun Apr 17 16:36:25 EDT 2022" docASTNodeCount="192" docActiveCodeLength="1162" docExpressionCount="131" docLength="1162" length="1" offset="1127" starttimestamp="1650226882502" timestamp="902850">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="77" _type="Insert" date="Sun Apr 17 16:36:25 EDT 2022" docASTNodeCount="192" docActiveCodeLength="1163" docExpressionCount="131" docLength="1163" length="1" offset="1128" starttimestamp="1650226882502" timestamp="902866">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="78" _type="Insert" date="Sun Apr 17 16:36:25 EDT 2022" docASTNodeCount="192" docActiveCodeLength="1164" docExpressionCount="131" docLength="1164" length="1" offset="1129" starttimestamp="1650226882502" timestamp="902881">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="80" _type="Replace" date="Sun Apr 17 16:36:25 EDT 2022" docASTNodeCount="190" docActiveCodeLength="1165" docExpressionCount="132" docLength="1165" endLine="36" insertionLength="4" int_docASTNodeCount="188" int_docActiveCodeLength="1161" int_docExpressionCount="130" int_docLength="1161" length="3" offset="1127" startLine="36" starttimestamp="1650226882502" timestamp="902907">
    <deletedText><![CDATA[out]]></deletedText>
    <insertedText><![CDATA[out.]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="83" _type="Insert" date="Sun Apr 17 16:36:26 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1166" docExpressionCount="133" docLength="1166" length="1" offset="1131" starttimestamp="1650226882502" timestamp="904324">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="84" _type="Insert" date="Sun Apr 17 16:36:29 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1167" docExpressionCount="133" docLength="1167" length="1" offset="1132" starttimestamp="1650226882502" timestamp="906914">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="85" _type="Insert" date="Sun Apr 17 16:36:29 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1168" docExpressionCount="133" docLength="1168" length="1" offset="1133" starttimestamp="1650226882502" timestamp="907167">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="86" _type="Insert" date="Sun Apr 17 16:36:29 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1169" docExpressionCount="133" docLength="1169" length="1" offset="1134" starttimestamp="1650226882502" timestamp="907310">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="87" _type="Insert" date="Sun Apr 17 16:36:30 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1170" docExpressionCount="133" docLength="1170" length="1" offset="1135" starttimestamp="1650226882502" timestamp="907511">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="88" _type="Delete" date="Sun Apr 17 16:36:30 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1169" docExpressionCount="133" docLength="1169" endLine="36" length="1" offset="1135" startLine="36" starttimestamp="1650226882502" timestamp="907943">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="89" _type="Insert" date="Sun Apr 17 16:36:30 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1170" docExpressionCount="133" docLength="1170" length="1" offset="1135" starttimestamp="1650226882502" timestamp="907995">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="90" _type="Insert" date="Sun Apr 17 16:36:30 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1171" docExpressionCount="133" docLength="1171" length="1" offset="1136" starttimestamp="1650226882502" timestamp="908168">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="91" _type="Insert" date="Sun Apr 17 16:36:30 EDT 2022" docASTNodeCount="194" docActiveCodeLength="1172" docExpressionCount="133" docLength="1172" length="1" offset="1137" starttimestamp="1650226882502" timestamp="908236">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="92" _type="Insert" date="Sun Apr 17 16:36:31 EDT 2022" docASTNodeCount="192" docActiveCodeLength="1174" docExpressionCount="133" docLength="1174" length="2" offset="1138" starttimestamp="1650226882502" timestamp="908641">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="93" _type="Insert" date="Sun Apr 17 16:36:32 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1176" docExpressionCount="134" docLength="1176" length="2" offset="1139" starttimestamp="1650226882502" timestamp="909873">
    <text><![CDATA[""]]></text>
  </DocumentChange>
  <DocumentChange __id="95" _type="Insert" date="Sun Apr 17 16:36:33 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1177" docExpressionCount="134" docLength="1177" length="1" offset="1140" starttimestamp="1650226882502" timestamp="911064">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="97" _type="Insert" date="Sun Apr 17 16:36:33 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1178" docExpressionCount="134" docLength="1178" length="1" offset="1141" starttimestamp="1650226882502" timestamp="911376">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="99" _type="Insert" date="Sun Apr 17 16:36:34 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1179" docExpressionCount="134" docLength="1179" length="1" offset="1142" starttimestamp="1650226882502" timestamp="911541">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="101" _type="Insert" date="Sun Apr 17 16:36:34 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1180" docExpressionCount="134" docLength="1180" length="1" offset="1143" starttimestamp="1650226882502" timestamp="911701">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="75" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 16:36:24 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="902295" />
  <Command __id="79" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 16:36:25 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="902893" />
  <Command __id="81" _type="InsertStringCommand" date="Sun Apr 17 16:36:25 EDT 2022" starttimestamp="1650226882502" timestamp="902940" timestamp2="902940">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="82" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 16:36:25 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="902958" />
  <Command __id="94" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 16:36:32 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="909923" />
  <Command __id="96" _type="InsertStringCommand" date="Sun Apr 17 16:36:33 EDT 2022" starttimestamp="1650226882502" timestamp="911066" timestamp2="911066">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="98" _type="InsertStringCommand" date="Sun Apr 17 16:36:33 EDT 2022" starttimestamp="1650226882502" timestamp="911378" timestamp2="911378">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="100" _type="InsertStringCommand" date="Sun Apr 17 16:36:34 EDT 2022" starttimestamp="1650226882502" timestamp="911543" timestamp2="911543">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="102" _type="InsertStringCommand" date="Sun Apr 17 16:36:34 EDT 2022" starttimestamp="1650226882502" timestamp="911705" timestamp2="911705">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="104" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:35 EDT 2022" starttimestamp="1650226882502" timestamp="912778" />
  <Command __id="106" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:35 EDT 2022" starttimestamp="1650226882502" timestamp="912926" />
  <Command __id="108" _type="InsertStringCommand" date="Sun Apr 17 16:36:35 EDT 2022" starttimestamp="1650226882502" timestamp="912975" timestamp2="912975">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="110" _type="InsertStringCommand" date="Sun Apr 17 16:36:35 EDT 2022" starttimestamp="1650226882502" timestamp="913059" timestamp2="913059">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="112" _type="InsertStringCommand" date="Sun Apr 17 16:36:35 EDT 2022" starttimestamp="1650226882502" timestamp="913219" timestamp2="913219">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="114" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:36 EDT 2022" starttimestamp="1650226882502" timestamp="913513" />
  <Command __id="116" _type="InsertStringCommand" date="Sun Apr 17 16:36:36 EDT 2022" starttimestamp="1650226882502" timestamp="913571" timestamp2="913571">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="118" _type="InsertStringCommand" date="Sun Apr 17 16:36:36 EDT 2022" starttimestamp="1650226882502" timestamp="913689" timestamp2="913689">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="120" _type="InsertStringCommand" date="Sun Apr 17 16:36:36 EDT 2022" starttimestamp="1650226882502" timestamp="913753" timestamp2="913753">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="122" _type="InsertStringCommand" date="Sun Apr 17 16:36:36 EDT 2022" starttimestamp="1650226882502" timestamp="913854" timestamp2="913854">
    <data><![CDATA[g]]></data>
  </Command>
  <Command __id="124" _type="InsertStringCommand" date="Sun Apr 17 16:36:36 EDT 2022" starttimestamp="1650226882502" timestamp="913946" timestamp2="913946">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="126" _type="InsertStringCommand" date="Sun Apr 17 16:36:36 EDT 2022" starttimestamp="1650226882502" timestamp="914298" timestamp2="914298">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="128" _type="InsertStringCommand" date="Sun Apr 17 16:36:37 EDT 2022" starttimestamp="1650226882502" timestamp="914886" timestamp2="914886">
    <data><![CDATA[y]]></data>
  </Command>
  <Command __id="130" _type="InsertStringCommand" date="Sun Apr 17 16:36:37 EDT 2022" starttimestamp="1650226882502" timestamp="915127" timestamp2="915127">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="132" _type="InsertStringCommand" date="Sun Apr 17 16:36:37 EDT 2022" starttimestamp="1650226882502" timestamp="915344" timestamp2="915344">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="134" _type="InsertStringCommand" date="Sun Apr 17 16:36:37 EDT 2022" starttimestamp="1650226882502" timestamp="915444" timestamp2="915444">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="136" _type="InsertStringCommand" date="Sun Apr 17 16:36:38 EDT 2022" starttimestamp="1650226882502" timestamp="915650" timestamp2="915650">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="138" _type="InsertStringCommand" date="Sun Apr 17 16:36:38 EDT 2022" starttimestamp="1650226882502" timestamp="915880" timestamp2="915880">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="140" _type="InsertStringCommand" date="Sun Apr 17 16:36:38 EDT 2022" starttimestamp="1650226882502" timestamp="916014" timestamp2="916014">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="142" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:36:39 EDT 2022" starttimestamp="1650226882502" timestamp="916697" />
  <DocumentChange __id="103" _type="Delete" date="Sun Apr 17 16:36:35 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1179" docExpressionCount="134" docLength="1179" endLine="36" length="1" offset="1143" startLine="36" starttimestamp="1650226882502" timestamp="912776">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="105" _type="Delete" date="Sun Apr 17 16:36:35 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1178" docExpressionCount="134" docLength="1178" endLine="36" length="1" offset="1142" startLine="36" starttimestamp="1650226882502" timestamp="912921">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="107" _type="Insert" date="Sun Apr 17 16:36:35 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1179" docExpressionCount="134" docLength="1179" length="1" offset="1142" starttimestamp="1650226882502" timestamp="912973">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="109" _type="Insert" date="Sun Apr 17 16:36:35 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1180" docExpressionCount="134" docLength="1180" length="1" offset="1143" starttimestamp="1650226882502" timestamp="913055">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="111" _type="Insert" date="Sun Apr 17 16:36:35 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1181" docExpressionCount="134" docLength="1181" length="1" offset="1144" starttimestamp="1650226882502" timestamp="913217">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="113" _type="Delete" date="Sun Apr 17 16:36:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1180" docExpressionCount="134" docLength="1180" endLine="36" length="1" offset="1144" startLine="36" starttimestamp="1650226882502" timestamp="913511">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="115" _type="Insert" date="Sun Apr 17 16:36:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1181" docExpressionCount="134" docLength="1181" length="1" offset="1144" starttimestamp="1650226882502" timestamp="913567">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="117" _type="Insert" date="Sun Apr 17 16:36:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1182" docExpressionCount="134" docLength="1182" length="1" offset="1145" starttimestamp="1650226882502" timestamp="913684">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="119" _type="Insert" date="Sun Apr 17 16:36:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1183" docExpressionCount="134" docLength="1183" length="1" offset="1146" starttimestamp="1650226882502" timestamp="913750">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="121" _type="Insert" date="Sun Apr 17 16:36:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1184" docExpressionCount="134" docLength="1184" length="1" offset="1147" starttimestamp="1650226882502" timestamp="913852">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <DocumentChange __id="123" _type="Insert" date="Sun Apr 17 16:36:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1185" docExpressionCount="134" docLength="1185" length="1" offset="1148" starttimestamp="1650226882502" timestamp="913944">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="125" _type="Insert" date="Sun Apr 17 16:36:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1186" docExpressionCount="134" docLength="1186" length="1" offset="1149" starttimestamp="1650226882502" timestamp="914297">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="127" _type="Insert" date="Sun Apr 17 16:36:37 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1187" docExpressionCount="134" docLength="1187" length="1" offset="1150" starttimestamp="1650226882502" timestamp="914884">
    <text><![CDATA[y]]></text>
  </DocumentChange>
  <DocumentChange __id="129" _type="Insert" date="Sun Apr 17 16:36:37 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1188" docExpressionCount="134" docLength="1188" length="1" offset="1151" starttimestamp="1650226882502" timestamp="915125">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="131" _type="Insert" date="Sun Apr 17 16:36:37 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1189" docExpressionCount="134" docLength="1189" length="1" offset="1152" starttimestamp="1650226882502" timestamp="915342">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="133" _type="Insert" date="Sun Apr 17 16:36:37 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1190" docExpressionCount="134" docLength="1190" length="1" offset="1153" starttimestamp="1650226882502" timestamp="915441">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="135" _type="Insert" date="Sun Apr 17 16:36:38 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1191" docExpressionCount="134" docLength="1191" length="1" offset="1154" starttimestamp="1650226882502" timestamp="915648">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="137" _type="Insert" date="Sun Apr 17 16:36:38 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1192" docExpressionCount="134" docLength="1192" length="1" offset="1155" starttimestamp="1650226882502" timestamp="915877">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="139" _type="Insert" date="Sun Apr 17 16:36:38 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1193" docExpressionCount="134" docLength="1193" length="1" offset="1156" starttimestamp="1650226882502" timestamp="916012">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="141" _type="Delete" date="Sun Apr 17 16:36:39 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1192" docExpressionCount="134" docLength="1192" endLine="36" length="1" offset="1156" startLine="36" starttimestamp="1650226882502" timestamp="916695">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="145" _type="Replace" date="Sun Apr 17 16:36:57 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1186" docExpressionCount="134" docLength="1186" endLine="36" insertionLength="1" int_docASTNodeCount="193" int_docActiveCodeLength="1185" int_docExpressionCount="134" int_docLength="1185" length="7" offset="1149" startLine="36" starttimestamp="1650226882502" timestamp="935380">
    <deletedText><![CDATA[syntact]]></deletedText>
    <insertedText><![CDATA[c]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="147" _type="Insert" date="Sun Apr 17 16:36:58 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1187" docExpressionCount="134" docLength="1187" length="1" offset="1150" starttimestamp="1650226882502" timestamp="935604">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="149" _type="Insert" date="Sun Apr 17 16:36:58 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1188" docExpressionCount="134" docLength="1188" length="1" offset="1151" starttimestamp="1650226882502" timestamp="935708">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="151" _type="Insert" date="Sun Apr 17 16:36:58 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1189" docExpressionCount="134" docLength="1189" length="1" offset="1152" starttimestamp="1650226882502" timestamp="935780">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="153" _type="Insert" date="Sun Apr 17 16:36:58 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1190" docExpressionCount="134" docLength="1190" length="1" offset="1153" starttimestamp="1650226882502" timestamp="935917">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="155" _type="Insert" date="Sun Apr 17 16:36:58 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1191" docExpressionCount="134" docLength="1191" length="1" offset="1154" starttimestamp="1650226882502" timestamp="936184">
    <text><![CDATA[x]]></text>
  </DocumentChange>
  <DocumentChange __id="157" _type="Insert" date="Sun Apr 17 16:36:58 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1192" docExpressionCount="134" docLength="1192" length="1" offset="1155" starttimestamp="1650226882502" timestamp="936357">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="159" _type="Insert" date="Sun Apr 17 16:36:59 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1193" docExpressionCount="134" docLength="1193" length="1" offset="1156" starttimestamp="1650226882502" timestamp="936837">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="161" _type="Insert" date="Sun Apr 17 16:36:59 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1194" docExpressionCount="134" docLength="1194" length="1" offset="1157" starttimestamp="1650226882502" timestamp="936980">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="163" _type="Insert" date="Sun Apr 17 16:36:59 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1195" docExpressionCount="134" docLength="1195" length="1" offset="1158" starttimestamp="1650226882502" timestamp="937085">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="165" _type="Insert" date="Sun Apr 17 16:36:59 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1196" docExpressionCount="134" docLength="1196" length="1" offset="1159" starttimestamp="1650226882502" timestamp="937364">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="167" _type="Insert" date="Sun Apr 17 16:37:00 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1197" docExpressionCount="134" docLength="1197" length="1" offset="1160" starttimestamp="1650226882502" timestamp="938381">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="169" _type="Insert" date="Sun Apr 17 16:37:01 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1198" docExpressionCount="134" docLength="1198" length="1" offset="1161" starttimestamp="1650226882502" timestamp="938584">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="171" _type="Insert" date="Sun Apr 17 16:37:01 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1199" docExpressionCount="134" docLength="1199" length="1" offset="1162" starttimestamp="1650226882502" timestamp="938715">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="173" _type="Insert" date="Sun Apr 17 16:37:01 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1200" docExpressionCount="134" docLength="1200" length="1" offset="1163" starttimestamp="1650226882502" timestamp="939115">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="175" _type="Insert" date="Sun Apr 17 16:37:02 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1201" docExpressionCount="134" docLength="1201" length="1" offset="1164" starttimestamp="1650226882502" timestamp="939528">
    <text><![CDATA[y]]></text>
  </DocumentChange>
  <DocumentChange __id="177" _type="Insert" date="Sun Apr 17 16:37:02 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1202" docExpressionCount="134" docLength="1202" length="1" offset="1165" starttimestamp="1650226882502" timestamp="939699">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="179" _type="Insert" date="Sun Apr 17 16:37:02 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1203" docExpressionCount="134" docLength="1203" length="1" offset="1166" starttimestamp="1650226882502" timestamp="939927">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="181" _type="Insert" date="Sun Apr 17 16:37:02 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1204" docExpressionCount="134" docLength="1204" length="1" offset="1167" starttimestamp="1650226882502" timestamp="940176">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="143" _type="MoveCaretCommand" caretOffset="904" date="Sun Apr 17 16:36:57 EDT 2022" docOffset="1152" starttimestamp="1650226882502" timestamp="934757" />
  <Command __id="144" _type="SelectTextCommand" caretOffset="908" date="Sun Apr 17 16:36:57 EDT 2022" end="908" start="901" starttimestamp="1650226882502" timestamp="934907" />
  <Command __id="146" _type="InsertStringCommand" date="Sun Apr 17 16:36:57 EDT 2022" starttimestamp="1650226882502" timestamp="935385" timestamp2="935385">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="148" _type="InsertStringCommand" date="Sun Apr 17 16:36:58 EDT 2022" starttimestamp="1650226882502" timestamp="935606" timestamp2="935606">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="150" _type="InsertStringCommand" date="Sun Apr 17 16:36:58 EDT 2022" starttimestamp="1650226882502" timestamp="935710" timestamp2="935710">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="152" _type="InsertStringCommand" date="Sun Apr 17 16:36:58 EDT 2022" starttimestamp="1650226882502" timestamp="935785" timestamp2="935785">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="154" _type="InsertStringCommand" date="Sun Apr 17 16:36:58 EDT 2022" starttimestamp="1650226882502" timestamp="935920" timestamp2="935920">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="156" _type="InsertStringCommand" date="Sun Apr 17 16:36:58 EDT 2022" starttimestamp="1650226882502" timestamp="936186" timestamp2="936186">
    <data><![CDATA[x]]></data>
  </Command>
  <Command __id="158" _type="InsertStringCommand" date="Sun Apr 17 16:36:58 EDT 2022" starttimestamp="1650226882502" timestamp="936358" timestamp2="936358">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="160" _type="InsertStringCommand" date="Sun Apr 17 16:36:59 EDT 2022" starttimestamp="1650226882502" timestamp="936839" timestamp2="936839">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="162" _type="InsertStringCommand" date="Sun Apr 17 16:36:59 EDT 2022" starttimestamp="1650226882502" timestamp="936985" timestamp2="936985">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="164" _type="InsertStringCommand" date="Sun Apr 17 16:36:59 EDT 2022" starttimestamp="1650226882502" timestamp="937090" timestamp2="937090">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="166" _type="InsertStringCommand" date="Sun Apr 17 16:36:59 EDT 2022" starttimestamp="1650226882502" timestamp="937366" timestamp2="937366">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="168" _type="InsertStringCommand" date="Sun Apr 17 16:37:00 EDT 2022" starttimestamp="1650226882502" timestamp="938383" timestamp2="938383">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="170" _type="InsertStringCommand" date="Sun Apr 17 16:37:01 EDT 2022" starttimestamp="1650226882502" timestamp="938586" timestamp2="938586">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="172" _type="InsertStringCommand" date="Sun Apr 17 16:37:01 EDT 2022" starttimestamp="1650226882502" timestamp="938718" timestamp2="938718">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="174" _type="InsertStringCommand" date="Sun Apr 17 16:37:01 EDT 2022" starttimestamp="1650226882502" timestamp="939118" timestamp2="939118">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="176" _type="InsertStringCommand" date="Sun Apr 17 16:37:02 EDT 2022" starttimestamp="1650226882502" timestamp="939530" timestamp2="939530">
    <data><![CDATA[y]]></data>
  </Command>
  <Command __id="178" _type="InsertStringCommand" date="Sun Apr 17 16:37:02 EDT 2022" starttimestamp="1650226882502" timestamp="939701" timestamp2="939701">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="180" _type="InsertStringCommand" date="Sun Apr 17 16:37:02 EDT 2022" starttimestamp="1650226882502" timestamp="939929" timestamp2="939929">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="182" _type="InsertStringCommand" date="Sun Apr 17 16:37:02 EDT 2022" starttimestamp="1650226882502" timestamp="940178" timestamp2="940178">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="184" _type="InsertStringCommand" date="Sun Apr 17 16:37:04 EDT 2022" starttimestamp="1650226882502" timestamp="941524" timestamp2="941524">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="186" _type="InsertStringCommand" date="Sun Apr 17 16:37:04 EDT 2022" starttimestamp="1650226882502" timestamp="941662" timestamp2="941662">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="188" _type="InsertStringCommand" date="Sun Apr 17 16:37:04 EDT 2022" starttimestamp="1650226882502" timestamp="941810" timestamp2="941810">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="189" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:37:04 EDT 2022" starttimestamp="1650226882502" timestamp="942299" />
  <Command __id="190" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:37:05 EDT 2022" starttimestamp="1650226882502" timestamp="942836" />
  <Command __id="192" _type="InsertStringCommand" date="Sun Apr 17 16:37:05 EDT 2022" starttimestamp="1650226882502" timestamp="943463" timestamp2="943463">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="194" _type="InsertStringCommand" date="Sun Apr 17 16:37:06 EDT 2022" starttimestamp="1650226882502" timestamp="943611" timestamp2="943611">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="195" _type="SelectTextCommand" caretOffset="936" date="Sun Apr 17 16:37:23 EDT 2022" end="951" start="936" starttimestamp="1650226882502" timestamp="961076" />
  <Command __id="198" _type="MoveCaretCommand" caretOffset="941" date="Sun Apr 17 16:37:25 EDT 2022" docOffset="1189" starttimestamp="1650226882502" timestamp="962540" />
  <Command __id="200" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.smartEnter" date="Sun Apr 17 16:37:25 EDT 2022" starttimestamp="1650226882502" timestamp="963257" />
  <Command __id="202" _type="InsertStringCommand" date="Sun Apr 17 16:37:26 EDT 2022" starttimestamp="1650226882502" timestamp="963504" timestamp2="963504">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="204" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:37:26 EDT 2022" starttimestamp="1650226882502" timestamp="964020" />
  <Command __id="206" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:37:26 EDT 2022" starttimestamp="1650226882502" timestamp="964223" />
  <Command __id="208" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:37:26 EDT 2022" starttimestamp="1650226882502" timestamp="964470" />
  <Command __id="209" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.LINE_UP" date="Sun Apr 17 16:37:27 EDT 2022" starttimestamp="1650226882502" timestamp="965053" />
  <Command __id="210" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:37:27 EDT 2022" starttimestamp="1650226882502" timestamp="965213" />
  <Command __id="212" _type="InsertStringCommand" date="Sun Apr 17 16:37:28 EDT 2022" starttimestamp="1650226882502" timestamp="965513" timestamp2="965513">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="214" _type="InsertStringCommand" date="Sun Apr 17 16:37:28 EDT 2022" starttimestamp="1650226882502" timestamp="965729" timestamp2="965729">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="216" _type="InsertStringCommand" date="Sun Apr 17 16:37:28 EDT 2022" starttimestamp="1650226882502" timestamp="965920" timestamp2="965920">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="217" _type="MoveCaretCommand" caretOffset="867" date="Sun Apr 17 16:37:29 EDT 2022" docOffset="1115" starttimestamp="1650226882502" timestamp="967452" />
  <Command __id="218" _type="MoveCaretCommand" caretOffset="926" date="Sun Apr 17 16:37:30 EDT 2022" docOffset="1174" starttimestamp="1650226882502" timestamp="967820" />
  <Command __id="219" _type="SelectTextCommand" caretOffset="831" date="Sun Apr 17 16:37:31 EDT 2022" end="926" start="831" starttimestamp="1650226882502" timestamp="969348" />
  <Command __id="220" _type="MoveCaretCommand" caretOffset="892" date="Sun Apr 17 16:37:32 EDT 2022" docOffset="1140" starttimestamp="1650226882502" timestamp="970105" />
  <Command __id="221" _type="SelectTextCommand" caretOffset="866" date="Sun Apr 17 16:37:33 EDT 2022" end="931" start="866" starttimestamp="1650226882502" timestamp="971180" />
  <Command __id="222" _type="MoveCaretCommand" caretOffset="866" date="Sun Apr 17 16:37:33 EDT 2022" docOffset="1114" starttimestamp="1650226882502" timestamp="971380" />
  <DocumentChange __id="183" _type="Insert" date="Sun Apr 17 16:37:04 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1205" docExpressionCount="134" docLength="1205" length="1" offset="1168" starttimestamp="1650226882502" timestamp="941521">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="185" _type="Insert" date="Sun Apr 17 16:37:04 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1206" docExpressionCount="134" docLength="1206" length="1" offset="1169" starttimestamp="1650226882502" timestamp="941661">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="187" _type="Insert" date="Sun Apr 17 16:37:04 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1207" docExpressionCount="134" docLength="1207" length="1" offset="1170" starttimestamp="1650226882502" timestamp="941808">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="191" _type="Insert" date="Sun Apr 17 16:37:05 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1208" docExpressionCount="134" docLength="1208" length="1" offset="1173" starttimestamp="1650226882502" timestamp="943459">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="193" _type="Insert" date="Sun Apr 17 16:37:06 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1213" docExpressionCount="134" docLength="1213" length="5" offset="1174" starttimestamp="1650226882502" timestamp="943604">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <DocumentChange __id="196" _type="Insert" date="Sun Apr 17 16:37:24 EDT 2022" docASTNodeCount="198" docActiveCodeLength="1228" docExpressionCount="138" docLength="1228" length="15" offset="1204" starttimestamp="1650226882502" timestamp="962053">
    <text><![CDATA[System.exit(0);]]></text>
  </DocumentChange>
  <DocumentChange __id="197" _type="Delete" date="Sun Apr 17 16:37:24 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1213" docExpressionCount="134" docLength="1213" endLine="38" length="15" offset="1184" startLine="38" starttimestamp="1650226882502" timestamp="962056">
    <text><![CDATA[System.exit(0);]]></text>
  </DocumentChange>
  <DocumentChange __id="199" _type="Insert" date="Sun Apr 17 16:37:25 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1217" docExpressionCount="134" docLength="1217" length="4" offset="1204" starttimestamp="1650226882502" timestamp="963254">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="201" _type="Insert" date="Sun Apr 17 16:37:26 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1221" docExpressionCount="134" docLength="1221" length="4" offset="1208" starttimestamp="1650226882502" timestamp="963500">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="203" _type="Delete" date="Sun Apr 17 16:37:26 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1220" docExpressionCount="134" docLength="1220" endLine="41" length="1" offset="1211" startLine="41" starttimestamp="1650226882502" timestamp="964018">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="205" _type="Delete" date="Sun Apr 17 16:37:26 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1219" docExpressionCount="134" docLength="1219" endLine="41" length="1" offset="1210" startLine="41" starttimestamp="1650226882502" timestamp="964220">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="207" _type="Delete" date="Sun Apr 17 16:37:26 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1217" docExpressionCount="134" docLength="1217" endLine="41" length="2" offset="1208" startLine="40" starttimestamp="1650226882502" timestamp="964467">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="211" _type="Insert" date="Sun Apr 17 16:37:28 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1221" docExpressionCount="134" docLength="1221" length="4" offset="1189" starttimestamp="1650226882502" timestamp="965508">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="213" _type="Insert" date="Sun Apr 17 16:37:28 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1225" docExpressionCount="134" docLength="1225" length="4" offset="1193" starttimestamp="1650226882502" timestamp="965724">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="215" _type="Insert" date="Sun Apr 17 16:37:28 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1229" docExpressionCount="134" docLength="1229" length="4" offset="1197" starttimestamp="1650226882502" timestamp="965915">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="223" _type="SelectTextCommand" caretOffset="872" date="Sun Apr 17 16:37:35 EDT 2022" end="926" start="872" starttimestamp="1650226882502" timestamp="972804" />
  <Command __id="226" _type="MoveCaretCommand" caretOffset="882" date="Sun Apr 17 16:37:37 EDT 2022" docOffset="1130" starttimestamp="1650226882502" timestamp="974676" />
  <Command __id="227" _type="MoveCaretCommand" caretOffset="887" date="Sun Apr 17 16:37:37 EDT 2022" docOffset="1135" starttimestamp="1650226882502" timestamp="975100" />
  <Command __id="228" _type="MoveCaretCommand" caretOffset="891" date="Sun Apr 17 16:37:38 EDT 2022" docOffset="1139" starttimestamp="1650226882502" timestamp="975844" />
  <DocumentChange __id="224" _type="Insert" date="Sun Apr 17 16:37:36 EDT 2022" docASTNodeCount="200" docActiveCodeLength="1283" docExpressionCount="140" docLength="1283" length="54" offset="1197" starttimestamp="1650226882502" timestamp="974237">
    <text><![CDATA[System.out.println("Starting contextual analysis...");]]></text>
  </DocumentChange>
  <DocumentChange __id="225" _type="Delete" date="Sun Apr 17 16:37:36 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1229" docExpressionCount="134" docLength="1229" endLine="36" length="54" offset="1120" startLine="36" starttimestamp="1650226882502" timestamp="974243">
    <text><![CDATA[System.out.println("Starting contextual analysis...");]]></text>
  </DocumentChange>
  <DocumentChange __id="230" _type="Delete" date="Sun Apr 17 16:37:40 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1224" docExpressionCount="134" docLength="1224" endLine="38" length="5" offset="1122" startLine="37" starttimestamp="1650226882502" timestamp="978287">
    <text><![CDATA[			
]]></text>
  </DocumentChange>
  <DocumentChange __id="233" _type="Delete" date="Sun Apr 17 16:37:41 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1219" docExpressionCount="134" docLength="1219" endLine="36" length="5" offset="1112" startLine="35" starttimestamp="1650226882502" timestamp="978878">
    <text><![CDATA[			
]]></text>
  </DocumentChange>
  <DocumentChange __id="236" _type="Delete" date="Sun Apr 17 16:37:41 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1214" docExpressionCount="134" docLength="1214" endLine="36" length="5" offset="1112" startLine="35" starttimestamp="1650226882502" timestamp="979374">
    <text><![CDATA[			
]]></text>
  </DocumentChange>
  <DocumentChange __id="238" _type="Delete" date="Sun Apr 17 16:37:42 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1209" docExpressionCount="134" docLength="1209" endLine="36" length="5" offset="1112" startLine="35" starttimestamp="1650226882502" timestamp="980022">
    <text><![CDATA[			
]]></text>
  </DocumentChange>
  <DocumentChange __id="242" _type="Insert" date="Sun Apr 17 16:38:03 EDT 2022" docASTNodeCount="193" docActiveCodeLength="1213" docExpressionCount="134" docLength="1213" length="4" offset="1177" starttimestamp="1650226882502" timestamp="1000628">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="229" _type="MoveCaretCommand" caretOffset="877" date="Sun Apr 17 16:37:40 EDT 2022" docOffset="1125" starttimestamp="1650226882502" timestamp="977724" />
  <Command __id="231" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.delete.line" date="Sun Apr 17 16:37:40 EDT 2022" starttimestamp="1650226882502" timestamp="978289" />
  <Command __id="232" _type="MoveCaretCommand" caretOffset="867" date="Sun Apr 17 16:37:41 EDT 2022" docOffset="1115" starttimestamp="1650226882502" timestamp="978732" />
  <Command __id="234" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.delete.line" date="Sun Apr 17 16:37:41 EDT 2022" starttimestamp="1650226882502" timestamp="978880" />
  <Command __id="235" _type="MoveCaretCommand" caretOffset="864" date="Sun Apr 17 16:37:41 EDT 2022" docOffset="1112" starttimestamp="1650226882502" timestamp="979284" />
  <Command __id="237" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.delete.line" date="Sun Apr 17 16:37:41 EDT 2022" starttimestamp="1650226882502" timestamp="979376" />
  <Command __id="239" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.delete.line" date="Sun Apr 17 16:37:42 EDT 2022" starttimestamp="1650226882502" timestamp="980026" />
  <Command __id="240" _type="MoveCaretCommand" caretOffset="948" date="Sun Apr 17 16:37:43 EDT 2022" docOffset="1196" starttimestamp="1650226882502" timestamp="980988" />
  <Command __id="241" _type="MoveCaretCommand" caretOffset="929" date="Sun Apr 17 16:37:43 EDT 2022" docOffset="1177" starttimestamp="1650226882502" timestamp="981340" />
  <Command __id="243" _type="InsertStringCommand" date="Sun Apr 17 16:38:03 EDT 2022" starttimestamp="1650226882502" timestamp="1000633" timestamp2="1000633">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="245" _type="InsertStringCommand" date="Sun Apr 17 16:38:04 EDT 2022" starttimestamp="1650226882502" timestamp="1002015" timestamp2="1002015">
    <data><![CDATA[I]]></data>
  </Command>
  <Command __id="247" _type="InsertStringCommand" date="Sun Apr 17 16:38:04 EDT 2022" starttimestamp="1650226882502" timestamp="1002290" timestamp2="1002290">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="249" _type="InsertStringCommand" date="Sun Apr 17 16:38:04 EDT 2022" starttimestamp="1650226882502" timestamp="1002456" timestamp2="1002456">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="251" _type="InsertStringCommand" date="Sun Apr 17 16:38:05 EDT 2022" starttimestamp="1650226882502" timestamp="1002542" timestamp2="1002542">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="253" _type="InsertStringCommand" date="Sun Apr 17 16:38:05 EDT 2022" starttimestamp="1650226882502" timestamp="1002654" timestamp2="1002654">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="255" _type="InsertStringCommand" date="Sun Apr 17 16:38:05 EDT 2022" starttimestamp="1650226882502" timestamp="1002761" timestamp2="1002761">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="257" _type="InsertStringCommand" date="Sun Apr 17 16:38:05 EDT 2022" starttimestamp="1650226882502" timestamp="1003137" timestamp2="1003137">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="259" _type="InsertStringCommand" date="Sun Apr 17 16:38:05 EDT 2022" starttimestamp="1650226882502" timestamp="1003204" timestamp2="1003204">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="261" _type="InsertStringCommand" date="Sun Apr 17 16:38:05 EDT 2022" starttimestamp="1650226882502" timestamp="1003425" timestamp2="1003425">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="263" _type="InsertStringCommand" date="Sun Apr 17 16:38:06 EDT 2022" starttimestamp="1650226882502" timestamp="1003563" timestamp2="1003563">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="265" _type="InsertStringCommand" date="Sun Apr 17 16:38:06 EDT 2022" starttimestamp="1650226882502" timestamp="1003730" timestamp2="1003730">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="267" _type="InsertStringCommand" date="Sun Apr 17 16:38:06 EDT 2022" starttimestamp="1650226882502" timestamp="1003820" timestamp2="1003820">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="269" _type="InsertStringCommand" date="Sun Apr 17 16:38:06 EDT 2022" starttimestamp="1650226882502" timestamp="1003896" timestamp2="1003896">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="271" _type="InsertStringCommand" date="Sun Apr 17 16:38:06 EDT 2022" starttimestamp="1650226882502" timestamp="1003986" timestamp2="1003986">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="244" _type="Insert" date="Sun Apr 17 16:38:04 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1214" docExpressionCount="135" docLength="1214" length="1" offset="1181" starttimestamp="1650226882502" timestamp="1002012">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="246" _type="Insert" date="Sun Apr 17 16:38:04 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1215" docExpressionCount="135" docLength="1215" length="1" offset="1182" starttimestamp="1650226882502" timestamp="1002287">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="248" _type="Insert" date="Sun Apr 17 16:38:04 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1216" docExpressionCount="135" docLength="1216" length="1" offset="1183" starttimestamp="1650226882502" timestamp="1002447">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="250" _type="Insert" date="Sun Apr 17 16:38:05 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1217" docExpressionCount="135" docLength="1217" length="1" offset="1184" starttimestamp="1650226882502" timestamp="1002534">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="252" _type="Insert" date="Sun Apr 17 16:38:05 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1218" docExpressionCount="135" docLength="1218" length="1" offset="1185" starttimestamp="1650226882502" timestamp="1002651">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="254" _type="Insert" date="Sun Apr 17 16:38:05 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1219" docExpressionCount="135" docLength="1219" length="1" offset="1186" starttimestamp="1650226882502" timestamp="1002759">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="256" _type="Insert" date="Sun Apr 17 16:38:05 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1220" docExpressionCount="135" docLength="1220" length="1" offset="1187" starttimestamp="1650226882502" timestamp="1003135">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <DocumentChange __id="258" _type="Insert" date="Sun Apr 17 16:38:05 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1221" docExpressionCount="135" docLength="1221" length="1" offset="1188" starttimestamp="1650226882502" timestamp="1003198">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="260" _type="Insert" date="Sun Apr 17 16:38:05 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1222" docExpressionCount="135" docLength="1222" length="1" offset="1189" starttimestamp="1650226882502" timestamp="1003423">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="262" _type="Insert" date="Sun Apr 17 16:38:06 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1223" docExpressionCount="135" docLength="1223" length="1" offset="1190" starttimestamp="1650226882502" timestamp="1003557">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="264" _type="Insert" date="Sun Apr 17 16:38:06 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1224" docExpressionCount="135" docLength="1224" length="1" offset="1191" starttimestamp="1650226882502" timestamp="1003727">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="266" _type="Insert" date="Sun Apr 17 16:38:06 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1225" docExpressionCount="135" docLength="1225" length="1" offset="1192" starttimestamp="1650226882502" timestamp="1003815">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="268" _type="Insert" date="Sun Apr 17 16:38:06 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1226" docExpressionCount="135" docLength="1226" length="1" offset="1193" starttimestamp="1650226882502" timestamp="1003891">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="270" _type="Insert" date="Sun Apr 17 16:38:06 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1227" docExpressionCount="135" docLength="1227" length="1" offset="1194" starttimestamp="1650226882502" timestamp="1003983">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="272" _type="Insert" date="Sun Apr 17 16:38:06 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1228" docExpressionCount="135" docLength="1228" length="1" offset="1195" starttimestamp="1650226882502" timestamp="1004359">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="274" _type="Insert" date="Sun Apr 17 16:38:07 EDT 2022" docASTNodeCount="198" docActiveCodeLength="1229" docExpressionCount="136" docLength="1229" length="1" offset="1196" starttimestamp="1650226882502" timestamp="1004967">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="276" _type="Insert" date="Sun Apr 17 16:38:07 EDT 2022" docASTNodeCount="198" docActiveCodeLength="1230" docExpressionCount="136" docLength="1230" length="1" offset="1197" starttimestamp="1650226882502" timestamp="1005035">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="278" _type="Insert" date="Sun Apr 17 16:38:07 EDT 2022" docASTNodeCount="198" docActiveCodeLength="1231" docExpressionCount="136" docLength="1231" length="1" offset="1198" starttimestamp="1650226882502" timestamp="1005215">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="280" _type="Insert" date="Sun Apr 17 16:38:08 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1232" docExpressionCount="136" docLength="1232" length="1" offset="1199" starttimestamp="1650226882502" timestamp="1006461">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="282" _type="Insert" date="Sun Apr 17 16:38:09 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1233" docExpressionCount="136" docLength="1233" length="1" offset="1200" starttimestamp="1650226882502" timestamp="1007114">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="284" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:38:10 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6403" docExpressionCount="649" docLength="7491" projectName="pa3" starttimestamp="1650226882502" timestamp="1008373">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="273" _type="InsertStringCommand" date="Sun Apr 17 16:38:06 EDT 2022" starttimestamp="1650226882502" timestamp="1004361" timestamp2="1004361">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="275" _type="InsertStringCommand" date="Sun Apr 17 16:38:07 EDT 2022" starttimestamp="1650226882502" timestamp="1004972" timestamp2="1004972">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="277" _type="InsertStringCommand" date="Sun Apr 17 16:38:07 EDT 2022" starttimestamp="1650226882502" timestamp="1005038" timestamp2="1005038">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="279" _type="InsertStringCommand" date="Sun Apr 17 16:38:07 EDT 2022" starttimestamp="1650226882502" timestamp="1005218" timestamp2="1005218">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="281" _type="InsertStringCommand" date="Sun Apr 17 16:38:08 EDT 2022" starttimestamp="1650226882502" timestamp="1006466" timestamp2="1006466">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="283" _type="InsertStringCommand" date="Sun Apr 17 16:38:09 EDT 2022" starttimestamp="1650226882502" timestamp="1007118" timestamp2="1007118">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="285" _type="MoveCaretCommand" caretOffset="36" date="Sun Apr 17 16:38:10 EDT 2022" docOffset="36" starttimestamp="1650226882502" timestamp="1008476" />
  <Command __id="287" _type="MoveCaretCommand" caretOffset="953" date="Sun Apr 17 16:38:19 EDT 2022" docOffset="1201" starttimestamp="1650226882502" timestamp="1016987" />
  <Command __id="288" _type="ShellCommand" date="Sun Apr 17 16:38:23 EDT 2022" starttimestamp="1650226882502" timestamp="1020666" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="289" _type="ShellCommand" date="Sun Apr 17 16:38:23 EDT 2022" starttimestamp="1650226882502" timestamp="1020765" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="286" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:38:19 EDT 2022" docASTNodeCount="197" docActiveCodeLength="1233" docExpressionCount="136" docLength="1233" projectName="pa3" starttimestamp="1650226882502" timestamp="1016918">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		AST ast = parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		"), Diff(INSERT,"}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = ¶	"), Diff(EQUAL,"	System.exit(0);¶		"), Diff(DELETE,"}"), Diff(EQUAL,"¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ASTDisplay;
import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(3);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		AST ast = parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			new ASTDisplay().showTree(ast);
		}
		
		System.out.println("Starting contextual analysis...");
		Identification id = 
		System.exit(0);
		
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="290" _type="Insert" date="Sun Apr 17 16:38:23 EDT 2022" docASTNodeCount="203" docActiveCodeLength="1283" docExpressionCount="141" docLength="1283" length="50" offset="213" starttimestamp="1650226882502" timestamp="1020848">
    <text><![CDATA[import miniJava.ContextualAnalyzer.Identification;]]></text>
  </DocumentChange>
  <DocumentChange __id="291" _type="Insert" date="Sun Apr 17 16:38:23 EDT 2022" docASTNodeCount="203" docActiveCodeLength="1285" docExpressionCount="141" docLength="1285" length="2" offset="213" starttimestamp="1650226882502" timestamp="1020850">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="292" _type="MoveCaretCommand" caretOffset="972" date="Sun Apr 17 16:38:24 EDT 2022" docOffset="1272" starttimestamp="1650226882502" timestamp="1021876" />
  <DocumentChange __id="293" _type="Insert" date="Sun Apr 17 16:38:30 EDT 2022" docASTNodeCount="205" docActiveCodeLength="1286" docExpressionCount="142" docLength="1286" length="1" offset="1253" starttimestamp="1650226882502" timestamp="1028282">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="294" _type="InsertStringCommand" date="Sun Apr 17 16:38:30 EDT 2022" starttimestamp="1650226882502" timestamp="1028287" timestamp2="1028287">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="295" _type="Insert" date="Sun Apr 17 16:38:30 EDT 2022" docASTNodeCount="205" docActiveCodeLength="1287" docExpressionCount="142" docLength="1287" length="1" offset="1254" starttimestamp="1650226882502" timestamp="1028355">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="296" _type="InsertStringCommand" date="Sun Apr 17 16:38:30 EDT 2022" starttimestamp="1650226882502" timestamp="1028358" timestamp2="1028358">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="297" _type="Insert" date="Sun Apr 17 16:38:30 EDT 2022" docASTNodeCount="205" docActiveCodeLength="1288" docExpressionCount="142" docLength="1288" length="1" offset="1255" starttimestamp="1650226882502" timestamp="1028434">
    <text><![CDATA[w]]></text>
  </DocumentChange>
  <Command __id="298" _type="InsertStringCommand" date="Sun Apr 17 16:38:30 EDT 2022" starttimestamp="1650226882502" timestamp="1028438" timestamp2="1028438">
    <data><![CDATA[w]]></data>
  </Command>
  <DocumentChange __id="299" _type="Insert" date="Sun Apr 17 16:38:31 EDT 2022" docASTNodeCount="205" docActiveCodeLength="1289" docExpressionCount="142" docLength="1289" length="1" offset="1256" starttimestamp="1650226882502" timestamp="1028586">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="300" _type="InsertStringCommand" date="Sun Apr 17 16:38:31 EDT 2022" starttimestamp="1650226882502" timestamp="1028589" timestamp2="1028589">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="301" _type="Insert" date="Sun Apr 17 16:38:31 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1290" docExpressionCount="143" docLength="1290" length="1" offset="1257" starttimestamp="1650226882502" timestamp="1028974">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <Command __id="302" _type="InsertStringCommand" date="Sun Apr 17 16:38:31 EDT 2022" starttimestamp="1650226882502" timestamp="1028978" timestamp2="1028978">
    <data><![CDATA[I]]></data>
  </Command>
  <DocumentChange __id="303" _type="Insert" date="Sun Apr 17 16:38:32 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1291" docExpressionCount="143" docLength="1291" length="1" offset="1258" starttimestamp="1650226882502" timestamp="1029555">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="304" _type="InsertStringCommand" date="Sun Apr 17 16:38:32 EDT 2022" starttimestamp="1650226882502" timestamp="1029559" timestamp2="1029559">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="305" _type="Insert" date="Sun Apr 17 16:38:32 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1292" docExpressionCount="143" docLength="1292" length="1" offset="1259" starttimestamp="1650226882502" timestamp="1029735">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="306" _type="InsertStringCommand" date="Sun Apr 17 16:38:32 EDT 2022" starttimestamp="1650226882502" timestamp="1029738" timestamp2="1029738">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="307" _type="Insert" date="Sun Apr 17 16:38:32 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1293" docExpressionCount="143" docLength="1293" length="1" offset="1260" starttimestamp="1650226882502" timestamp="1029811">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="308" _type="InsertStringCommand" date="Sun Apr 17 16:38:32 EDT 2022" starttimestamp="1650226882502" timestamp="1029814" timestamp2="1029814">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="309" _type="Insert" date="Sun Apr 17 16:38:32 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1294" docExpressionCount="143" docLength="1294" length="1" offset="1261" starttimestamp="1650226882502" timestamp="1029966">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="310" _type="InsertStringCommand" date="Sun Apr 17 16:38:32 EDT 2022" starttimestamp="1650226882502" timestamp="1029976" timestamp2="1029976">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="311" _type="Insert" date="Sun Apr 17 16:38:32 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1295" docExpressionCount="143" docLength="1295" length="1" offset="1262" starttimestamp="1650226882502" timestamp="1030055">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="312" _type="InsertStringCommand" date="Sun Apr 17 16:38:32 EDT 2022" starttimestamp="1650226882502" timestamp="1030058" timestamp2="1030058">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="313" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1296" docExpressionCount="143" docLength="1296" length="1" offset="1263" starttimestamp="1650226882502" timestamp="1030579">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <Command __id="314" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1030583" timestamp2="1030583">
    <data><![CDATA[f]]></data>
  </Command>
  <DocumentChange __id="315" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1297" docExpressionCount="143" docLength="1297" length="1" offset="1264" starttimestamp="1650226882502" timestamp="1030654">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="316" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1030665" timestamp2="1030665">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="317" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1298" docExpressionCount="143" docLength="1298" length="1" offset="1265" starttimestamp="1650226882502" timestamp="1030830">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="318" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1030833" timestamp2="1030833">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="319" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1299" docExpressionCount="143" docLength="1299" length="1" offset="1266" starttimestamp="1650226882502" timestamp="1030963">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="320" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1030967" timestamp2="1030967">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="321" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1300" docExpressionCount="143" docLength="1300" length="1" offset="1267" starttimestamp="1650226882502" timestamp="1031111">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="322" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1031115" timestamp2="1031115">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="323" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1301" docExpressionCount="143" docLength="1301" length="1" offset="1268" starttimestamp="1650226882502" timestamp="1031171">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="324" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1031174" timestamp2="1031174">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="325" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1302" docExpressionCount="143" docLength="1302" length="1" offset="1269" starttimestamp="1650226882502" timestamp="1031235">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="326" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1031240" timestamp2="1031240">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="327" _type="Insert" date="Sun Apr 17 16:38:33 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1303" docExpressionCount="143" docLength="1303" length="1" offset="1270" starttimestamp="1650226882502" timestamp="1031363">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="328" _type="InsertStringCommand" date="Sun Apr 17 16:38:33 EDT 2022" starttimestamp="1650226882502" timestamp="1031366" timestamp2="1031366">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="329" _type="Insert" date="Sun Apr 17 16:38:34 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1305" docExpressionCount="143" docLength="1305" length="2" offset="1271" starttimestamp="1650226882502" timestamp="1032045">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="330" _type="InsertStringCommand" date="Sun Apr 17 16:38:34 EDT 2022" starttimestamp="1650226882502" timestamp="1032048" timestamp2="1032048">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="331" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:38:35 EDT 2022" starttimestamp="1650226882502" timestamp="1032660" />
  <DocumentChange __id="332" _type="Insert" date="Sun Apr 17 16:38:35 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1306" docExpressionCount="143" docLength="1306" length="1" offset="1273" starttimestamp="1650226882502" timestamp="1033213">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="333" _type="InsertStringCommand" date="Sun Apr 17 16:38:35 EDT 2022" starttimestamp="1650226882502" timestamp="1033218" timestamp2="1033218">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="334" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:38:37 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6403" docExpressionCount="649" docLength="7491" projectName="pa3" starttimestamp="1650226882502" timestamp="1035211">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="335" _type="MoveCaretCommand" caretOffset="36" date="Sun Apr 17 16:38:37 EDT 2022" docOffset="36" starttimestamp="1650226882502" timestamp="1035370" />
  <Command __id="336" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:38:56 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1306" docExpressionCount="143" docLength="1306" projectName="pa3" starttimestamp="1650226882502" timestamp="1053963">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶"), Diff(INSERT,"import miniJava.ContextualAnalyzer.Identification;¶"), Diff(EQUAL,"import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		AST ast = parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = "), Diff(INSERT,"new Identification();"), Diff(EQUAL,"¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ASTDisplay;
import miniJava.ContextualAnalyzer.Identification;
import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(3);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		AST ast = parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			new ASTDisplay().showTree(ast);
		}
		
		System.out.println("Starting contextual analysis...");
		Identification id = new Identification();
		System.exit(0);
		
	}
}
]]></snapshot>
  </Command>
  <Command __id="337" _type="MoveCaretCommand" caretOffset="974" date="Sun Apr 17 16:38:56 EDT 2022" docOffset="1274" starttimestamp="1650226882502" timestamp="1054016" />
  <Command __id="338" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:39:15 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1072513">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

import miniJava.SyntacticAnalyzer.Scanner;
import miniJava.SyntacticAnalyzer.TokenKind;

import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassDeclList;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.ExprList;
import miniJava.AbstractSyntaxTrees.Expression;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MemberDecl;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.Reference;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.Terminal;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeDenoter;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.AbstractSyntaxTrees.ParameterDecl;

public class Parser {
	private Scanner scanner;
	private ErrorReporter reporter;
	private Token currentToken;

	public Parser(Scanner scanner, ErrorReporter reporter) {
		this.scanner = scanner;
		this.reporter = reporter;
	}


	/**
	 *  parse input, catch possible parse error
	 */
	public AST parse() throws SyntaxError{
		currentToken = scanner.scan();
		AST ast = null;
		try {
			ast = parseProgram();
		}
		catch (SyntaxError e) { }
		return ast;
	}
	
	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{
		return kind == TokenKind.PUBLIC ||
				kind == TokenKind.PRIVATE ||
				 kind == TokenKind.STATIC ||
				  startsType(kind) ||
					 kind == TokenKind.VOID;
	}
	
	private boolean startsType(TokenKind kind) throws SyntaxError {
		return kind == TokenKind.INT ||
				   kind == TokenKind.BOOLEAN ||
					kind == TokenKind.ID;
	}

	
	public Package parseProgram() throws SyntaxError {
		ClassDeclList classList = new ClassDeclList();
		while (currentToken.kind != TokenKind.EOT) {
			FieldDeclList fieldList = new FieldDeclList();
            MethodDeclList methodList = new MethodDeclList();
            
    		accept(TokenKind.CLASS);
    		Identifier classId = parseId();
    		accept(TokenKind.LCURLY);
    		
//    		System.out.print(currentToken.kind);
    		while (startsDeclaration(currentToken.kind)) {
//    			System.out.println("------------starting declaration-----------");
    			// parse accessibility
    			boolean isPublic = true;
    			if (currentToken.kind == TokenKind.PRIVATE) {
    				acceptIt();
    				isPublic = false;
    			} else if (currentToken.kind == TokenKind.PUBLIC) {
    				acceptIt();
    			}
    			
    			// parse access
    			boolean isStatic = false;
    			if (currentToken.kind == TokenKind.STATIC) {
    				acceptIt();
    				isStatic = true;
    			}
    			
    			switch(currentToken.kind) {
    				// Method Declaration
    				case VOID:
    					TypeDenoter type = new BaseType(TypeKind.VOID, null);
    					acceptIt();
    					Identifier methodId = parseId();
    					accept(TokenKind.LPAREN);
    					ParameterDeclList paramList = new ParameterDeclList();
    					if (startsType(currentToken.kind)) {
    						paramList = parseParameterList();
    					}
    					accept(TokenKind.RPAREN);
    					accept(TokenKind.LCURLY);
    					
    					StatementList stateList = new StatementList();
    					while (startsStatement(currentToken.kind)) {
//    						System.out.println("IN VOID METHOD DECLARATION");
    						stateList.add(parseStatement());
//    						System.out.println("OUT VOID METHOD DECLARATION");
    					}
    					accept(TokenKind.RCURLY);
    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));
    					break;
    					
    				// both possible
    				default:
    					if (startsType(currentToken.kind)) {
    						TypeDenoter type2 = parseType();
    						Identifier id = parseId();
    						switch(currentToken.kind) {
    							// Field Declaration
    							case SEMICOLON:
    								acceptIt();
    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));
    								break;
    							
    							// Method Declaration
    							case LPAREN:
    								acceptIt();
    								ParameterDeclList paramList2 = new ParameterDeclList();
    								if (startsType(currentToken.kind)) {
    									paramList2 = parseParameterList();
    								}
    								accept(TokenKind.RPAREN);
    								accept(TokenKind.LCURLY);
    								
    								StatementList stateList2 = new StatementList();
    								while (startsStatement(currentToken.kind)) {
//    									System.out.println("IN METHOD DECLARATION");
    									stateList2.add(parseStatement());
//    									System.out.println("OUT METHOD DECLARATION");
    								}
    								accept(TokenKind.RCURLY);
    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));
    								break;
    						}
    					}
    					else {
    						parseError("Parsing wrong in declarations, no types declared.");
    					}
    					break;
    					
    			}
//    			System.out.println("------------ending declaration-----------");
    		}
//    		System.out.println("out here end of program: " + currentToken.spelling);

    		accept(TokenKind.RCURLY);
    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));
            
		}
		

		accept(TokenKind.EOT);
		return new Package(classList,null);
	}
	
//	  public Statement(SourcePosition posn) {
//    public StatementList() {
//    public BlockStmt(StatementList sl, SourcePosition posn){
	private Statement parseStatement() throws SyntaxError {
		Statement stmt = null;
		switch (currentToken.kind) {
			// {statements*}
			case LCURLY:
				acceptIt();
				StatementList sl = new StatementList();
				while (startsStatement(currentToken.kind)) {
					sl.add(parseStatement());
				}
	//			System.out.println("in here: " + currentToken);
				accept(TokenKind.RCURLY);
				stmt = new BlockStmt(sl, null);
				break;
				
				
//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {
//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){
			// Type id = Expression;
			case INT: case BOOLEAN:
				String name = currentToken.spelling;
				TypeDenoter td = parseType();
				Identifier id = parseId();
				accept(TokenKind.EQUAL);
				Expression e = parseExpression();
				accept(TokenKind.SEMICOLON);
				
				VarDecl vd = new VarDecl(td, name, null);
				stmt = new VarDeclStmt(vd, e, null);
				break;
			
			case ID:			
//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");
				Identifier id2 = parseId();
//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");
				switch (currentToken.kind) {
					// starts with Type
					// Type id = Expression
					case ID:
						TypeDenoter td2 = new ClassType(id2, null);
						Identifier id3 = parseId();
						accept(TokenKind.EQUAL);
						Expression e2 = parseExpression();
						accept(TokenKind.SEMICOLON);
						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);
						stmt = new VarDeclStmt(vd2, e2, null);
						break;
					
					// starts with Reference
					// Reference = Expression
					case EQUAL:
						Reference r = new IdRef(id2, null);
//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");
						acceptIt();
//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");
						Expression e3 = parseExpression();
//						System.out.println("inhere 4");
						accept(TokenKind.SEMICOLON);
						
						stmt = new AssignStmt(r, e3, null);
						break;
					
					// Reference (arglist?)
					case LPAREN:
						Reference r2 = new IdRef(id2, null);
						ExprList al = new ExprList();
						acceptIt();
						if (currentToken.kind == TokenKind.RPAREN) {
							acceptIt();
						} else {
							al = parseArgumentList();
							accept(TokenKind.RPAREN);
						}
						accept(TokenKind.SEMICOLON);
						stmt = new CallStmt(r2, al, null);
						break;
					
					// both
					case LBRACKET: 
						acceptIt();
						
						if (currentToken.kind == TokenKind.RBRACKET) {
							// in Type
							// Type id = Expression;
							// Type := id[]
							acceptIt();							
							ArrayType at = new ArrayType(new ClassType(id2, null), null);
							Identifier id4 = parseId();
							accept(TokenKind.EQUAL);
							Expression e4 =parseExpression();
							accept(TokenKind.SEMICOLON);
							VarDecl vd3 = new VarDecl(at, id4.spelling, null);
							stmt = new VarDeclStmt(vd3, e4, null);
						} else {
							// in Reference
							Reference r3 = new IdRef(id2, null);
							Expression e5 = parseExpression();
							accept(TokenKind.RBRACKET);
							accept(TokenKind.EQUAL);
							Expression e6 = parseExpression();
							accept(TokenKind.SEMICOLON);
							stmt = new IxAssignStmt(r3, e5, e6, null);
						}
						break;
					
					case DOT:
						// in Reference
						Reference r4 = new IdRef(id2,null);
						while (currentToken.kind == TokenKind.DOT) {
							acceptIt();
							Identifier id4 = parseId();
							r4 = new QualRef(r4, id4, null);
						}
						switch (currentToken.kind) {
							// Reference = Expression;
							case EQUAL:
								acceptIt();
								Expression e4 = parseExpression();
								accept(TokenKind.SEMICOLON);
								stmt = new AssignStmt(r4,e4,null);
								break;
							
							// Reference[Expression] = Expression;
							case LBRACKET: 
								acceptIt();
								Expression e5 = parseExpression();
								accept(TokenKind.RBRACKET);
								accept(TokenKind.EQUAL);
								Expression e6 = parseExpression();
								accept(TokenKind.SEMICOLON);
								stmt = new IxAssignStmt(r4, e5, e6, null);
								break;
							
							// Reference(arglist?);
							case LPAREN:
								acceptIt();
								ExprList el2 = new ExprList();
								if (currentToken.kind == TokenKind.RPAREN) {
									acceptIt();
								} else {
									el2 = parseArgumentList();
									accept(TokenKind.RPAREN);
								}
								accept(TokenKind.SEMICOLON);
								stmt = new CallStmt(r4, el2, null);
								break;
							
							default:
								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);
						}
						break;
					default:
						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);
						break;
				}
				break;
			
			
			// in Reference
			case THIS:
				Reference rInThis = new ThisRef(null);
				acceptIt();
				while (currentToken.kind == TokenKind.DOT) {
					acceptIt();
					Identifier idAfterThis = parseId();
					rInThis = new QualRef(rInThis, idAfterThis, null);
				}
				switch (currentToken.kind) {
				// Reference = Expression;
				case EQUAL:
					acceptIt();
//					System.out.println("before");
					Expression e5 =parseExpression();
//					System.out.println("after");
					accept(TokenKind.SEMICOLON);
					stmt = new AssignStmt(rInThis, e5, null);
					break;
				
				// Reference[Expression] = Expression;
				case LBRACKET:
					acceptIt();
					Expression e6 = parseExpression();
					accept(TokenKind.RBRACKET);
					accept(TokenKind.EQUAL);
					Expression e7 = parseExpression();
					accept(TokenKind.SEMICOLON);
					stmt = new IxAssignStmt(rInThis, e6, e7, null);
					break;
					
				// Reference(arglist?);
				case LPAREN:
					acceptIt();
					ExprList el = new ExprList();
					if (currentToken.kind == TokenKind.RPAREN) {
						acceptIt();
						accept(TokenKind.SEMICOLON);
					} else {
						el = parseArgumentList();
						accept(TokenKind.RPAREN);
						accept(TokenKind.SEMICOLON);
					}
					stmt = new CallStmt(rInThis, el, null);
					break;
				
				default:
					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);
				}
				break;
				
			// in reference
			case RETURN:
				acceptIt();
				Expression e2 = null;
				if (currentToken.kind == TokenKind.SEMICOLON) {
					acceptIt();
				} else {
					e2 = parseExpression();
					accept(TokenKind.SEMICOLON);
				}
				stmt = new ReturnStmt(e2, null);
				break;
			
			case IF:
				acceptIt();
				accept(TokenKind.LPAREN);
				Expression ifE = parseExpression();
				accept(TokenKind.RPAREN);
				Statement ifS = parseStatement();
				if (currentToken.kind == TokenKind.ELSE) {
					acceptIt();
					Statement elseS = parseStatement();
					stmt = new IfStmt(ifE, ifS, elseS, null);
				} else {
					stmt = new IfStmt(ifE,ifS,null);
				}
				break;
				
			case WHILE:
				acceptIt();
				accept(TokenKind.LPAREN);
				Expression whileE = parseExpression();
				accept(TokenKind.RPAREN);
				Statement whileS = parseStatement();
				stmt = new WhileStmt(whileE, whileS, null);
				break;
			
			default:
				parseError("parsing statement, current token is:" + currentToken);
				break;
		}
		return stmt;
		
	}


	private ExprList parseArgumentList() throws SyntaxError {
		// TODO Auto-generated method stub
		ExprList el = new ExprList();
		Expression e = parseExpression();
		el.add(e);
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			e = parseExpression();
			el.add(e);
		}
		return el;
	}

//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){
//	  public Operator (Token t) {
	private Expression parseExpression() throws SyntaxError {
		Expression e1 = parseExpressionA();
//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);

		while (currentToken.kind == TokenKind.OR) {
			Operator o = new Operator(currentToken);
			acceptIt();
			Expression e2 = parseExpressionA();
			e1 = new BinaryExpr(o,e1,e2,null);
		}
		return e1;
	}
	
	private Expression parseExpressionA() throws SyntaxError {
//		System.out.println("into A");
		Expression e1 = parseExpressionB();
		while (currentToken.kind == TokenKind.AND) {
			Operator o = new Operator(currentToken);
			acceptIt();
			Expression e2 = parseExpressionB();
			e1 = new BinaryExpr(o,e1,e2,null);
		}
//		System.out.println("out A");
		return e1;
	}

	
	private Expression parseExpressionB() throws SyntaxError {
//		System.out.println("into B");
		Expression e1 = parseExpressionC();
		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {
			Operator o = new Operator(currentToken);
			acceptIt();
			Expression e2 = parseExpressionC();
			e1 = new BinaryExpr(o,e1,e2,null);
		}
//		System.out.println("out B");
		return e1;
	}


	private Expression parseExpressionC() throws SyntaxError {
//		System.out.println("into C");
		Expression e1 = parseExpressionD();
		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||
				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {
			Operator o = new Operator(currentToken);
			acceptIt();
			Expression e2 = parseExpressionD();
			e1 = new BinaryExpr(o,e1,e2,null);
		}
//		System.out.println("out C");
		return e1;
	}


	private Expression parseExpressionD() throws SyntaxError {
//		System.out.println("into D");
		Expression e1 = parseExpressionE();
		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {
			Operator o = new Operator(currentToken);
			acceptIt();
			Expression e2 = parseExpressionE();
			e1 = new BinaryExpr(o,e1,e2,null);
		}
//		System.out.println("out D");
		return e1;
	}


	private Expression parseExpressionE() throws SyntaxError {
//		System.out.println("into E");
		Expression e1 = parseExpressionF();
		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {
			Operator o = new Operator(currentToken);
			acceptIt();
			Expression e2 = parseExpressionF();
			e1 = new BinaryExpr(o,e1,e2,null);
		}
//		System.out.println("out E");
		return e1;
	}

//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){
	private Expression parseExpressionF() throws SyntaxError {
//		System.out.println("into F");
		Stack<Operator> s = new Stack<>();
		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {
			Operator o = new Operator(currentToken);
			s.add(o);
			acceptIt();
		}
		Expression e = parseExpressionG();
		while(!s.isEmpty()) {
			e = new UnaryExpr(s.pop(),e, null);
		}
//		System.out.println("out F");
		return e;
	}


	private Expression parseExpressionG() throws SyntaxError {
//		System.out.println("into G");
//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);
		Expression e = null;
		switch (currentToken.kind) {
		case LPAREN:
			acceptIt();
			e = parseExpression();
			accept(TokenKind.RPAREN);
			break;
		
		
		case NUM:
//			  public IntLiteral(Token t) {
			IntLiteral il = new IntLiteral(currentToken);
			acceptIt();
			
//		    public LiteralExpr(Terminal t, SourcePosition posn){
			e = new LiteralExpr(il, null);
			break;
			
		case TRUE: case FALSE:
			BooleanLiteral bl = new BooleanLiteral(currentToken);
			acceptIt();
			e = new LiteralExpr(bl, null);
			break;
		
		case NEW:
			acceptIt();
			switch (currentToken.kind) {
				case ID:
//					  public Identifier (Token t) {
					Identifier id = new Identifier(currentToken);
					acceptIt();
					switch (currentToken.kind) {
					case LPAREN:
						acceptIt();
						accept(TokenKind.RPAREN);
						
//					    public NewObjectExpr(ClassType ct, SourcePosition posn){
//					    public ClassType(Identifier cn, SourcePosition posn){
						e =  new NewObjectExpr(new ClassType(id, null), null);
						break;
						
					case LBRACKET:
						acceptIt();
						e = parseExpression();
						accept(TokenKind.RBRACKET);
						
//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){
//					    public TypeDenoter(TypeKind type, SourcePosition posn){
//						public class ClassType extends TypeDenoter
//						public ClassType(Identifier cn, SourcePosition posn){
						e = new NewArrayExpr(new ClassType(id,null), e, null);
						break;
						
					default:
						parseError("parsing expression, nothing after new.");
					
					}
					break;
					
				case INT:
					acceptIt();
					accept(TokenKind.LBRACKET);
					e = parseExpression();
					accept(TokenKind.RBRACKET);
					
//				    public BaseType(TypeKind t, SourcePosition posn){
					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);
					break;
				
				default:
					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);
			}
			break;
			
			
		// starts with reference
		case ID: case THIS:
			Reference r = parseReference();

			switch (currentToken.kind) {
			// reference[expression]
			case LBRACKET:
				acceptIt();
				e = parseExpression();
				
				accept(TokenKind.RBRACKET);
				
				//	public IxExpr(Reference r, Expression e, SourcePosition posn){
				e = new IxExpr(r, e, null);
				
				break;
			
			// reference(arglist?)
			case LPAREN:
				acceptIt();
				ExprList arglist = new ExprList();
				if (currentToken.kind == TokenKind.RPAREN) {
					acceptIt();
				} else {
					arglist = parseArgumentList();
					accept(TokenKind.RPAREN);
				}
				
//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){
				e = new CallExpr(r,arglist, null);
				break;
					
			default:
//			    public RefExpr(Reference r, SourcePosition posn){
//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);
				e = new RefExpr(r, null);
				break;
			}
			break;			
		
		default:
			parseError("parsing expressionG");
			
		}
		return e;
	}

//	public ThisRef(SourcePosition posn) {
//	public IdRef(Identifier id, SourcePosition posn){
//	public QualRef(Reference ref, Identifier id, SourcePosition posn){
//	 public Identifier (Token t) {
	private Reference parseReference() throws SyntaxError {
		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {
			Reference ref = null;
			if(currentToken.kind == TokenKind.ID) {
				ref = new IdRef(new Identifier(currentToken), null);
			} else {
				ref = new ThisRef(null);
			}
			acceptIt();
			
			// dealing with (.id)*
			while (currentToken.kind == TokenKind.DOT) {
				acceptIt();
				if (currentToken.kind == TokenKind.ID) {
					ref = new QualRef(ref, new Identifier(currentToken), null);
					acceptIt();
				} else {
					parseError("no identifier after reference and dot");
				}
			}
			return ref;
			
		} else {
			parseError("parsing reference");
			return null;
		}
	}


//	private void parseExpression() {
//		// TODO Auto-generated method stub
//		switch (currentToken.kind) {
//			// starts with reference
//			case ID: case THIS:
//				acceptIt();
//				// dealing with (.id)*
//				while (currentToken.kind == TokenKind.DOT) {
//					acceptIt();
//					accept(TokenKind.ID);
//				}
//				switch (currentToken.kind) {
//					// reference[expression]
//					case LBRACKET:
//						acceptIt();
//						parseExpression();
//						accept(TokenKind.RBRACKET);
//						break;
//					
//					// reference(arglist?)
//					case LPAREN:
//						acceptIt();
//						if (currentToken.kind == TokenKind.RPAREN) {
//							acceptIt();
//						} else {
//							parseArgumentList();
//							accept(TokenKind.RPAREN);
//						}
//						break;
//						
//					// just reference
//					default:
//						break;
////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);
//				}
//				break;
//				
//			case UNOP: case MINUS:
//				acceptIt();
//				parseExpression();
//				break;
//			
//			case LPAREN:
//				acceptIt();
//				parseExpression();
//				accept(TokenKind.RPAREN);
//				break;
//			
//			case NUM: case TRUE: case FALSE:
//				acceptIt();
//				break;
//			
//			case NEW:
//				acceptIt();
////				System.out.println("in hereeee");
//				switch (currentToken.kind) {
//					case ID:
//						acceptIt();
//						switch (currentToken.kind) {
//						case LPAREN:
//							acceptIt();
//							accept(TokenKind.RPAREN);
//							break;
//						case LBRACKET:
//							acceptIt();
//							parseExpression();
//							accept(TokenKind.RBRACKET);
//							break;
//						default:
//							parseError("parsing expression, nothing after new.");
//						
//						}
//						break;
//					
//					case INT:
//						acceptIt();
//						accept(TokenKind.LBRACKET);
//						parseExpression();
//						accept(TokenKind.RBRACKET);
//						break;
//					
//					default:
//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);
//				}
//				break;
//			
//			default:
//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);
//				break;
//		}
//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS 
//				|| currentToken.kind == TokenKind.EQUAL) {
//			acceptIt();
//			parseExpression();
//		}
//	}


	private boolean startsStatement(TokenKind kind) throws SyntaxError {
		return kind == TokenKind.LCURLY ||
				startsType(kind) ||
				 startsReference(kind) ||
				  kind == TokenKind.RETURN ||
				   kind == TokenKind.IF ||
					kind == TokenKind.WHILE;
	}


	private boolean startsReference(TokenKind kind) throws SyntaxError {
		return kind == TokenKind.ID ||
				kind == TokenKind.THIS;
	}


	private ParameterDeclList parseParameterList() throws SyntaxError {
		ParameterDeclList paramList = new ParameterDeclList();
		TypeDenoter td = parseType();
		Identifier id = parseId();
		paramList.add(new ParameterDecl(td, id.spelling, null));
		while (currentToken.kind == TokenKind.COMMA) {
			acceptIt();
			td = parseType();
			id = parseId();
			paramList.add(new ParameterDecl(td, id.spelling, null));
		}
		return paramList;
	}


	private TypeDenoter parseType() throws SyntaxError{
		TypeDenoter td = null;
		switch (currentToken.kind) {
		case INT:
//		    public BaseType(TypeKind t, SourcePosition posn){
			td = new BaseType(TypeKind.INT, null);
			acceptIt();
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
				
//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){
				td = new ArrayType(td, null);
			}
			break;
		case BOOLEAN:
			td = new BaseType(TypeKind.BOOLEAN, null);
			acceptIt();
			break;
		case ID:
			Identifier id = parseId();
			
//		    public ClassType(Identifier cn, SourcePosition posn){
			td = new ClassType(id, null);
			if (currentToken.kind == TokenKind.LBRACKET) {
				acceptIt();
				accept(TokenKind.RBRACKET);
				td = new ArrayType(td, null);
			}
			break;
		default:
			parseError("Wrong in parsing Type, currentToken is: " + currentToken);
		}
		return td;
	}


	private Identifier parseId() throws SyntaxError {
		Identifier id = null;
		if(currentToken.kind == TokenKind.ID) {
			id = new Identifier(currentToken);
			acceptIt();
		} else {
			parseError("is not an identifier");
		}
		return id;
	}


	private void parseClassDeclaration() throws SyntaxError {
		while (currentToken.kind == TokenKind.CLASS) {
			parseClassDeclaration();
		}
		accept(TokenKind.EOT);
	}

	/**
	 * accept current token and advance to next token
	 */
	private void acceptIt() throws SyntaxError {
		accept(currentToken.kind);
	}

	/**
	 * verify that current token in input matches expected token and advance to next token
	 * @param expectedToken
	 * @throws SyntaxError  if match fails
	 */
	private void accept(TokenKind expectedTokenKind) throws SyntaxError {
		if (currentToken.kind == expectedTokenKind) {
//			System.out.println(currentToken.spelling);
			currentToken = scanner.scan();
		}
		else
			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +
					"' but found '" + currentToken.kind + "'");
	}

	/**
	 * report parse error and unwind call stack to start of parse
	 * @param e  string with error detail
	 * @throws SyntaxError
	 */
	private void parseError(String e) throws SyntaxError {
		reporter.reportError("Parse error: " + e);
		throw new SyntaxError();
	}

	// show parse stack whenever terminal is  accepted
	private void pTrace() {
		StackTraceElement [] stl = Thread.currentThread().getStackTrace();
		for (int i = stl.length - 1; i > 0 ; i--) {
			if(stl[i].toString().contains("parse"))
				System.out.println(stl[i]);
		}
		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");
		System.out.println();
	}

}
]]></snapshot>
  </Command>
  <Command __id="339" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 16:39:15 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="1072689" />
  <Command __id="340" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:39:19 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6403" docExpressionCount="649" docLength="7491" projectName="pa3" starttimestamp="1650226882502" timestamp="1076843">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="341" _type="MoveCaretCommand" caretOffset="36" date="Sun Apr 17 16:39:19 EDT 2022" docOffset="36" starttimestamp="1650226882502" timestamp="1076935" />
  <Command __id="342" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:39:19 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1306" docExpressionCount="143" docLength="1306" projectName="pa3" starttimestamp="1650226882502" timestamp="1077284">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		AST ast = parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification();¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="343" _type="MoveCaretCommand" caretOffset="974" date="Sun Apr 17 16:39:19 EDT 2022" docOffset="1274" starttimestamp="1650226882502" timestamp="1077331" />
  <Command __id="344" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:39:25 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="1083033">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

public class Package extends AST {

	public Package(ClassDeclList cdl, SourcePosition posn) {
		super(posn);
		classDeclList = cdl;
	}

	public <A,R> R visit(Visitor<A,R> v, A o) {
		return v.visitPackage(this, o);
	}

	public ClassDeclList classDeclList;
}
]]></snapshot>
  </Command>
  <Command __id="345" _type="SelectTextCommand" caretOffset="156" date="Sun Apr 17 16:39:25 EDT 2022" end="156" start="149" starttimestamp="1650226882502" timestamp="1083195" />
  <Command __id="346" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:39:30 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1306" docExpressionCount="143" docLength="1306" projectName="pa3" starttimestamp="1650226882502" timestamp="1088297">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		AST ast = parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification();¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="347" _type="MoveCaretCommand" caretOffset="974" date="Sun Apr 17 16:39:30 EDT 2022" docOffset="1274" starttimestamp="1650226882502" timestamp="1088352" />
  <Command __id="348" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:39:45 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="1103276">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="349" _type="SelectTextCommand" caretOffset="156" date="Sun Apr 17 16:39:45 EDT 2022" end="156" start="149" starttimestamp="1650226882502" timestamp="1103341" />
  <Command __id="351" _type="MoveCaretCommand" caretOffset="974" date="Sun Apr 17 16:39:47 EDT 2022" docOffset="1274" starttimestamp="1650226882502" timestamp="1105290" />
  <Command __id="352" _type="MoveCaretCommand" caretOffset="972" date="Sun Apr 17 16:39:49 EDT 2022" docOffset="1272" starttimestamp="1650226882502" timestamp="1106788" />
  <Command __id="353" _type="InsertStringCommand" date="Sun Apr 17 16:39:49 EDT 2022" starttimestamp="1650226882502" timestamp="1107482" timestamp2="1107482">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="354" _type="InsertStringCommand" date="Sun Apr 17 16:39:50 EDT 2022" starttimestamp="1650226882502" timestamp="1107596" timestamp2="1107596">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="355" _type="InsertStringCommand" date="Sun Apr 17 16:39:50 EDT 2022" starttimestamp="1650226882502" timestamp="1107820" timestamp2="1107820">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="356" _type="InsertStringCommand" date="Sun Apr 17 16:39:51 EDT 2022" starttimestamp="1650226882502" timestamp="1108573" timestamp2="1108573">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="357" _type="InsertStringCommand" date="Sun Apr 17 16:39:51 EDT 2022" starttimestamp="1650226882502" timestamp="1108684" timestamp2="1108684">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="358" _type="InsertStringCommand" date="Sun Apr 17 16:39:54 EDT 2022" starttimestamp="1650226882502" timestamp="1112212" timestamp2="1112212">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="359" _type="InsertStringCommand" date="Sun Apr 17 16:39:54 EDT 2022" starttimestamp="1650226882502" timestamp="1112284" timestamp2="1112284">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="360" _type="InsertStringCommand" date="Sun Apr 17 16:39:55 EDT 2022" starttimestamp="1650226882502" timestamp="1112863" timestamp2="1112863">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="361" _type="InsertStringCommand" date="Sun Apr 17 16:39:55 EDT 2022" starttimestamp="1650226882502" timestamp="1113012" timestamp2="1113012">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="362" _type="InsertStringCommand" date="Sun Apr 17 16:39:55 EDT 2022" starttimestamp="1650226882502" timestamp="1113220" timestamp2="1113220">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="363" _type="InsertStringCommand" date="Sun Apr 17 16:39:56 EDT 2022" starttimestamp="1650226882502" timestamp="1113610" timestamp2="1113610">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="364" _type="InsertStringCommand" date="Sun Apr 17 16:39:56 EDT 2022" starttimestamp="1650226882502" timestamp="1114032" timestamp2="1114032">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="365" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:56 EDT 2022" starttimestamp="1650226882502" timestamp="1114487" />
  <Command __id="366" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:57 EDT 2022" starttimestamp="1650226882502" timestamp="1114647" />
  <Command __id="367" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:57 EDT 2022" starttimestamp="1650226882502" timestamp="1114795" />
  <Command __id="368" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:57 EDT 2022" starttimestamp="1650226882502" timestamp="1114943" />
  <Command __id="369" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:57 EDT 2022" starttimestamp="1650226882502" timestamp="1115088" />
  <Command __id="370" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:57 EDT 2022" starttimestamp="1650226882502" timestamp="1115251" />
  <Command __id="371" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:57 EDT 2022" starttimestamp="1650226882502" timestamp="1115427" />
  <Command __id="372" _type="InsertStringCommand" date="Sun Apr 17 16:39:58 EDT 2022" starttimestamp="1650226882502" timestamp="1115531" timestamp2="1115531">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="373" _type="InsertStringCommand" date="Sun Apr 17 16:39:58 EDT 2022" starttimestamp="1650226882502" timestamp="1115664" timestamp2="1115664">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="374" _type="InsertStringCommand" date="Sun Apr 17 16:39:58 EDT 2022" starttimestamp="1650226882502" timestamp="1115820" timestamp2="1115820">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="375" _type="InsertStringCommand" date="Sun Apr 17 16:39:58 EDT 2022" starttimestamp="1650226882502" timestamp="1116096" timestamp2="1116096">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="376" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:39:58 EDT 2022" starttimestamp="1650226882502" timestamp="1116358" />
  <Command __id="377" _type="InsertStringCommand" date="Sun Apr 17 16:39:59 EDT 2022" starttimestamp="1650226882502" timestamp="1116516" timestamp2="1116516">
    <data><![CDATA[R]]></data>
  </Command>
  <Command __id="378" _type="InsertStringCommand" date="Sun Apr 17 16:39:59 EDT 2022" starttimestamp="1650226882502" timestamp="1116784" timestamp2="1116784">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="379" _type="InsertStringCommand" date="Sun Apr 17 16:39:59 EDT 2022" starttimestamp="1650226882502" timestamp="1117144" timestamp2="1117144">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="380" _type="InsertStringCommand" date="Sun Apr 17 16:40:00 EDT 2022" starttimestamp="1650226882502" timestamp="1117548" timestamp2="1117548">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="381" _type="InsertStringCommand" date="Sun Apr 17 16:40:00 EDT 2022" starttimestamp="1650226882502" timestamp="1117704" timestamp2="1117704">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="382" _type="InsertStringCommand" date="Sun Apr 17 16:40:00 EDT 2022" starttimestamp="1650226882502" timestamp="1117867" timestamp2="1117867">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="383" _type="InsertStringCommand" date="Sun Apr 17 16:40:00 EDT 2022" starttimestamp="1650226882502" timestamp="1118024" timestamp2="1118024">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="384" _type="InsertStringCommand" date="Sun Apr 17 16:40:00 EDT 2022" starttimestamp="1650226882502" timestamp="1118440" timestamp2="1118440">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="385" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:40:01 EDT 2022" starttimestamp="1650226882502" timestamp="1119275" />
  <Command __id="386" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:40:02 EDT 2022" starttimestamp="1650226882502" timestamp="1119527" />
  <Command __id="387" _type="ShellCommand" date="Sun Apr 17 16:40:09 EDT 2022" starttimestamp="1650226882502" timestamp="1126516" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="388" _type="ShellCommand" date="Sun Apr 17 16:40:09 EDT 2022" starttimestamp="1650226882502" timestamp="1126606" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="389" _type="ShellCommand" date="Sun Apr 17 16:40:37 EDT 2022" starttimestamp="1650226882502" timestamp="1155102" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="390" _type="ShellCommand" date="Sun Apr 17 16:40:37 EDT 2022" starttimestamp="1650226882502" timestamp="1155292" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="391" _type="MoveCaretCommand" caretOffset="989" date="Sun Apr 17 16:40:38 EDT 2022" docOffset="1289" starttimestamp="1650226882502" timestamp="1156451" />
  <Command __id="392" _type="ShellCommand" date="Sun Apr 17 16:40:45 EDT 2022" starttimestamp="1650226882502" timestamp="1163198" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="393" _type="ShellCommand" date="Sun Apr 17 16:40:45 EDT 2022" starttimestamp="1650226882502" timestamp="1163317" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="394" _type="MoveCaretCommand" caretOffset="766" date="Sun Apr 17 16:40:46 EDT 2022" docOffset="1066" starttimestamp="1650226882502" timestamp="1164059" />
  <Command __id="395" _type="MoveCaretCommand" caretOffset="973" date="Sun Apr 17 16:40:47 EDT 2022" docOffset="1273" starttimestamp="1650226882502" timestamp="1165315" />
  <Command __id="396" _type="MoveCaretCommand" caretOffset="972" date="Sun Apr 17 16:40:48 EDT 2022" docOffset="1272" starttimestamp="1650226882502" timestamp="1165740" />
  <Command __id="397" _type="InsertStringCommand" date="Sun Apr 17 16:40:49 EDT 2022" starttimestamp="1650226882502" timestamp="1166570" timestamp2="1166570">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="398" _type="InsertStringCommand" date="Sun Apr 17 16:40:49 EDT 2022" starttimestamp="1650226882502" timestamp="1166597" timestamp2="1166597">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="399" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:40:49 EDT 2022" starttimestamp="1650226882502" timestamp="1167323" />
  <Command __id="400" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:40:49 EDT 2022" starttimestamp="1650226882502" timestamp="1167491" />
  <Command __id="401" _type="InsertStringCommand" date="Sun Apr 17 16:40:50 EDT 2022" starttimestamp="1650226882502" timestamp="1168182" timestamp2="1168182">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="402" _type="InsertStringCommand" date="Sun Apr 17 16:40:50 EDT 2022" starttimestamp="1650226882502" timestamp="1168231" timestamp2="1168231">
    <data><![CDATA[)]]></data>
  </Command>
  <Command __id="403" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_PREVIOUS" date="Sun Apr 17 16:40:51 EDT 2022" starttimestamp="1650226882502" timestamp="1168715" />
  <Command __id="404" _type="InsertStringCommand" date="Sun Apr 17 16:40:51 EDT 2022" starttimestamp="1650226882502" timestamp="1169321" timestamp2="1169321">
    <data><![CDATA[P]]></data>
  </Command>
  <Command __id="405" _type="InsertStringCommand" date="Sun Apr 17 16:40:52 EDT 2022" starttimestamp="1650226882502" timestamp="1169661" timestamp2="1169661">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="406" _type="InsertStringCommand" date="Sun Apr 17 16:40:52 EDT 2022" starttimestamp="1650226882502" timestamp="1169864" timestamp2="1169864">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="407" _type="InsertStringCommand" date="Sun Apr 17 16:40:52 EDT 2022" starttimestamp="1650226882502" timestamp="1170169" timestamp2="1170169">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="408" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:40:53 EDT 2022" starttimestamp="1650226882502" timestamp="1170542" />
  <Command __id="409" _type="InsertStringCommand" date="Sun Apr 17 16:40:53 EDT 2022" starttimestamp="1650226882502" timestamp="1170769" timestamp2="1170769">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="410" _type="InsertStringCommand" date="Sun Apr 17 16:40:53 EDT 2022" starttimestamp="1650226882502" timestamp="1170829" timestamp2="1170829">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="411" _type="InsertStringCommand" date="Sun Apr 17 16:40:53 EDT 2022" starttimestamp="1650226882502" timestamp="1171010" timestamp2="1171010">
    <data><![CDATA[g]]></data>
  </Command>
  <Command __id="412" _type="InsertStringCommand" date="Sun Apr 17 16:40:53 EDT 2022" starttimestamp="1650226882502" timestamp="1171086" timestamp2="1171086">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="350" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:39:47 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1306" docExpressionCount="143" docLength="1306" projectName="pa3" starttimestamp="1650226882502" timestamp="1105165">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		AST ast = parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification();¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="413" _type="MoveCaretCommand" caretOffset="981" date="Sun Apr 17 16:40:55 EDT 2022" docOffset="1281" starttimestamp="1650226882502" timestamp="1172708" />
  <Command __id="414" _type="InsertStringCommand" date="Sun Apr 17 16:40:55 EDT 2022" starttimestamp="1650226882502" timestamp="1172855" timestamp2="1172855">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="415" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:41:04 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1182275">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="416" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 16:41:04 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="1182337" />
  <Command __id="417" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:41:15 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="1192554">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="418" _type="SelectTextCommand" caretOffset="156" date="Sun Apr 17 16:41:15 EDT 2022" end="156" start="149" starttimestamp="1650226882502" timestamp="1192826" />
  <Command __id="419" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:41:27 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="1205138">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="420" _type="SelectTextCommand" caretOffset="199" date="Sun Apr 17 16:41:27 EDT 2022" end="199" start="171" starttimestamp="1650226882502" timestamp="1205218" />
  <Command __id="422" _type="MoveCaretCommand" caretOffset="982" date="Sun Apr 17 16:41:28 EDT 2022" docOffset="1282" starttimestamp="1650226882502" timestamp="1206061" />
  <Command __id="423" _type="MoveCaretCommand" caretOffset="776" date="Sun Apr 17 16:41:29 EDT 2022" docOffset="1076" starttimestamp="1650226882502" timestamp="1206859" />
  <Command __id="424" _type="MoveCaretCommand" caretOffset="776" date="Sun Apr 17 16:41:29 EDT 2022" docOffset="1076" starttimestamp="1650226882502" timestamp="1206859" />
  <Command __id="425" _type="MoveCaretCommand" caretOffset="1025" date="Sun Apr 17 16:41:29 EDT 2022" docOffset="1325" starttimestamp="1650226882502" timestamp="1207203" />
  <Command __id="426" _type="MoveCaretCommand" caretOffset="1025" date="Sun Apr 17 16:41:29 EDT 2022" docOffset="1325" starttimestamp="1650226882502" timestamp="1207203" />
  <Command __id="427" _type="SelectTextCommand" caretOffset="973" date="Sun Apr 17 16:41:40 EDT 2022" end="982" start="973" starttimestamp="1650226882502" timestamp="1217651" />
  <Command __id="428" _type="SelectTextCommand" caretOffset="973" date="Sun Apr 17 16:41:40 EDT 2022" end="982" start="973" starttimestamp="1650226882502" timestamp="1217651" />
  <Command __id="430" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:41:40 EDT 2022" starttimestamp="1650226882502" timestamp="1218408" />
  <Command __id="431" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:41:40 EDT 2022" starttimestamp="1650226882502" timestamp="1218408" />
  <Command __id="433" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:41:41 EDT 2022" starttimestamp="1650226882502" timestamp="1218599" />
  <Command __id="434" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:41:41 EDT 2022" starttimestamp="1650226882502" timestamp="1218599" />
  <Command __id="435" _type="MoveCaretCommand" caretOffset="1011" date="Sun Apr 17 16:41:42 EDT 2022" docOffset="1311" starttimestamp="1650226882502" timestamp="1220196" />
  <Command __id="436" _type="MoveCaretCommand" caretOffset="1011" date="Sun Apr 17 16:41:42 EDT 2022" docOffset="1311" starttimestamp="1650226882502" timestamp="1220196" />
  <Command __id="437" _type="ShellCommand" date="Sun Apr 17 16:41:47 EDT 2022" starttimestamp="1650226882502" timestamp="1225454" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="438" _type="ShellCommand" date="Sun Apr 17 16:41:48 EDT 2022" starttimestamp="1650226882502" timestamp="1225530" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="441" _type="MoveCaretCommand" caretOffset="582" date="Sun Apr 17 16:41:49 EDT 2022" docOffset="882" starttimestamp="1650226882502" timestamp="1226781" />
  <Command __id="442" _type="MoveCaretCommand" caretOffset="582" date="Sun Apr 17 16:41:49 EDT 2022" docOffset="882" starttimestamp="1650226882502" timestamp="1226781" />
  <Command __id="443" _type="ShellCommand" date="Sun Apr 17 16:41:53 EDT 2022" starttimestamp="1650226882502" timestamp="1230818" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="444" _type="ShellCommand" date="Sun Apr 17 16:41:53 EDT 2022" starttimestamp="1650226882502" timestamp="1230932" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="448" _type="SelectTextCommand" caretOffset="407" date="Sun Apr 17 16:41:53 EDT 2022" end="407" start="390" starttimestamp="1650226882502" timestamp="1231154" />
  <Command __id="449" _type="MoveCaretCommand" caretOffset="400" date="Sun Apr 17 16:41:56 EDT 2022" docOffset="2740" starttimestamp="1650226882502" timestamp="1233661" />
  <Command __id="450" _type="MoveCaretCommand" caretOffset="400" date="Sun Apr 17 16:41:58 EDT 2022" docOffset="2740" starttimestamp="1650226882502" timestamp="1235611" />
  <Command __id="451" _type="SelectTextCommand" caretOffset="389" date="Sun Apr 17 16:41:59 EDT 2022" end="400" start="389" starttimestamp="1650226882502" timestamp="1237075" />
  <Command __id="452" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:42:00 EDT 2022" starttimestamp="1650226882502" timestamp="1238331" />
  <Command __id="455" _type="UndoCommand" date="Sun Apr 17 16:42:01 EDT 2022" starttimestamp="1650226882502" timestamp="1239090" />
  <Command __id="421" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:41:28 EDT 2022" docASTNodeCount="212" docActiveCodeLength="1334" docExpressionCount="147" docLength="1334" projectName="pa3" starttimestamp="1650226882502" timestamp="1205979">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		AST ast = parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification("), Diff(INSERT,"(Package) ast, errorReporter"), Diff(EQUAL,");¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ASTDisplay;
import miniJava.ContextualAnalyzer.Identification;
import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(3);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		AST ast = parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			new ASTDisplay().showTree(ast);
		}
		
		System.out.println("Starting contextual analysis...");
		Identification id = new Identification((Package) ast, errorReporter);
		System.exit(0);
		
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="429" _type="Delete" date="Sun Apr 17 16:41:40 EDT 2022" docASTNodeCount="210" docActiveCodeLength="1325" docExpressionCount="146" docLength="1325" endLine="39" length="9" offset="1273" startLine="39" starttimestamp="1650226882502" timestamp="1218403">
    <text><![CDATA[Package) ]]></text>
  </DocumentChange>
  <DocumentChange __id="432" _type="Delete" date="Sun Apr 17 16:41:41 EDT 2022" docASTNodeCount="209" docActiveCodeLength="1324" docExpressionCount="145" docLength="1324" endLine="39" length="1" offset="1272" startLine="39" starttimestamp="1650226882502" timestamp="1218596">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="439" _type="Delete" date="Sun Apr 17 16:41:48 EDT 2022" docASTNodeCount="207" docActiveCodeLength="1321" docExpressionCount="145" docLength="1321" endLine="27" length="3" offset="875" startLine="27" starttimestamp="1650226882502" timestamp="1225543">
    <text><![CDATA[AST]]></text>
  </DocumentChange>
  <DocumentChange __id="440" _type="Insert" date="Sun Apr 17 16:41:48 EDT 2022" docASTNodeCount="209" docActiveCodeLength="1328" docExpressionCount="145" docLength="1328" length="7" offset="875" starttimestamp="1650226882502" timestamp="1225544">
    <text><![CDATA[Package]]></text>
  </DocumentChange>
  <Command __id="445" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:41:53 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1230972">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="446" _type="Delete" date="Sun Apr 17 16:41:53 EDT 2022" docASTNodeCount="3247" docActiveCodeLength="22073" docExpressionCount="2261" docLength="29055" endLine="69" length="3" offset="2730" startLine="69" starttimestamp="1650226882502" timestamp="1231044">
    <text><![CDATA[AST]]></text>
  </DocumentChange>
  <DocumentChange __id="447" _type="Insert" date="Sun Apr 17 16:41:53 EDT 2022" docASTNodeCount="3253" docActiveCodeLength="22090" docExpressionCount="2266" docLength="29072" length="17" offset="2730" starttimestamp="1650226882502" timestamp="1231056">
    <text><![CDATA[java.lang.Package]]></text>
  </DocumentChange>
  <DocumentChange __id="453" _type="Delete" date="Sun Apr 17 16:42:01 EDT 2022" docASTNodeCount="3247" docActiveCodeLength="22073" docExpressionCount="2261" docLength="29055" endLine="69" length="17" offset="2730" startLine="69" starttimestamp="1650226882502" timestamp="1239066">
    <text><![CDATA[java.lang.Package]]></text>
  </DocumentChange>
  <DocumentChange __id="454" _type="Insert" date="Sun Apr 17 16:42:01 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" length="3" offset="2730" starttimestamp="1650226882502" timestamp="1239077">
    <text><![CDATA[AST]]></text>
  </DocumentChange>
  <Command __id="456" _type="MoveCaretCommand" caretOffset="406" date="Sun Apr 17 16:42:02 EDT 2022" docOffset="2746" starttimestamp="1650226882502" timestamp="1240179" />
  <Command __id="458" _type="MoveCaretCommand" caretOffset="36" date="Sun Apr 17 16:42:09 EDT 2022" docOffset="36" starttimestamp="1650226882502" timestamp="1246598" />
  <Command __id="460" _type="ShellCommand" date="Sun Apr 17 16:42:14 EDT 2022" starttimestamp="1650226882502" timestamp="1251879" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="461" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 16:42:20 EDT 2022" forward="false" matchWord="false" offset="36" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="1258274" wrapSearch="false">
    <searchString><![CDATA[pack]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="462" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 16:42:23 EDT 2022" forward="false" matchWord="false" offset="4" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="1261076" wrapSearch="false">
    <searchString><![CDATA[pack]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="463" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 16:42:24 EDT 2022" forward="false" matchWord="false" offset="4" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="1261580" wrapSearch="false">
    <searchString><![CDATA[pack]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="464" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 16:42:24 EDT 2022" forward="false" matchWord="false" offset="4" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="1261764" wrapSearch="false">
    <searchString><![CDATA[pack]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="465" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 16:42:24 EDT 2022" forward="false" matchWord="false" offset="4" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="1262341" wrapSearch="false">
    <searchString><![CDATA[pack]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="466" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 16:42:25 EDT 2022" forward="false" matchWord="false" offset="4" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="1262508" wrapSearch="false">
    <searchString><![CDATA[pack]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="467" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 16:42:25 EDT 2022" forward="false" matchWord="false" offset="4" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="1262684" wrapSearch="false">
    <searchString><![CDATA[pack]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="468" _type="ShellCommand" date="Sun Apr 17 16:42:27 EDT 2022" starttimestamp="1650226882502" timestamp="1264879" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="457" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:42:09 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6403" docExpressionCount="649" docLength="7491" projectName="pa3" starttimestamp="1650226882502" timestamp="1246545">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="469" _type="MoveCaretCommand" caretOffset="2023" date="Sun Apr 17 16:42:38 EDT 2022" docOffset="2023" starttimestamp="1650226882502" timestamp="1276427" />
  <DocumentChange __id="470" _type="Insert" date="Sun Apr 17 16:42:39 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6405" docExpressionCount="649" docLength="7493" length="2" offset="2023" starttimestamp="1650226882502" timestamp="1277480">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="471" _type="InsertStringCommand" date="Sun Apr 17 16:42:39 EDT 2022" starttimestamp="1650226882502" timestamp="1277484" timestamp2="1277484">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="473" _type="SelectTextCommand" caretOffset="156" date="Sun Apr 17 16:42:58 EDT 2022" end="156" start="149" starttimestamp="1650226882502" timestamp="1296094" />
  <Command __id="474" _type="MoveCaretCommand" caretOffset="112" date="Sun Apr 17 16:42:59 EDT 2022" docOffset="169" starttimestamp="1650226882502" timestamp="1297115" />
  <Command __id="475" _type="MoveCaretCommand" caretOffset="79" date="Sun Apr 17 16:43:00 EDT 2022" docOffset="136" starttimestamp="1650226882502" timestamp="1297524" />
  <Command __id="472" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:42:58 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="1296034">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="476" _type="SelectTextCommand" caretOffset="50" date="Sun Apr 17 16:43:05 EDT 2022" end="78" start="50" starttimestamp="1650226882502" timestamp="1302819" />
  <Command __id="477" _type="CopyCommand" date="Sun Apr 17 16:43:05 EDT 2022" starttimestamp="1650226882502" timestamp="1303303" />
  <Command __id="478" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:43:08 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="1305689">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="479" _type="SelectTextCommand" caretOffset="199" date="Sun Apr 17 16:43:08 EDT 2022" end="199" start="171" starttimestamp="1650226882502" timestamp="1305732" />
  <Command __id="480" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:43:08 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1306119">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="481" _type="MoveCaretCommand" caretOffset="406" date="Sun Apr 17 16:43:08 EDT 2022" docOffset="2746" starttimestamp="1650226882502" timestamp="1306204" />
  <Command __id="482" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:43:09 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6405" docExpressionCount="649" docLength="7493" projectName="pa3" starttimestamp="1650226882502" timestamp="1306658">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶¶"), Diff(INSERT,"¶"), Diff(EQUAL,"public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;


public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="483" _type="MoveCaretCommand" caretOffset="2025" date="Sun Apr 17 16:43:09 EDT 2022" docOffset="2025" starttimestamp="1650226882502" timestamp="1306710" />
  <DocumentChange __id="484" _type="Insert" date="Sun Apr 17 16:43:10 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6433" docExpressionCount="649" docLength="7521" length="28" offset="2025" starttimestamp="1650226882502" timestamp="1307601">
    <text><![CDATA[miniJava.AbstractSyntaxTrees]]></text>
  </DocumentChange>
  <Command __id="485" _type="PasteCommand" date="Sun Apr 17 16:43:10 EDT 2022" starttimestamp="1650226882502" timestamp="1307607" />
  <DocumentChange __id="486" _type="Insert" date="Sun Apr 17 16:43:12 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6434" docExpressionCount="649" docLength="7522" length="1" offset="2025" starttimestamp="1650226882502" timestamp="1309631">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="487" _type="InsertStringCommand" date="Sun Apr 17 16:43:12 EDT 2022" starttimestamp="1650226882502" timestamp="1309636" timestamp2="1309636">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="488" _type="Insert" date="Sun Apr 17 16:43:12 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6435" docExpressionCount="649" docLength="7523" length="1" offset="2026" starttimestamp="1650226882502" timestamp="1309740">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="489" _type="InsertStringCommand" date="Sun Apr 17 16:43:12 EDT 2022" starttimestamp="1650226882502" timestamp="1309745" timestamp2="1309745">
    <data><![CDATA[m]]></data>
  </Command>
  <DocumentChange __id="490" _type="Insert" date="Sun Apr 17 16:43:12 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6436" docExpressionCount="649" docLength="7524" length="1" offset="2027" starttimestamp="1650226882502" timestamp="1309880">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="491" _type="InsertStringCommand" date="Sun Apr 17 16:43:12 EDT 2022" starttimestamp="1650226882502" timestamp="1309889" timestamp2="1309889">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="492" _type="Insert" date="Sun Apr 17 16:43:12 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6437" docExpressionCount="649" docLength="7525" length="1" offset="2028" starttimestamp="1650226882502" timestamp="1310031">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="493" _type="InsertStringCommand" date="Sun Apr 17 16:43:12 EDT 2022" starttimestamp="1650226882502" timestamp="1310034" timestamp2="1310034">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="494" _type="Insert" date="Sun Apr 17 16:43:12 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6438" docExpressionCount="649" docLength="7526" length="1" offset="2029" starttimestamp="1650226882502" timestamp="1310140">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="495" _type="InsertStringCommand" date="Sun Apr 17 16:43:12 EDT 2022" starttimestamp="1650226882502" timestamp="1310145" timestamp2="1310145">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="496" _type="Insert" date="Sun Apr 17 16:43:12 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6439" docExpressionCount="649" docLength="7527" length="1" offset="2030" starttimestamp="1650226882502" timestamp="1310317">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="497" _type="InsertStringCommand" date="Sun Apr 17 16:43:12 EDT 2022" starttimestamp="1650226882502" timestamp="1310321" timestamp2="1310321">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="499" _type="InsertStringCommand" date="Sun Apr 17 16:43:12 EDT 2022" starttimestamp="1650226882502" timestamp="1310460" timestamp2="1310460">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="500" _type="MoveCaretCommand" caretOffset="2060" date="Sun Apr 17 16:43:14 EDT 2022" docOffset="2060" starttimestamp="1650226882502" timestamp="1312099" />
  <Command __id="502" _type="InsertStringCommand" date="Sun Apr 17 16:43:15 EDT 2022" starttimestamp="1650226882502" timestamp="1312774" timestamp2="1312774">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="503" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 16:43:15 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="1312776" />
  <Command __id="508" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 16:43:17 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="1315128" />
  <Command __id="509" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.LINE_DOWN" date="Sun Apr 17 16:43:17 EDT 2022" starttimestamp="1650226882502" timestamp="1315272" />
  <DocumentChange __id="498" _type="Insert" date="Sun Apr 17 16:43:12 EDT 2022" docASTNodeCount="1063" docActiveCodeLength="6440" docExpressionCount="652" docLength="7528" length="1" offset="2031" starttimestamp="1650226882502" timestamp="1310454">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="501" _type="Insert" date="Sun Apr 17 16:43:15 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6441" docExpressionCount="649" docLength="7529" length="1" offset="2060" starttimestamp="1650226882502" timestamp="1312771">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="504" _type="Insert" date="Sun Apr 17 16:43:15 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6442" docExpressionCount="654" docLength="7530" length="1" offset="2061" starttimestamp="1650226882502" timestamp="1313267">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="505" _type="Delete" date="Sun Apr 17 16:43:16 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6441" docExpressionCount="649" docLength="7529" endLine="45" length="1" offset="2061" startLine="45" starttimestamp="1650226882502" timestamp="1313567">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="506" _type="Insert" date="Sun Apr 17 16:43:16 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6442" docExpressionCount="654" docLength="7530" length="1" offset="2061" starttimestamp="1650226882502" timestamp="1313794">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="507" _type="Insert" date="Sun Apr 17 16:43:16 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6443" docExpressionCount="654" docLength="7531" length="1" offset="2062" starttimestamp="1650226882502" timestamp="1313919">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="511" _type="Insert" date="Sun Apr 17 16:43:19 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6444" docExpressionCount="654" docLength="7532" length="1" offset="2063" starttimestamp="1650226882502" timestamp="1316542">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="532" _type="EclipseCommand" commandID="" date="Sun Apr 17 16:43:29 EDT 2022" starttimestamp="1650226882502" timestamp="1327055" />
  <Command __id="533" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Apr 17 16:43:29 EDT 2022" starttimestamp="1650226882502" timestamp="1327059" />
  <Command __id="534" _type="EclipseCommand" commandID="" date="Sun Apr 17 16:43:30 EDT 2022" starttimestamp="1650226882502" timestamp="1327685" />
  <DocumentChange __id="513" _type="Delete" date="Sun Apr 17 16:43:20 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6443" docExpressionCount="654" docLength="7531" endLine="45" length="1" offset="2063" startLine="45" starttimestamp="1650226882502" timestamp="1317574">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="515" _type="Delete" date="Sun Apr 17 16:43:20 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6442" docExpressionCount="654" docLength="7530" endLine="45" length="1" offset="2062" startLine="45" starttimestamp="1650226882502" timestamp="1317723">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="517" _type="Delete" date="Sun Apr 17 16:43:20 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6441" docExpressionCount="649" docLength="7529" endLine="45" length="1" offset="2061" startLine="45" starttimestamp="1650226882502" timestamp="1318024">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="519" _type="Delete" date="Sun Apr 17 16:43:20 EDT 2022" docASTNodeCount="1063" docActiveCodeLength="6440" docExpressionCount="652" docLength="7528" endLine="45" length="1" offset="2060" startLine="45" starttimestamp="1650226882502" timestamp="1318250">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="521" _type="Insert" date="Sun Apr 17 16:43:21 EDT 2022" docASTNodeCount="1059" docActiveCodeLength="6441" docExpressionCount="649" docLength="7529" length="1" offset="2060" starttimestamp="1650226882502" timestamp="1319019">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="524" _type="Insert" date="Sun Apr 17 16:43:21 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6442" docExpressionCount="654" docLength="7530" length="1" offset="2061" starttimestamp="1650226882502" timestamp="1319278">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="525" _type="Insert" date="Sun Apr 17 16:43:22 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6443" docExpressionCount="654" docLength="7531" length="1" offset="2062" starttimestamp="1650226882502" timestamp="1319883">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="526" _type="Delete" date="Sun Apr 17 16:43:22 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6442" docExpressionCount="654" docLength="7530" endLine="45" length="1" offset="2062" startLine="45" starttimestamp="1650226882502" timestamp="1320170">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="527" _type="Insert" date="Sun Apr 17 16:43:22 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6443" docExpressionCount="654" docLength="7531" length="1" offset="2062" starttimestamp="1650226882502" timestamp="1320235">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="528" _type="Insert" date="Sun Apr 17 16:43:22 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6444" docExpressionCount="654" docLength="7532" length="1" offset="2063" starttimestamp="1650226882502" timestamp="1320416">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="530" _type="Replace" date="Sun Apr 17 16:43:23 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" endLine="45" insertionLength="8" int_docASTNodeCount="1059" int_docActiveCodeLength="6441" int_docExpressionCount="649" int_docLength="7529" length="3" offset="2061" startLine="45" starttimestamp="1650226882502" timestamp="1320848">
    <deletedText><![CDATA[pac]]></deletedText>
    <insertedText><![CDATA[Package;]]></insertedText>
  </DocumentChange>
  <Command __id="537" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:43:33 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="1331108">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="535" _type="SelectTextCommand" caretOffset="2025" date="Sun Apr 17 16:43:32 EDT 2022" end="2069" start="2025" starttimestamp="1650226882502" timestamp="1329819" />
  <Command __id="536" _type="CopyCommand" date="Sun Apr 17 16:43:32 EDT 2022" starttimestamp="1650226882502" timestamp="1330496" />
  <Command __id="538" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:43:33 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="1331161" />
  <Command __id="540" _type="MoveCaretCommand" caretOffset="582" date="Sun Apr 17 16:43:35 EDT 2022" docOffset="882" starttimestamp="1650226882502" timestamp="1333021" />
  <Command __id="539" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:43:35 EDT 2022" docASTNodeCount="209" docActiveCodeLength="1328" docExpressionCount="145" docLength="1328" projectName="pa3" starttimestamp="1650226882502" timestamp="1332969">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		"), Diff(DELETE,"AST"), Diff(INSERT,"Package"), Diff(EQUAL," ast = parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification("), Diff(DELETE,"(Package) "), Diff(EQUAL,"ast, errorReporter);¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ASTDisplay;
import miniJava.ContextualAnalyzer.Identification;
import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(3);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		Package ast = parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			new ASTDisplay().showTree(ast);
		}
		
		System.out.println("Starting contextual analysis...");
		Identification id = new Identification(ast, errorReporter);
		System.exit(0);
		
	}
}
]]></snapshot>
  </Command>
  <Command __id="541" _type="MoveCaretCommand" caretOffset="213" date="Sun Apr 17 16:43:41 EDT 2022" docOffset="213" starttimestamp="1650226882502" timestamp="1339131" />
  <Command __id="542" _type="MoveCaretCommand" caretOffset="213" date="Sun Apr 17 16:43:41 EDT 2022" docOffset="213" starttimestamp="1650226882502" timestamp="1339131" />
  <DocumentChange __id="543" _type="Insert" date="Sun Apr 17 16:43:42 EDT 2022" docASTNodeCount="209" docActiveCodeLength="1330" docExpressionCount="145" docLength="1330" length="2" offset="213" starttimestamp="1650226882502" timestamp="1340362">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="544" _type="InsertStringCommand" date="Sun Apr 17 16:43:42 EDT 2022" starttimestamp="1650226882502" timestamp="1340368" timestamp2="1340368">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="545" _type="InsertStringCommand" date="Sun Apr 17 16:43:42 EDT 2022" starttimestamp="1650226882502" timestamp="1340368" timestamp2="1340368">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="547" _type="PasteCommand" date="Sun Apr 17 16:43:43 EDT 2022" starttimestamp="1650226882502" timestamp="1340567" />
  <Command __id="548" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Apr 17 16:43:44 EDT 2022" starttimestamp="1650226882502" timestamp="1342294" />
  <Command __id="549" _type="EclipseCommand" commandID="" date="Sun Apr 17 16:43:44 EDT 2022" starttimestamp="1650226882502" timestamp="1342438" />
  <Command __id="550" _type="EclipseCommand" commandID="" date="Sun Apr 17 16:43:45 EDT 2022" starttimestamp="1650226882502" timestamp="1342545" />
  <Command __id="551" _type="ShellCommand" date="Sun Apr 17 16:43:48 EDT 2022" starttimestamp="1650226882502" timestamp="1346496" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="552" _type="ShellCommand" date="Sun Apr 17 16:43:49 EDT 2022" starttimestamp="1650226882502" timestamp="1346613" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="556" _type="MoveCaretCommand" caretOffset="1013" date="Sun Apr 17 16:43:51 EDT 2022" docOffset="1013" starttimestamp="1650226882502" timestamp="1349292" />
  <Command __id="557" _type="MoveCaretCommand" caretOffset="1013" date="Sun Apr 17 16:43:51 EDT 2022" docOffset="1013" starttimestamp="1650226882502" timestamp="1349292" />
  <Command __id="558" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Apr 17 16:43:52 EDT 2022" starttimestamp="1650226882502" timestamp="1349914" />
  <Command __id="559" _type="EclipseCommand" commandID="" date="Sun Apr 17 16:43:52 EDT 2022" starttimestamp="1650226882502" timestamp="1350009" />
  <Command __id="560" _type="EclipseCommand" commandID="" date="Sun Apr 17 16:43:52 EDT 2022" starttimestamp="1650226882502" timestamp="1350025" />
  <Command __id="561" _type="MoveCaretCommand" caretOffset="1121" date="Sun Apr 17 16:43:53 EDT 2022" docOffset="1121" starttimestamp="1650226882502" timestamp="1350723" />
  <Command __id="562" _type="MoveCaretCommand" caretOffset="1121" date="Sun Apr 17 16:43:53 EDT 2022" docOffset="1121" starttimestamp="1650226882502" timestamp="1350723" />
  <Command __id="563" _type="MoveCaretCommand" caretOffset="1326" date="Sun Apr 17 16:43:56 EDT 2022" docOffset="1326" starttimestamp="1650226882502" timestamp="1353556" />
  <Command __id="564" _type="MoveCaretCommand" caretOffset="1326" date="Sun Apr 17 16:43:56 EDT 2022" docOffset="1326" starttimestamp="1650226882502" timestamp="1353556" />
  <Command __id="565" _type="MoveCaretCommand" caretOffset="1375" date="Sun Apr 17 16:43:56 EDT 2022" docOffset="1375" starttimestamp="1650226882502" timestamp="1353859" />
  <Command __id="566" _type="MoveCaretCommand" caretOffset="1375" date="Sun Apr 17 16:43:56 EDT 2022" docOffset="1375" starttimestamp="1650226882502" timestamp="1353859" />
  <Command __id="567" _type="MoveCaretCommand" caretOffset="1371" date="Sun Apr 17 16:43:57 EDT 2022" docOffset="1371" starttimestamp="1650226882502" timestamp="1355019" />
  <Command __id="568" _type="MoveCaretCommand" caretOffset="1371" date="Sun Apr 17 16:43:57 EDT 2022" docOffset="1371" starttimestamp="1650226882502" timestamp="1355020" />
  <Command __id="569" _type="MoveCaretCommand" caretOffset="1371" date="Sun Apr 17 16:43:57 EDT 2022" docOffset="1371" starttimestamp="1650226882502" timestamp="1355355" />
  <Command __id="570" _type="MoveCaretCommand" caretOffset="1371" date="Sun Apr 17 16:43:57 EDT 2022" docOffset="1371" starttimestamp="1650226882502" timestamp="1355355" />
  <Command __id="571" _type="MoveCaretCommand" caretOffset="1371" date="Sun Apr 17 16:43:58 EDT 2022" docOffset="1371" starttimestamp="1650226882502" timestamp="1355699" />
  <Command __id="572" _type="MoveCaretCommand" caretOffset="1371" date="Sun Apr 17 16:43:58 EDT 2022" docOffset="1371" starttimestamp="1650226882502" timestamp="1355699" />
  <Command __id="573" _type="MoveCaretCommand" caretOffset="1352" date="Sun Apr 17 16:43:58 EDT 2022" docOffset="1352" starttimestamp="1650226882502" timestamp="1356035" />
  <Command __id="574" _type="MoveCaretCommand" caretOffset="1352" date="Sun Apr 17 16:43:58 EDT 2022" docOffset="1352" starttimestamp="1650226882502" timestamp="1356035" />
  <Command __id="576" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1356786" timestamp2="1356786">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="577" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1356786" timestamp2="1356786">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="579" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1356934" timestamp2="1356934">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="580" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1356934" timestamp2="1356934">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="582" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1357095" timestamp2="1357095">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="583" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1357095" timestamp2="1357095">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="585" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1357238" timestamp2="1357238">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="586" _type="InsertStringCommand" date="Sun Apr 17 16:43:59 EDT 2022" starttimestamp="1650226882502" timestamp="1357239" timestamp2="1357239">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="587" _type="MoveCaretCommand" caretOffset="1356" date="Sun Apr 17 16:44:00 EDT 2022" docOffset="1356" starttimestamp="1650226882502" timestamp="1358452" />
  <Command __id="588" _type="MoveCaretCommand" caretOffset="1356" date="Sun Apr 17 16:44:00 EDT 2022" docOffset="1356" starttimestamp="1650226882502" timestamp="1358453" />
  <DocumentChange __id="546" _type="Insert" date="Sun Apr 17 16:43:43 EDT 2022" docASTNodeCount="215" docActiveCodeLength="1374" docExpressionCount="150" docLength="1374" length="44" offset="215" starttimestamp="1650226882502" timestamp="1340553">
    <text><![CDATA[import miniJava.AbstractSyntaxTrees.Package;]]></text>
  </DocumentChange>
  <DocumentChange __id="553" _type="Delete" date="Sun Apr 17 16:43:49 EDT 2022" docASTNodeCount="211" docActiveCodeLength="1360" docExpressionCount="147" docLength="1360" endLine="28" length="14" offset="935" startLine="28" starttimestamp="1650226882502" timestamp="1346634">
    <text><![CDATA[parser.parse()]]></text>
  </DocumentChange>
  <DocumentChange __id="554" _type="Insert" date="Sun Apr 17 16:43:49 EDT 2022" docASTNodeCount="215" docActiveCodeLength="1374" docExpressionCount="150" docLength="1374" length="14" offset="935" starttimestamp="1650226882502" timestamp="1346638">
    <text><![CDATA[parser.parse()]]></text>
  </DocumentChange>
  <DocumentChange __id="555" _type="Insert" date="Sun Apr 17 16:43:49 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1384" docExpressionCount="152" docLength="1384" length="10" offset="935" starttimestamp="1650226882502" timestamp="1346639">
    <text><![CDATA[(Package) ]]></text>
  </DocumentChange>
  <DocumentChange __id="575" _type="Insert" date="Sun Apr 17 16:43:59 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1388" docExpressionCount="152" docLength="1388" length="4" offset="1352" starttimestamp="1650226882502" timestamp="1356781">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="578" _type="Insert" date="Sun Apr 17 16:43:59 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1392" docExpressionCount="152" docLength="1392" length="4" offset="1356" starttimestamp="1650226882502" timestamp="1356930">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="581" _type="Insert" date="Sun Apr 17 16:43:59 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1396" docExpressionCount="152" docLength="1396" length="4" offset="1360" starttimestamp="1650226882502" timestamp="1357090">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="584" _type="Insert" date="Sun Apr 17 16:43:59 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1400" docExpressionCount="152" docLength="1400" length="4" offset="1364" starttimestamp="1650226882502" timestamp="1357234">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="589" _type="MoveCaretCommand" caretOffset="1356" date="Sun Apr 17 16:44:08 EDT 2022" docOffset="1356" starttimestamp="1650226882502" timestamp="1366067" />
  <Command __id="590" _type="MoveCaretCommand" caretOffset="1356" date="Sun Apr 17 16:44:08 EDT 2022" docOffset="1356" starttimestamp="1650226882502" timestamp="1366067" />
  <Command __id="592" _type="SelectTextCommand" caretOffset="2025" date="Sun Apr 17 16:44:27 EDT 2022" end="2069" start="2025" starttimestamp="1650226882502" timestamp="1385474" />
  <Command __id="593" _type="MoveCaretCommand" caretOffset="2601" date="Sun Apr 17 16:44:39 EDT 2022" docOffset="2601" starttimestamp="1650226882502" timestamp="1397075" />
  <Command __id="594" _type="ShellCommand" date="Sun Apr 17 16:45:46 EDT 2022" starttimestamp="1650226882502" timestamp="1464159" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="591" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:44:27 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" projectName="pa3" starttimestamp="1650226882502" timestamp="1385421">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶"), Diff(INSERT,"import miniJava.AbstractSyntaxTrees.Package;"), Diff(EQUAL,"¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="596" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:46:57 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1534984">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="598" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:46:58 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="1535754">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="600" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:46:58 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="1536103">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="602" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:46:59 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="1536907">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="604" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:46:59 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1400" docExpressionCount="152" docLength="1400" projectName="pa3" starttimestamp="1650226882502" timestamp="1537218">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶"), Diff(INSERT,"import miniJava.AbstractSyntaxTrees.Package;¶"), Diff(EQUAL,"import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast ="), Diff(INSERT," (Package)"), Diff(EQUAL," parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		"), Diff(INSERT,"¶		¶		¶		¶		"), Diff(EQUAL,"System.exit(0);¶		¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ASTDisplay;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.ContextualAnalyzer.Identification;
import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(3);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		Package ast = (Package) parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			new ASTDisplay().showTree(ast);
		}
		
		System.out.println("Starting contextual analysis...");
		Identification id = new Identification(ast, errorReporter);
		
		
		
		
		System.exit(0);
		
	}
}
]]></snapshot>
  </Command>
  <Command __id="595" _type="ShellCommand" date="Sun Apr 17 16:46:57 EDT 2022" starttimestamp="1650226882502" timestamp="1534873" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="597" _type="MoveCaretCommand" caretOffset="406" date="Sun Apr 17 16:46:57 EDT 2022" docOffset="2746" starttimestamp="1650226882502" timestamp="1535053" />
  <Command __id="599" _type="SelectTextCommand" caretOffset="199" date="Sun Apr 17 16:46:58 EDT 2022" end="199" start="171" starttimestamp="1650226882502" timestamp="1535814" />
  <Command __id="601" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:46:58 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="1536185" />
  <Command __id="603" _type="SelectTextCommand" caretOffset="50" date="Sun Apr 17 16:46:59 EDT 2022" end="78" start="50" starttimestamp="1650226882502" timestamp="1536964" />
  <Command __id="605" _type="MoveCaretCommand" caretOffset="1356" date="Sun Apr 17 16:46:59 EDT 2022" docOffset="1356" starttimestamp="1650226882502" timestamp="1537273" />
  <Command __id="607" _type="InsertStringCommand" date="Sun Apr 17 16:47:10 EDT 2022" starttimestamp="1650226882502" timestamp="1548455" timestamp2="1548455">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="608" _type="InsertStringCommand" date="Sun Apr 17 16:47:10 EDT 2022" starttimestamp="1650226882502" timestamp="1548455" timestamp2="1548455">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="609" _type="ShellCommand" date="Sun Apr 17 16:47:58 EDT 2022" starttimestamp="1650226882502" timestamp="1596150" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="606" _type="Insert" date="Sun Apr 17 16:47:10 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" length="4" offset="1356" starttimestamp="1650226882502" timestamp="1548450">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="611" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:48:08 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" projectName="pa3" starttimestamp="1650226882502" timestamp="1606206">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="610" _type="ShellCommand" date="Sun Apr 17 16:48:08 EDT 2022" starttimestamp="1650226882502" timestamp="1606103" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="612" _type="MoveCaretCommand" caretOffset="2601" date="Sun Apr 17 16:48:08 EDT 2022" docOffset="2601" starttimestamp="1650226882502" timestamp="1606267" />
  <Command __id="614" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:48:15 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="1613394" />
  <Command __id="615" _type="ShellCommand" date="Sun Apr 17 16:48:23 EDT 2022" starttimestamp="1650226882502" timestamp="1621462" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="613" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:48:15 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="1613345">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="617" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:49:20 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" projectName="pa3" starttimestamp="1650226882502" timestamp="1677554">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="619" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:50:08 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1725983">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="621" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:50:18 EDT 2022" docASTNodeCount="103" docActiveCodeLength="557" docExpressionCount="61" docLength="654" projectName="pa3" starttimestamp="1650226882502" timestamp="1735778">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\AST.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

public abstract class AST {

  public AST (SourcePosition posn) {
    this.posn = posn;
  }
  
  public String toString() {
      String fullClassName = this.getClass().getName();
      String cn = fullClassName.substring(1 + fullClassName.lastIndexOf('.'));
      if (ASTDisplay.showPosition)
    	  cn = cn + " " + posn.toString();
      return cn;
  }

  public abstract <A,R> R visit(Visitor<A,R> v, A o);

  public SourcePosition posn;
}
]]></snapshot>
  </Command>
  <Command __id="616" _type="ShellCommand" date="Sun Apr 17 16:49:19 EDT 2022" starttimestamp="1650226882502" timestamp="1677441" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="618" _type="MoveCaretCommand" caretOffset="2601" date="Sun Apr 17 16:49:20 EDT 2022" docOffset="2601" starttimestamp="1650226882502" timestamp="1677611" />
  <Command __id="620" _type="MoveCaretCommand" caretOffset="406" date="Sun Apr 17 16:50:08 EDT 2022" docOffset="2746" starttimestamp="1650226882502" timestamp="1726050" />
  <Command __id="622" _type="SelectTextCommand" caretOffset="161" date="Sun Apr 17 16:50:18 EDT 2022" end="161" start="158" starttimestamp="1650226882502" timestamp="1735934" />
  <Command __id="624" _type="MoveCaretCommand" caretOffset="406" date="Sun Apr 17 16:50:36 EDT 2022" docOffset="2746" starttimestamp="1650226882502" timestamp="1754287" />
  <Command __id="625" _type="MoveCaretCommand" caretOffset="558" date="Sun Apr 17 16:50:38 EDT 2022" docOffset="2898" starttimestamp="1650226882502" timestamp="1756235" />
  <Command __id="623" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:50:36 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1754134">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="626" _type="MoveCaretCommand" caretOffset="557" date="Sun Apr 17 16:50:44 EDT 2022" docOffset="2897" starttimestamp="1650226882502" timestamp="1762058" />
  <Command __id="627" _type="MoveCaretCommand" caretOffset="558" date="Sun Apr 17 16:50:44 EDT 2022" docOffset="2898" starttimestamp="1650226882502" timestamp="1762483" />
  <Command __id="629" _type="SelectTextCommand" caretOffset="156" date="Sun Apr 17 16:51:12 EDT 2022" end="156" start="149" starttimestamp="1650226882502" timestamp="1790225" />
  <Command __id="628" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:51:12 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="1790167">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="630" _type="SelectTextCommand" caretOffset="277" date="Sun Apr 17 16:51:18 EDT 2022" end="364" start="277" starttimestamp="1650226882502" timestamp="1796150" />
  <Command __id="631" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 16:51:19 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="1796515" />
  <Command __id="632" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:51:25 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1802993">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="633" _type="MoveCaretCommand" caretOffset="558" date="Sun Apr 17 16:51:25 EDT 2022" docOffset="2898" starttimestamp="1650226882502" timestamp="1803051" />
  <Command __id="634" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:51:51 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="1828958">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="635" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 16:51:51 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="1829014" />
  <Command __id="636" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:51:58 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1836112">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="637" _type="MoveCaretCommand" caretOffset="558" date="Sun Apr 17 16:51:58 EDT 2022" docOffset="2898" starttimestamp="1650226882502" timestamp="1836184" />
  <Command __id="638" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:52:18 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="1856111">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="639" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 16:52:18 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="1856155" />
  <Command __id="640" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:52:50 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1887852">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="641" _type="MoveCaretCommand" caretOffset="558" date="Sun Apr 17 16:52:50 EDT 2022" docOffset="2898" starttimestamp="1650226882502" timestamp="1887910" />
  <Command __id="642" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:53:06 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="1903608">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="643" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 16:53:06 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="1903654" />
  <Command __id="645" _type="MoveCaretCommand" caretOffset="558" date="Sun Apr 17 16:53:08 EDT 2022" docOffset="2898" starttimestamp="1650226882502" timestamp="1905532" />
  <Command __id="646" _type="MoveCaretCommand" caretOffset="1262" date="Sun Apr 17 16:53:23 EDT 2022" docOffset="3602" starttimestamp="1650226882502" timestamp="1920874" />
  <Command __id="647" _type="MoveCaretCommand" caretOffset="1262" date="Sun Apr 17 16:53:23 EDT 2022" docOffset="3602" starttimestamp="1650226882502" timestamp="1920874" />
  <Command __id="648" _type="MoveCaretCommand" caretOffset="1262" date="Sun Apr 17 16:53:23 EDT 2022" docOffset="3602" starttimestamp="1650226882502" timestamp="1921218" />
  <Command __id="649" _type="MoveCaretCommand" caretOffset="1262" date="Sun Apr 17 16:53:23 EDT 2022" docOffset="3602" starttimestamp="1650226882502" timestamp="1921218" />
  <Command __id="650" _type="SelectTextCommand" caretOffset="1226" date="Sun Apr 17 16:53:24 EDT 2022" end="1248" start="1226" starttimestamp="1650226882502" timestamp="1922467" />
  <Command __id="651" _type="SelectTextCommand" caretOffset="1226" date="Sun Apr 17 16:53:24 EDT 2022" end="1248" start="1226" starttimestamp="1650226882502" timestamp="1922467" />
  <Command __id="652" _type="MoveCaretCommand" caretOffset="1294" date="Sun Apr 17 16:53:25 EDT 2022" docOffset="3634" starttimestamp="1650226882502" timestamp="1922770" />
  <Command __id="653" _type="MoveCaretCommand" caretOffset="1294" date="Sun Apr 17 16:53:25 EDT 2022" docOffset="3634" starttimestamp="1650226882502" timestamp="1922770" />
  <Command __id="654" _type="ShellCommand" date="Sun Apr 17 16:53:26 EDT 2022" starttimestamp="1650226882502" timestamp="1923794" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="655" _type="ShellCommand" date="Sun Apr 17 16:53:27 EDT 2022" starttimestamp="1650226882502" timestamp="1924730" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="656" _type="ShellCommand" date="Sun Apr 17 16:53:27 EDT 2022" starttimestamp="1650226882502" timestamp="1925078" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="657" _type="ShellCommand" date="Sun Apr 17 16:53:28 EDT 2022" starttimestamp="1650226882502" timestamp="1926231" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="658" _type="MoveCaretCommand" caretOffset="1658" date="Sun Apr 17 16:53:28 EDT 2022" docOffset="3998" starttimestamp="1650226882502" timestamp="1926276" />
  <Command __id="659" _type="MoveCaretCommand" caretOffset="1658" date="Sun Apr 17 16:53:28 EDT 2022" docOffset="3998" starttimestamp="1650226882502" timestamp="1926276" />
  <Command __id="660" _type="MoveCaretCommand" caretOffset="1333" date="Sun Apr 17 16:53:29 EDT 2022" docOffset="3673" starttimestamp="1650226882502" timestamp="1926626" />
  <Command __id="661" _type="MoveCaretCommand" caretOffset="1333" date="Sun Apr 17 16:53:29 EDT 2022" docOffset="3673" starttimestamp="1650226882502" timestamp="1926626" />
  <Command __id="662" _type="MoveCaretCommand" caretOffset="1262" date="Sun Apr 17 16:53:29 EDT 2022" docOffset="3602" starttimestamp="1650226882502" timestamp="1926922" />
  <Command __id="663" _type="MoveCaretCommand" caretOffset="1262" date="Sun Apr 17 16:53:29 EDT 2022" docOffset="3602" starttimestamp="1650226882502" timestamp="1926922" />
  <Command __id="644" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:53:07 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1905421">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="664" _type="MoveCaretCommand" caretOffset="1474" date="Sun Apr 17 16:53:42 EDT 2022" docOffset="3814" starttimestamp="1650226882502" timestamp="1940251" />
  <Command __id="665" _type="MoveCaretCommand" caretOffset="1474" date="Sun Apr 17 16:53:42 EDT 2022" docOffset="3814" starttimestamp="1650226882502" timestamp="1940251" />
  <Command __id="666" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:53:45 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="1942831">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="667" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 16:53:45 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="1942884" />
  <Command __id="668" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:53:47 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1944747">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="669" _type="MoveCaretCommand" caretOffset="1474" date="Sun Apr 17 16:53:47 EDT 2022" docOffset="3814" starttimestamp="1650226882502" timestamp="1944814" />
  <Command __id="670" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:54:15 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="1972855">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		"), Diff(INSERT,"¶		"), Diff(EQUAL,"System.exit(0);¶		¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

import miniJava.AbstractSyntaxTrees.AST;
import miniJava.AbstractSyntaxTrees.ASTDisplay;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.ContextualAnalyzer.Identification;
import miniJava.SyntacticAnalyzer.Parser;
import miniJava.SyntacticAnalyzer.Scanner;

public class Compiler {
	public static void main(String[] args) {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("Input file " + args[0] + " not found");
			System.exit(3);
		}
		
		ErrorReporter errorReporter = new ErrorReporter();
		Scanner scanner = new Scanner(inputStream, errorReporter);
		Parser parser = new Parser(scanner, errorReporter);
		
		System.out.println("Syntactic analysis ... ");
		Package ast = (Package) parser.parse();
		System.out.print("Sytactic analysis complete: ");
		if (errorReporter.hasErrors()) {
			System.out.println("Invalid miniJava program");
			System.exit(4);
		}
		else {
			System.out.println("Valid miniJava program");
			new ASTDisplay().showTree(ast);
		}
		
		System.out.println("Starting contextual analysis...");
		Identification id = new Identification(ast, errorReporter);
		
		
		
		
		
		System.exit(0);
		
	}
}
]]></snapshot>
  </Command>
  <Command __id="671" _type="MoveCaretCommand" caretOffset="1360" date="Sun Apr 17 16:54:15 EDT 2022" docOffset="1360" starttimestamp="1650226882502" timestamp="1972902" />
  <Command __id="672" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:54:19 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="1976537">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="673" _type="MoveCaretCommand" caretOffset="1474" date="Sun Apr 17 16:54:19 EDT 2022" docOffset="3814" starttimestamp="1650226882502" timestamp="1976602" />
  <Command __id="674" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:54:26 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="1984349">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="675" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 16:54:26 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="1984401" />
  <Command __id="677" _type="MoveCaretCommand" caretOffset="2601" date="Sun Apr 17 16:54:30 EDT 2022" docOffset="2601" starttimestamp="1650226882502" timestamp="1988277" />
  <Command __id="678" _type="SelectTextCommand" caretOffset="2352" date="Sun Apr 17 16:54:34 EDT 2022" end="2373" start="2352" starttimestamp="1650226882502" timestamp="1991715" />
  <Command __id="679" _type="MoveCaretCommand" caretOffset="2377" date="Sun Apr 17 16:54:34 EDT 2022" docOffset="2377" starttimestamp="1650226882502" timestamp="1992074" />
  <Command __id="676" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:54:30 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" projectName="pa3" starttimestamp="1650226882502" timestamp="1988224">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="680" _type="SelectTextCommand" caretOffset="2377" date="Sun Apr 17 16:54:35 EDT 2022" end="2377" start="2350" starttimestamp="1650226882502" timestamp="1993122" />
  <Command __id="681" _type="MoveCaretCommand" caretOffset="2377" date="Sun Apr 17 16:54:35 EDT 2022" docOffset="2377" starttimestamp="1650226882502" timestamp="1993482" />
  <Command __id="682" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:54:53 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="2010744">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="683" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 16:54:53 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="2010794" />
  <Command __id="684" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:55:26 EDT 2022" docASTNodeCount="428" docActiveCodeLength="2318" docExpressionCount="198" docLength="2621" projectName="pa3" starttimestamp="1650226882502" timestamp="2044210">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Visitor.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

/**
 * An implementation of the Visitor interface provides a method visitX
 * for each non-abstract AST class X.  
 */
public interface Visitor<ArgType,ResultType> {

  // Package
    public ResultType visitPackage(Package prog, ArgType arg);

  // Declarations
    public ResultType visitClassDecl(ClassDecl cd, ArgType arg);
    public ResultType visitFieldDecl(FieldDecl fd, ArgType arg);
    public ResultType visitMethodDecl(MethodDecl md, ArgType arg);
    public ResultType visitParameterDecl(ParameterDecl pd, ArgType arg);
    public ResultType visitVarDecl(VarDecl decl, ArgType arg);
 
  // Types
    public ResultType visitBaseType(BaseType type, ArgType arg);
    public ResultType visitClassType(ClassType type, ArgType arg);
    public ResultType visitArrayType(ArrayType type, ArgType arg);
    
  // Statements
    public ResultType visitBlockStmt(BlockStmt stmt, ArgType arg);
    public ResultType visitVardeclStmt(VarDeclStmt stmt, ArgType arg);
    public ResultType visitAssignStmt(AssignStmt stmt, ArgType arg);
    public ResultType visitIxAssignStmt(IxAssignStmt stmt, ArgType arg);
    public ResultType visitCallStmt(CallStmt stmt, ArgType arg);
    public ResultType visitReturnStmt(ReturnStmt stmt, ArgType arg);
    public ResultType visitIfStmt(IfStmt stmt, ArgType arg);
    public ResultType visitWhileStmt(WhileStmt stmt, ArgType arg);
    
  // Expressions
    public ResultType visitUnaryExpr(UnaryExpr expr, ArgType arg);
    public ResultType visitBinaryExpr(BinaryExpr expr, ArgType arg);
    public ResultType visitRefExpr(RefExpr expr, ArgType arg);
    public ResultType visitIxExpr(IxExpr expr, ArgType arg);
    public ResultType visitCallExpr(CallExpr expr, ArgType arg);
    public ResultType visitLiteralExpr(LiteralExpr expr, ArgType arg);
    public ResultType visitNewObjectExpr(NewObjectExpr expr, ArgType arg);
    public ResultType visitNewArrayExpr(NewArrayExpr expr, ArgType arg);
    
  // References
    public ResultType visitThisRef(ThisRef ref, ArgType arg);
    public ResultType visitIdRef(IdRef ref, ArgType arg);
    public ResultType visitQRef(QualRef ref, ArgType arg);

  // Terminals
    public ResultType visitIdentifier(Identifier id, ArgType arg);
    public ResultType visitOperator(Operator op, ArgType arg);
    public ResultType visitIntLiteral(IntLiteral num, ArgType arg);
    public ResultType visitBooleanLiteral(BooleanLiteral bool, ArgType arg);
}
]]></snapshot>
  </Command>
  <Command __id="685" _type="SelectTextCommand" caretOffset="230" date="Sun Apr 17 16:55:26 EDT 2022" end="230" start="223" starttimestamp="1650226882502" timestamp="2044383" />
  <Command __id="686" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:55:34 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="2052144">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="687" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 16:55:34 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="2052256" />
  <Command __id="688" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:55:37 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="2055024">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="689" _type="MoveCaretCommand" caretOffset="1360" date="Sun Apr 17 16:55:37 EDT 2022" docOffset="1360" starttimestamp="1650226882502" timestamp="2055072" />
  <Command __id="690" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:55:39 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" projectName="pa3" starttimestamp="1650226882502" timestamp="2057209">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="691" _type="MoveCaretCommand" caretOffset="2377" date="Sun Apr 17 16:55:39 EDT 2022" docOffset="2377" starttimestamp="1650226882502" timestamp="2057260" />
  <Command __id="692" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:55:50 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="2068497">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="693" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 16:55:51 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="2068542" />
  <Command __id="694" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:55:57 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" projectName="pa3" starttimestamp="1650226882502" timestamp="2074991">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="695" _type="MoveCaretCommand" caretOffset="2377" date="Sun Apr 17 16:55:57 EDT 2022" docOffset="2377" starttimestamp="1650226882502" timestamp="2075046" />
  <Command __id="696" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:56:00 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="2077975">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="697" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 16:56:00 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="2078020" />
  <Command __id="699" _type="MoveCaretCommand" caretOffset="2377" date="Sun Apr 17 16:56:01 EDT 2022" docOffset="2377" starttimestamp="1650226882502" timestamp="2079196" />
  <Command __id="700" _type="MoveCaretCommand" caretOffset="2545" date="Sun Apr 17 16:56:18 EDT 2022" docOffset="2545" starttimestamp="1650226882502" timestamp="2095850" />
  <Command __id="701" _type="ShellCommand" date="Sun Apr 17 16:56:49 EDT 2022" starttimestamp="1650226882502" timestamp="2127492" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="702" _type="ShellCommand" date="Sun Apr 17 16:57:07 EDT 2022" starttimestamp="1650226882502" timestamp="2145034" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="703" _type="MoveCaretCommand" caretOffset="2519" date="Sun Apr 17 16:57:07 EDT 2022" docOffset="2519" starttimestamp="1650226882502" timestamp="2145140" />
  <Command __id="704" _type="MoveCaretCommand" caretOffset="2549" date="Sun Apr 17 16:57:10 EDT 2022" docOffset="2549" starttimestamp="1650226882502" timestamp="2148338" />
  <Command __id="705" _type="ShellCommand" date="Sun Apr 17 16:58:11 EDT 2022" starttimestamp="1650226882502" timestamp="2209384" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="706" _type="ShellCommand" date="Sun Apr 17 16:58:37 EDT 2022" starttimestamp="1650226882502" timestamp="2235085" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="707" _type="MoveCaretCommand" caretOffset="2545" date="Sun Apr 17 16:58:37 EDT 2022" docOffset="2545" starttimestamp="1650226882502" timestamp="2235154" />
  <Command __id="709" _type="InsertStringCommand" date="Sun Apr 17 16:58:38 EDT 2022" starttimestamp="1650226882502" timestamp="2236063" timestamp2="2236063">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="711" _type="InsertStringCommand" date="Sun Apr 17 16:58:38 EDT 2022" starttimestamp="1650226882502" timestamp="2236465" timestamp2="2236465">
    <data><![CDATA[D]]></data>
  </Command>
  <Command __id="713" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:58:39 EDT 2022" starttimestamp="1650226882502" timestamp="2236758" />
  <Command __id="715" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:58:39 EDT 2022" starttimestamp="1650226882502" timestamp="2236906" />
  <Command __id="717" _type="InsertStringCommand" date="Sun Apr 17 16:58:39 EDT 2022" starttimestamp="1650226882502" timestamp="2236975" timestamp2="2236975">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="719" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:58:39 EDT 2022" starttimestamp="1650226882502" timestamp="2237274" />
  <Command __id="721" _type="InsertStringCommand" date="Sun Apr 17 16:58:40 EDT 2022" starttimestamp="1650226882502" timestamp="2237506" timestamp2="2237506">
    <data><![CDATA[	]]></data>
  </Command>
  <Command __id="723" _type="InsertStringCommand" date="Sun Apr 17 16:58:40 EDT 2022" starttimestamp="1650226882502" timestamp="2237985" timestamp2="2237985">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="725" _type="InsertStringCommand" date="Sun Apr 17 16:58:40 EDT 2022" starttimestamp="1650226882502" timestamp="2238254" timestamp2="2238254">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="727" _type="InsertStringCommand" date="Sun Apr 17 16:58:40 EDT 2022" starttimestamp="1650226882502" timestamp="2238348" timestamp2="2238348">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="729" _type="InsertStringCommand" date="Sun Apr 17 16:58:40 EDT 2022" starttimestamp="1650226882502" timestamp="2238448" timestamp2="2238448">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="731" _type="InsertStringCommand" date="Sun Apr 17 16:58:41 EDT 2022" starttimestamp="1650226882502" timestamp="2238716" timestamp2="2238716">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="733" _type="InsertStringCommand" date="Sun Apr 17 16:58:41 EDT 2022" starttimestamp="1650226882502" timestamp="2238952" timestamp2="2238952">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="735" _type="InsertStringCommand" date="Sun Apr 17 16:58:41 EDT 2022" starttimestamp="1650226882502" timestamp="2239212" timestamp2="2239212">
    <data><![CDATA[P]]></data>
  </Command>
  <Command __id="737" _type="InsertStringCommand" date="Sun Apr 17 16:58:41 EDT 2022" starttimestamp="1650226882502" timestamp="2239397" timestamp2="2239397">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="739" _type="InsertStringCommand" date="Sun Apr 17 16:58:41 EDT 2022" starttimestamp="1650226882502" timestamp="2239479" timestamp2="2239479">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="741" _type="InsertStringCommand" date="Sun Apr 17 16:58:42 EDT 2022" starttimestamp="1650226882502" timestamp="2239662" timestamp2="2239662">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="743" _type="InsertStringCommand" date="Sun Apr 17 16:58:42 EDT 2022" starttimestamp="1650226882502" timestamp="2239731" timestamp2="2239731">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="745" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:58:43 EDT 2022" starttimestamp="1650226882502" timestamp="2240531" />
  <Command __id="747" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:58:43 EDT 2022" starttimestamp="1650226882502" timestamp="2240651" />
  <Command __id="749" _type="InsertStringCommand" date="Sun Apr 17 16:58:43 EDT 2022" starttimestamp="1650226882502" timestamp="2240872" timestamp2="2240872">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="751" _type="InsertStringCommand" date="Sun Apr 17 16:58:43 EDT 2022" starttimestamp="1650226882502" timestamp="2240944" timestamp2="2240944">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="698" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:56:01 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6449" docExpressionCount="654" docLength="7537" projectName="pa3" starttimestamp="1650226882502" timestamp="2079143">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="708" _type="Insert" date="Sun Apr 17 16:58:38 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6453" docExpressionCount="654" docLength="7541" length="4" offset="2545" starttimestamp="1650226882502" timestamp="2236060">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="710" _type="Insert" date="Sun Apr 17 16:58:38 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6454" docExpressionCount="655" docLength="7542" length="1" offset="2549" starttimestamp="1650226882502" timestamp="2236462">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <DocumentChange __id="712" _type="Delete" date="Sun Apr 17 16:58:39 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6453" docExpressionCount="654" docLength="7541" endLine="63" length="1" offset="2549" startLine="63" starttimestamp="1650226882502" timestamp="2236757">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <DocumentChange __id="714" _type="Delete" date="Sun Apr 17 16:58:39 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6452" docExpressionCount="654" docLength="7540" endLine="63" length="1" offset="2548" startLine="63" starttimestamp="1650226882502" timestamp="2236901">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="716" _type="Insert" date="Sun Apr 17 16:58:39 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6453" docExpressionCount="655" docLength="7541" length="1" offset="2548" starttimestamp="1650226882502" timestamp="2236972">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="718" _type="Delete" date="Sun Apr 17 16:58:39 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6452" docExpressionCount="654" docLength="7540" endLine="63" length="1" offset="2548" startLine="63" starttimestamp="1650226882502" timestamp="2237273">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="720" _type="Replace" date="Sun Apr 17 16:58:40 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6453" docExpressionCount="654" docLength="7541" endLine="63" insertionLength="2" int_docASTNodeCount="1065" int_docActiveCodeLength="6451" int_docExpressionCount="654" int_docLength="7539" length="1" offset="2547" startLine="63" starttimestamp="1650226882502" timestamp="2237502">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[		]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="722" _type="Insert" date="Sun Apr 17 16:58:40 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6454" docExpressionCount="655" docLength="7542" length="1" offset="2549" starttimestamp="1650226882502" timestamp="2237981">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="724" _type="Insert" date="Sun Apr 17 16:58:40 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6455" docExpressionCount="655" docLength="7543" length="1" offset="2550" starttimestamp="1650226882502" timestamp="2238246">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="726" _type="Insert" date="Sun Apr 17 16:58:40 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6456" docExpressionCount="655" docLength="7544" length="1" offset="2551" starttimestamp="1650226882502" timestamp="2238346">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="728" _type="Insert" date="Sun Apr 17 16:58:40 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6457" docExpressionCount="655" docLength="7545" length="1" offset="2552" starttimestamp="1650226882502" timestamp="2238444">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="730" _type="Insert" date="Sun Apr 17 16:58:41 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6458" docExpressionCount="655" docLength="7546" length="1" offset="2553" starttimestamp="1650226882502" timestamp="2238714">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="732" _type="Insert" date="Sun Apr 17 16:58:41 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6459" docExpressionCount="655" docLength="7547" length="1" offset="2554" starttimestamp="1650226882502" timestamp="2238949">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="734" _type="Insert" date="Sun Apr 17 16:58:41 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6460" docExpressionCount="655" docLength="7548" length="1" offset="2555" starttimestamp="1650226882502" timestamp="2239209">
    <text><![CDATA[P]]></text>
  </DocumentChange>
  <DocumentChange __id="736" _type="Insert" date="Sun Apr 17 16:58:41 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6461" docExpressionCount="655" docLength="7549" length="1" offset="2556" starttimestamp="1650226882502" timestamp="2239393">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="738" _type="Insert" date="Sun Apr 17 16:58:41 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6462" docExpressionCount="655" docLength="7550" length="1" offset="2557" starttimestamp="1650226882502" timestamp="2239476">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="740" _type="Insert" date="Sun Apr 17 16:58:42 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6463" docExpressionCount="655" docLength="7551" length="1" offset="2558" starttimestamp="1650226882502" timestamp="2239660">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="742" _type="Insert" date="Sun Apr 17 16:58:42 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6464" docExpressionCount="655" docLength="7552" length="1" offset="2559" starttimestamp="1650226882502" timestamp="2239729">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="744" _type="Delete" date="Sun Apr 17 16:58:43 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6463" docExpressionCount="655" docLength="7551" endLine="63" length="1" offset="2559" startLine="63" starttimestamp="1650226882502" timestamp="2240529">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="746" _type="Delete" date="Sun Apr 17 16:58:43 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6462" docExpressionCount="655" docLength="7550" endLine="63" length="1" offset="2558" startLine="63" starttimestamp="1650226882502" timestamp="2240646">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="748" _type="Insert" date="Sun Apr 17 16:58:43 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6463" docExpressionCount="655" docLength="7551" length="1" offset="2558" starttimestamp="1650226882502" timestamp="2240869">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="750" _type="Insert" date="Sun Apr 17 16:58:43 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6464" docExpressionCount="655" docLength="7552" length="1" offset="2559" starttimestamp="1650226882502" timestamp="2240939">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="752" _type="Insert" date="Sun Apr 17 16:58:43 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6465" docExpressionCount="655" docLength="7553" length="1" offset="2560" starttimestamp="1650226882502" timestamp="2241030">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="753" _type="InsertStringCommand" date="Sun Apr 17 16:58:43 EDT 2022" starttimestamp="1650226882502" timestamp="2241039" timestamp2="2241039">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="754" _type="Insert" date="Sun Apr 17 16:58:43 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6466" docExpressionCount="655" docLength="7554" length="1" offset="2561" starttimestamp="1650226882502" timestamp="2241082">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="755" _type="InsertStringCommand" date="Sun Apr 17 16:58:43 EDT 2022" starttimestamp="1650226882502" timestamp="2241086" timestamp2="2241086">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="756" _type="Insert" date="Sun Apr 17 16:58:43 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6467" docExpressionCount="655" docLength="7555" length="1" offset="2562" starttimestamp="1650226882502" timestamp="2241185">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="757" _type="InsertStringCommand" date="Sun Apr 17 16:58:43 EDT 2022" starttimestamp="1650226882502" timestamp="2241188" timestamp2="2241188">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="758" _type="Insert" date="Sun Apr 17 16:58:45 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6468" docExpressionCount="655" docLength="7556" length="1" offset="2563" starttimestamp="1650226882502" timestamp="2242689">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="759" _type="InsertStringCommand" date="Sun Apr 17 16:58:45 EDT 2022" starttimestamp="1650226882502" timestamp="2242692" timestamp2="2242692">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="760" _type="Insert" date="Sun Apr 17 16:58:45 EDT 2022" docASTNodeCount="1070" docActiveCodeLength="6469" docExpressionCount="656" docLength="7557" length="1" offset="2564" starttimestamp="1650226882502" timestamp="2242813">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="761" _type="InsertStringCommand" date="Sun Apr 17 16:58:45 EDT 2022" starttimestamp="1650226882502" timestamp="2242816" timestamp2="2242816">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="762" _type="Insert" date="Sun Apr 17 16:58:45 EDT 2022" docASTNodeCount="1070" docActiveCodeLength="6470" docExpressionCount="656" docLength="7558" length="1" offset="2565" starttimestamp="1650226882502" timestamp="2242994">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="763" _type="InsertStringCommand" date="Sun Apr 17 16:58:45 EDT 2022" starttimestamp="1650226882502" timestamp="2242997" timestamp2="2242997">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="764" _type="Insert" date="Sun Apr 17 16:58:45 EDT 2022" docASTNodeCount="1070" docActiveCodeLength="6471" docExpressionCount="656" docLength="7559" length="1" offset="2566" starttimestamp="1650226882502" timestamp="2243157">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="765" _type="InsertStringCommand" date="Sun Apr 17 16:58:45 EDT 2022" starttimestamp="1650226882502" timestamp="2243160" timestamp2="2243160">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="766" _type="Insert" date="Sun Apr 17 16:58:45 EDT 2022" docASTNodeCount="1070" docActiveCodeLength="6472" docExpressionCount="656" docLength="7560" length="1" offset="2567" starttimestamp="1650226882502" timestamp="2243405">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="767" _type="InsertStringCommand" date="Sun Apr 17 16:58:45 EDT 2022" starttimestamp="1650226882502" timestamp="2243408" timestamp2="2243408">
    <data><![CDATA[=]]></data>
  </Command>
  <DocumentChange __id="768" _type="Insert" date="Sun Apr 17 16:58:46 EDT 2022" docASTNodeCount="1070" docActiveCodeLength="6473" docExpressionCount="656" docLength="7561" length="1" offset="2568" starttimestamp="1650226882502" timestamp="2243553">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="769" _type="InsertStringCommand" date="Sun Apr 17 16:58:46 EDT 2022" starttimestamp="1650226882502" timestamp="2243556" timestamp2="2243556">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="770" _type="Insert" date="Sun Apr 17 16:58:46 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6474" docExpressionCount="657" docLength="7562" length="1" offset="2569" starttimestamp="1650226882502" timestamp="2243865">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="771" _type="InsertStringCommand" date="Sun Apr 17 16:58:46 EDT 2022" starttimestamp="1650226882502" timestamp="2243868" timestamp2="2243868">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="772" _type="Insert" date="Sun Apr 17 16:58:46 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6475" docExpressionCount="657" docLength="7563" length="1" offset="2570" starttimestamp="1650226882502" timestamp="2243959">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="773" _type="InsertStringCommand" date="Sun Apr 17 16:58:46 EDT 2022" starttimestamp="1650226882502" timestamp="2243967" timestamp2="2243967">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="775" _type="InsertStringCommand" date="Sun Apr 17 16:58:46 EDT 2022" starttimestamp="1650226882502" timestamp="2244032" timestamp2="2244032">
    <data><![CDATA[w]]></data>
  </Command>
  <Command __id="776" _type="MoveCaretCommand" caretOffset="2545" date="Sun Apr 17 16:58:50 EDT 2022" docOffset="2545" starttimestamp="1650226882502" timestamp="2247802" />
  <Command __id="777" _type="MoveCaretCommand" caretOffset="2071" date="Sun Apr 17 16:59:09 EDT 2022" docOffset="2071" starttimestamp="1650226882502" timestamp="2267082" />
  <Command __id="778" _type="MoveCaretCommand" caretOffset="2069" date="Sun Apr 17 16:59:10 EDT 2022" docOffset="2069" starttimestamp="1650226882502" timestamp="2267610" />
  <Command __id="780" _type="InsertStringCommand" date="Sun Apr 17 16:59:10 EDT 2022" starttimestamp="1650226882502" timestamp="2268143" timestamp2="2268143">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="782" _type="InsertStringCommand" date="Sun Apr 17 16:59:11 EDT 2022" starttimestamp="1650226882502" timestamp="2268839" timestamp2="2268839">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="784" _type="InsertStringCommand" date="Sun Apr 17 16:59:11 EDT 2022" starttimestamp="1650226882502" timestamp="2268940" timestamp2="2268940">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="786" _type="InsertStringCommand" date="Sun Apr 17 16:59:11 EDT 2022" starttimestamp="1650226882502" timestamp="2269080" timestamp2="2269080">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="788" _type="InsertStringCommand" date="Sun Apr 17 16:59:11 EDT 2022" starttimestamp="1650226882502" timestamp="2269224" timestamp2="2269224">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="790" _type="InsertStringCommand" date="Sun Apr 17 16:59:12 EDT 2022" starttimestamp="1650226882502" timestamp="2269512" timestamp2="2269512">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="792" _type="InsertStringCommand" date="Sun Apr 17 16:59:12 EDT 2022" starttimestamp="1650226882502" timestamp="2269716" timestamp2="2269716">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="794" _type="InsertStringCommand" date="Sun Apr 17 16:59:12 EDT 2022" starttimestamp="1650226882502" timestamp="2269818" timestamp2="2269818">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="796" _type="InsertStringCommand" date="Sun Apr 17 16:59:12 EDT 2022" starttimestamp="1650226882502" timestamp="2270200" timestamp2="2270200">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="798" _type="InsertStringCommand" date="Sun Apr 17 16:59:12 EDT 2022" starttimestamp="1650226882502" timestamp="2270296" timestamp2="2270296">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="800" _type="InsertStringCommand" date="Sun Apr 17 16:59:12 EDT 2022" starttimestamp="1650226882502" timestamp="2270464" timestamp2="2270464">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="802" _type="InsertStringCommand" date="Sun Apr 17 16:59:13 EDT 2022" starttimestamp="1650226882502" timestamp="2270528" timestamp2="2270528">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="804" _type="InsertStringCommand" date="Sun Apr 17 16:59:13 EDT 2022" starttimestamp="1650226882502" timestamp="2271016" timestamp2="2271016">
    <data><![CDATA[J]]></data>
  </Command>
  <Command __id="806" _type="InsertStringCommand" date="Sun Apr 17 16:59:13 EDT 2022" starttimestamp="1650226882502" timestamp="2271318" timestamp2="2271318">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="808" _type="InsertStringCommand" date="Sun Apr 17 16:59:13 EDT 2022" starttimestamp="1650226882502" timestamp="2271464" timestamp2="2271464">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="810" _type="InsertStringCommand" date="Sun Apr 17 16:59:14 EDT 2022" starttimestamp="1650226882502" timestamp="2271543" timestamp2="2271543">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="812" _type="InsertStringCommand" date="Sun Apr 17 16:59:14 EDT 2022" starttimestamp="1650226882502" timestamp="2271832" timestamp2="2271832">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="813" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 16:59:14 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="2271834" />
  <DocumentChange __id="774" _type="Insert" date="Sun Apr 17 16:58:46 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6476" docExpressionCount="654" docLength="7564" length="1" offset="2571" starttimestamp="1650226882502" timestamp="2244023">
    <text><![CDATA[w]]></text>
  </DocumentChange>
  <DocumentChange __id="779" _type="Insert" date="Sun Apr 17 16:59:10 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6478" docExpressionCount="654" docLength="7566" length="2" offset="2069" starttimestamp="1650226882502" timestamp="2268139">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="781" _type="Insert" date="Sun Apr 17 16:59:11 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6479" docExpressionCount="654" docLength="7567" length="1" offset="2071" starttimestamp="1650226882502" timestamp="2268837">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="783" _type="Insert" date="Sun Apr 17 16:59:11 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6480" docExpressionCount="654" docLength="7568" length="1" offset="2072" starttimestamp="1650226882502" timestamp="2268937">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="785" _type="Insert" date="Sun Apr 17 16:59:11 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6481" docExpressionCount="654" docLength="7569" length="1" offset="2073" starttimestamp="1650226882502" timestamp="2269072">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="787" _type="Insert" date="Sun Apr 17 16:59:11 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6482" docExpressionCount="654" docLength="7570" length="1" offset="2074" starttimestamp="1650226882502" timestamp="2269222">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="789" _type="Insert" date="Sun Apr 17 16:59:12 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6483" docExpressionCount="654" docLength="7571" length="1" offset="2075" starttimestamp="1650226882502" timestamp="2269509">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="791" _type="Insert" date="Sun Apr 17 16:59:12 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6484" docExpressionCount="654" docLength="7572" length="1" offset="2076" starttimestamp="1650226882502" timestamp="2269712">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="793" _type="Insert" date="Sun Apr 17 16:59:12 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6485" docExpressionCount="654" docLength="7573" length="1" offset="2077" starttimestamp="1650226882502" timestamp="2269814">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="795" _type="Insert" date="Sun Apr 17 16:59:12 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6486" docExpressionCount="655" docLength="7574" length="1" offset="2078" starttimestamp="1650226882502" timestamp="2270198">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="797" _type="Insert" date="Sun Apr 17 16:59:12 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6487" docExpressionCount="655" docLength="7575" length="1" offset="2079" starttimestamp="1650226882502" timestamp="2270288">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="799" _type="Insert" date="Sun Apr 17 16:59:12 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6488" docExpressionCount="655" docLength="7576" length="1" offset="2080" starttimestamp="1650226882502" timestamp="2270462">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="801" _type="Insert" date="Sun Apr 17 16:59:13 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6489" docExpressionCount="655" docLength="7577" length="1" offset="2081" starttimestamp="1650226882502" timestamp="2270526">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="803" _type="Insert" date="Sun Apr 17 16:59:13 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6490" docExpressionCount="655" docLength="7578" length="1" offset="2082" starttimestamp="1650226882502" timestamp="2271013">
    <text><![CDATA[J]]></text>
  </DocumentChange>
  <DocumentChange __id="805" _type="Insert" date="Sun Apr 17 16:59:13 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6491" docExpressionCount="655" docLength="7579" length="1" offset="2083" starttimestamp="1650226882502" timestamp="2271315">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="807" _type="Insert" date="Sun Apr 17 16:59:13 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6492" docExpressionCount="655" docLength="7580" length="1" offset="2084" starttimestamp="1650226882502" timestamp="2271461">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <DocumentChange __id="809" _type="Insert" date="Sun Apr 17 16:59:14 EDT 2022" docASTNodeCount="1067" docActiveCodeLength="6493" docExpressionCount="655" docLength="7581" length="1" offset="2085" starttimestamp="1650226882502" timestamp="2271538">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="811" _type="Insert" date="Sun Apr 17 16:59:14 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6494" docExpressionCount="654" docLength="7582" length="1" offset="2086" starttimestamp="1650226882502" timestamp="2271830">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="814" _type="Insert" date="Sun Apr 17 16:59:14 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6495" docExpressionCount="657" docLength="7583" length="1" offset="2087" starttimestamp="1650226882502" timestamp="2272482">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="816" _type="Replace" date="Sun Apr 17 16:59:16 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6514" docExpressionCount="657" docLength="7602" endLine="46" insertionLength="29" int_docASTNodeCount="1065" int_docActiveCodeLength="6485" int_docExpressionCount="654" int_docLength="7573" length="10" offset="2078" startLine="46" starttimestamp="1650226882502" timestamp="2273569">
    <deletedText><![CDATA[miniJava.s]]></deletedText>
    <insertedText><![CDATA[miniJava.SyntacticAnalyzer.*;]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="818" _type="Delete" date="Sun Apr 17 16:59:16 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6513" docExpressionCount="657" docLength="7601" endLine="46" length="1" offset="2106" startLine="46" starttimestamp="1650226882502" timestamp="2274397">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="820" _type="Delete" date="Sun Apr 17 16:59:17 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6512" docExpressionCount="654" docLength="7600" endLine="46" length="1" offset="2105" startLine="46" starttimestamp="1650226882502" timestamp="2274592">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="815" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 16:59:16 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="2273564" />
  <Command __id="817" _type="InsertStringCommand" date="Sun Apr 17 16:59:16 EDT 2022" starttimestamp="1650226882502" timestamp="2273574" timestamp2="2273574">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="819" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:59:16 EDT 2022" starttimestamp="1650226882502" timestamp="2274399" />
  <Command __id="821" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:59:17 EDT 2022" starttimestamp="1650226882502" timestamp="2274596" />
  <Command __id="823" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:59:18 EDT 2022" starttimestamp="1650226882502" timestamp="2275927" />
  <Command __id="825" _type="InsertStringCommand" date="Sun Apr 17 16:59:19 EDT 2022" starttimestamp="1650226882502" timestamp="2276587" timestamp2="2276587">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="826" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 16:59:19 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="2276589" />
  <Command __id="829" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 16:59:21 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="2278570" />
  <Command __id="831" _type="InsertStringCommand" date="Sun Apr 17 16:59:21 EDT 2022" starttimestamp="1650226882502" timestamp="2278581" timestamp2="2278581">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="833" _type="InsertStringCommand" date="Sun Apr 17 16:59:21 EDT 2022" starttimestamp="1650226882502" timestamp="2278904" timestamp2="2278904">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="835" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:59:21 EDT 2022" starttimestamp="1650226882502" timestamp="2279390" />
  <DocumentChange __id="822" _type="Delete" date="Sun Apr 17 16:59:18 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6511" docExpressionCount="657" docLength="7599" endLine="46" length="1" offset="2104" startLine="46" starttimestamp="1650226882502" timestamp="2275924">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="824" _type="Insert" date="Sun Apr 17 16:59:19 EDT 2022" docASTNodeCount="1065" docActiveCodeLength="6512" docExpressionCount="654" docLength="7600" length="1" offset="2104" starttimestamp="1650226882502" timestamp="2276585">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="827" _type="Insert" date="Sun Apr 17 16:59:19 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6513" docExpressionCount="659" docLength="7601" length="1" offset="2105" starttimestamp="1650226882502" timestamp="2277186">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="828" _type="Insert" date="Sun Apr 17 16:59:20 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6514" docExpressionCount="659" docLength="7602" length="1" offset="2106" starttimestamp="1650226882502" timestamp="2278157">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="830" _type="Replace" date="Sun Apr 17 16:59:21 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6527" docExpressionCount="659" docLength="7615" endLine="46" insertionLength="15" int_docASTNodeCount="1065" int_docActiveCodeLength="6512" int_docExpressionCount="654" int_docLength="7600" length="2" offset="2105" startLine="46" starttimestamp="1650226882502" timestamp="2278575">
    <deletedText><![CDATA[so]]></deletedText>
    <insertedText><![CDATA[SourcePosition;]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="832" _type="Insert" date="Sun Apr 17 16:59:21 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6528" docExpressionCount="659" docLength="7616" length="1" offset="2120" starttimestamp="1650226882502" timestamp="2278899">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="834" _type="Delete" date="Sun Apr 17 16:59:21 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6527" docExpressionCount="659" docLength="7615" endLine="46" length="1" offset="2120" startLine="46" starttimestamp="1650226882502" timestamp="2279389">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="837" _type="Insert" date="Sun Apr 17 16:59:29 EDT 2022" docASTNodeCount="1071" docActiveCodeLength="6528" docExpressionCount="659" docLength="7616" length="1" offset="2623" starttimestamp="1650226882502" timestamp="2287125">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="839" _type="Insert" date="Sun Apr 17 16:59:30 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6529" docExpressionCount="663" docLength="7617" length="1" offset="2624" starttimestamp="1650226882502" timestamp="2287553">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="841" _type="Insert" date="Sun Apr 17 16:59:30 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6530" docExpressionCount="663" docLength="7618" length="1" offset="2625" starttimestamp="1650226882502" timestamp="2287765">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="843" _type="Insert" date="Sun Apr 17 16:59:30 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6531" docExpressionCount="663" docLength="7619" length="1" offset="2626" starttimestamp="1650226882502" timestamp="2287870">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="845" _type="Insert" date="Sun Apr 17 16:59:30 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6532" docExpressionCount="663" docLength="7620" length="1" offset="2627" starttimestamp="1650226882502" timestamp="2287947">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="847" _type="Insert" date="Sun Apr 17 16:59:30 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6533" docExpressionCount="663" docLength="7621" length="1" offset="2628" starttimestamp="1650226882502" timestamp="2288197">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="849" _type="Insert" date="Sun Apr 17 16:59:30 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6534" docExpressionCount="663" docLength="7622" length="1" offset="2629" starttimestamp="1650226882502" timestamp="2288375">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="851" _type="Insert" date="Sun Apr 17 16:59:31 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6535" docExpressionCount="663" docLength="7623" length="1" offset="2630" starttimestamp="1650226882502" timestamp="2289090">
    <text><![CDATA[P]]></text>
  </DocumentChange>
  <DocumentChange __id="853" _type="Insert" date="Sun Apr 17 16:59:31 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6536" docExpressionCount="663" docLength="7624" length="1" offset="2631" starttimestamp="1650226882502" timestamp="2289347">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="855" _type="Insert" date="Sun Apr 17 16:59:32 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6537" docExpressionCount="663" docLength="7625" length="1" offset="2632" starttimestamp="1650226882502" timestamp="2289643">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="857" _type="Insert" date="Sun Apr 17 16:59:32 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6538" docExpressionCount="663" docLength="7626" length="1" offset="2633" starttimestamp="1650226882502" timestamp="2289854">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="859" _type="Insert" date="Sun Apr 17 16:59:32 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6539" docExpressionCount="663" docLength="7627" length="1" offset="2634" starttimestamp="1650226882502" timestamp="2290061">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="861" _type="Insert" date="Sun Apr 17 16:59:32 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6540" docExpressionCount="663" docLength="7628" length="1" offset="2635" starttimestamp="1650226882502" timestamp="2290097">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="863" _type="Insert" date="Sun Apr 17 16:59:32 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6541" docExpressionCount="663" docLength="7629" length="1" offset="2636" starttimestamp="1650226882502" timestamp="2290182">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="865" _type="Insert" date="Sun Apr 17 16:59:32 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6542" docExpressionCount="663" docLength="7630" length="1" offset="2637" starttimestamp="1650226882502" timestamp="2290285">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="867" _type="Insert" date="Sun Apr 17 16:59:33 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6544" docExpressionCount="663" docLength="7632" length="2" offset="2638" starttimestamp="1650226882502" timestamp="2291095">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="870" _type="Insert" date="Sun Apr 17 16:59:34 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6545" docExpressionCount="663" docLength="7633" length="1" offset="2640" starttimestamp="1650226882502" timestamp="2292269">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="873" _type="Insert" date="Sun Apr 17 16:59:36 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6546" docExpressionCount="663" docLength="7634" length="1" offset="2640" starttimestamp="1650226882502" timestamp="2293843">
    <text><![CDATA[0]]></text>
  </DocumentChange>
  <DocumentChange __id="875" _type="Delete" date="Sun Apr 17 16:59:36 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6545" docExpressionCount="663" docLength="7633" endLine="64" length="1" offset="2640" startLine="64" starttimestamp="1650226882502" timestamp="2294477">
    <text><![CDATA[0]]></text>
  </DocumentChange>
  <DocumentChange __id="878" _type="Insert" date="Sun Apr 17 16:59:38 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6546" docExpressionCount="664" docLength="7634" length="1" offset="2639" starttimestamp="1650226882502" timestamp="2295516">
    <text><![CDATA[0]]></text>
  </DocumentChange>
  <Command __id="836" _type="MoveCaretCommand" caretOffset="2623" date="Sun Apr 17 16:59:28 EDT 2022" docOffset="2623" starttimestamp="1650226882502" timestamp="2286298" />
  <Command __id="838" _type="InsertStringCommand" date="Sun Apr 17 16:59:29 EDT 2022" starttimestamp="1650226882502" timestamp="2287127" timestamp2="2287127">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="840" _type="InsertStringCommand" date="Sun Apr 17 16:59:30 EDT 2022" starttimestamp="1650226882502" timestamp="2287556" timestamp2="2287556">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="842" _type="InsertStringCommand" date="Sun Apr 17 16:59:30 EDT 2022" starttimestamp="1650226882502" timestamp="2287768" timestamp2="2287768">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="844" _type="InsertStringCommand" date="Sun Apr 17 16:59:30 EDT 2022" starttimestamp="1650226882502" timestamp="2287873" timestamp2="2287873">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="846" _type="InsertStringCommand" date="Sun Apr 17 16:59:30 EDT 2022" starttimestamp="1650226882502" timestamp="2287954" timestamp2="2287954">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="848" _type="InsertStringCommand" date="Sun Apr 17 16:59:30 EDT 2022" starttimestamp="1650226882502" timestamp="2288200" timestamp2="2288200">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="850" _type="InsertStringCommand" date="Sun Apr 17 16:59:30 EDT 2022" starttimestamp="1650226882502" timestamp="2288383" timestamp2="2288383">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="852" _type="InsertStringCommand" date="Sun Apr 17 16:59:31 EDT 2022" starttimestamp="1650226882502" timestamp="2289094" timestamp2="2289094">
    <data><![CDATA[P]]></data>
  </Command>
  <Command __id="854" _type="InsertStringCommand" date="Sun Apr 17 16:59:31 EDT 2022" starttimestamp="1650226882502" timestamp="2289352" timestamp2="2289352">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="856" _type="InsertStringCommand" date="Sun Apr 17 16:59:32 EDT 2022" starttimestamp="1650226882502" timestamp="2289647" timestamp2="2289647">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="858" _type="InsertStringCommand" date="Sun Apr 17 16:59:32 EDT 2022" starttimestamp="1650226882502" timestamp="2289863" timestamp2="2289863">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="860" _type="InsertStringCommand" date="Sun Apr 17 16:59:32 EDT 2022" starttimestamp="1650226882502" timestamp="2290064" timestamp2="2290064">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="862" _type="InsertStringCommand" date="Sun Apr 17 16:59:32 EDT 2022" starttimestamp="1650226882502" timestamp="2290101" timestamp2="2290101">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="864" _type="InsertStringCommand" date="Sun Apr 17 16:59:32 EDT 2022" starttimestamp="1650226882502" timestamp="2290191" timestamp2="2290191">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="866" _type="InsertStringCommand" date="Sun Apr 17 16:59:32 EDT 2022" starttimestamp="1650226882502" timestamp="2290290" timestamp2="2290290">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="868" _type="InsertStringCommand" date="Sun Apr 17 16:59:33 EDT 2022" starttimestamp="1650226882502" timestamp="2291099" timestamp2="2291099">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="869" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 16:59:34 EDT 2022" starttimestamp="1650226882502" timestamp="2291562" />
  <Command __id="871" _type="InsertStringCommand" date="Sun Apr 17 16:59:34 EDT 2022" starttimestamp="1650226882502" timestamp="2292279" timestamp2="2292279">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="872" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_PREVIOUS" date="Sun Apr 17 16:59:35 EDT 2022" starttimestamp="1650226882502" timestamp="2292749" />
  <Command __id="874" _type="InsertStringCommand" date="Sun Apr 17 16:59:36 EDT 2022" starttimestamp="1650226882502" timestamp="2293850" timestamp2="2293850">
    <data><![CDATA[0]]></data>
  </Command>
  <Command __id="876" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 16:59:36 EDT 2022" starttimestamp="1650226882502" timestamp="2294479" />
  <Command __id="877" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_PREVIOUS" date="Sun Apr 17 16:59:37 EDT 2022" starttimestamp="1650226882502" timestamp="2294793" />
  <Command __id="879" _type="InsertStringCommand" date="Sun Apr 17 16:59:38 EDT 2022" starttimestamp="1650226882502" timestamp="2295520" timestamp2="2295520">
    <data><![CDATA[0]]></data>
  </Command>
  <Command __id="880" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:59:40 EDT 2022" docASTNodeCount="27" docActiveCodeLength="170" docExpressionCount="12" docLength="170" projectName="pa3" starttimestamp="1650226882502" timestamp="2298141">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\SourcePosition.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

public class SourcePosition {
	public int lineNum;
	public void SourcePosition(int lineNum) {
		this.lineNum = lineNum;
	}
}
]]></snapshot>
  </Command>
  <Command __id="881" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 16:59:40 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="2298274" />
  <Command __id="882" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:59:44 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6546" docExpressionCount="664" docLength="7634" projectName="pa3" starttimestamp="1650226882502" timestamp="2302071">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;"), Diff(INSERT,"¶import miniJava.SyntacticAnalyzer.SourcePosition;"), Diff(EQUAL,"¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		"), Diff(INSERT,"SourcePosition sp = new SourcePosition(0);¶		"), Diff(EQUAL,"¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="883" _type="MoveCaretCommand" caretOffset="2640" date="Sun Apr 17 16:59:44 EDT 2022" docOffset="2640" starttimestamp="1650226882502" timestamp="2302183" />
  <Command __id="884" _type="MoveCaretCommand" caretOffset="2697" date="Sun Apr 17 16:59:45 EDT 2022" docOffset="2697" starttimestamp="1650226882502" timestamp="2302834" />
  <Command __id="885" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 16:59:45 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2303082" />
  <Command __id="886" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 16:59:46 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2303530" />
  <Command __id="887" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 16:59:52 EDT 2022" docASTNodeCount="27" docActiveCodeLength="170" docExpressionCount="12" docLength="170" projectName="pa3" starttimestamp="1650226882502" timestamp="2310246">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\SourcePosition.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶public class SourcePosition {¶	public int lineNum;¶	public void SourcePosition(int lineNum) {¶		this.lineNum = lineNum;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="888" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 16:59:52 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="2310359" />
  <Command __id="890" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:00:01 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2319243" />
  <Command __id="889" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:01 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6546" docExpressionCount="664" docLength="7634" projectName="pa3" starttimestamp="1650226882502" timestamp="2319124">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="891" _type="ShellCommand" date="Sun Apr 17 17:00:03 EDT 2022" starttimestamp="1650226882502" timestamp="2321111" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="892" _type="ShellCommand" date="Sun Apr 17 17:00:03 EDT 2022" starttimestamp="1650226882502" timestamp="2321195" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="893" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:07 EDT 2022" docASTNodeCount="27" docActiveCodeLength="170" docExpressionCount="12" docLength="170" projectName="pa3" starttimestamp="1650226882502" timestamp="2325040">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\SourcePosition.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶public class SourcePosition {¶	public int lineNum;¶	public void SourcePosition(int lineNum) {¶		this.lineNum = lineNum;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="894" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 17:00:07 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="2325170" />
  <Command __id="896" _type="MoveCaretCommand" caretOffset="2645" date="Sun Apr 17 17:00:15 EDT 2022" docOffset="2645" starttimestamp="1650226882502" timestamp="2332776" />
  <Command __id="897" _type="MoveCaretCommand" caretOffset="2639" date="Sun Apr 17 17:00:16 EDT 2022" docOffset="2639" starttimestamp="1650226882502" timestamp="2334490" />
  <Command __id="898" _type="InsertStringCommand" date="Sun Apr 17 17:00:18 EDT 2022" starttimestamp="1650226882502" timestamp="2335581" timestamp2="2335581">
    <data><![CDATA[0]]></data>
  </Command>
  <Command __id="899" _type="MoveCaretCommand" caretOffset="2570" date="Sun Apr 17 17:00:23 EDT 2022" docOffset="2570" starttimestamp="1650226882502" timestamp="2341138" />
  <Command __id="900" _type="ShellCommand" date="Sun Apr 17 17:00:25 EDT 2022" starttimestamp="1650226882502" timestamp="2343224" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="901" _type="ShellCommand" date="Sun Apr 17 17:00:25 EDT 2022" starttimestamp="1650226882502" timestamp="2343309" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="914" _type="SelectTextCommand" caretOffset="99" date="Sun Apr 17 17:00:26 EDT 2022" end="99" start="93" starttimestamp="1650226882502" timestamp="2343779" />
  <Command __id="895" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:15 EDT 2022" docASTNodeCount="1079" docActiveCodeLength="6545" docExpressionCount="663" docLength="7633" projectName="pa3" starttimestamp="1650226882502" timestamp="2332650">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition("), Diff(DELETE,"0"), Diff(EQUAL,");¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition();
		
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="902" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="27" docActiveCodeLength="170" docExpressionCount="12" docLength="170" projectName="pa3" starttimestamp="1650226882502" timestamp="2343555">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\SourcePosition.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶public class SourcePosition {¶	public int lineNum;¶	public void SourcePosition(int lineNum) {¶		this.lineNum = lineNum;¶	}¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="903" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="27" docActiveCodeLength="173" docExpressionCount="12" docLength="173" length="3" offset="93" starttimestamp="1650226882502" timestamp="2343630">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="904" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="29" docActiveCodeLength="177" docExpressionCount="12" docLength="177" length="4" offset="93" starttimestamp="1650226882502" timestamp="2343631">
    <text><![CDATA[
	}]]></text>
  </DocumentChange>
  <DocumentChange __id="905" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="29" docActiveCodeLength="177" docExpressionCount="12" docLength="216" length="39" offset="93" starttimestamp="1650226882502" timestamp="2343632">
    <text><![CDATA[// TODO Auto-generated constructor stub]]></text>
  </DocumentChange>
  <DocumentChange __id="906" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="29" docActiveCodeLength="184" docExpressionCount="12" docLength="223" length="7" offset="93" starttimestamp="1650226882502" timestamp="2343634">
    <text><![CDATA[) {
		]]></text>
  </DocumentChange>
  <DocumentChange __id="907" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="29" docActiveCodeLength="185" docExpressionCount="12" docLength="224" length="1" offset="93" starttimestamp="1650226882502" timestamp="2343635">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="908" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="29" docActiveCodeLength="186" docExpressionCount="12" docLength="225" length="1" offset="93" starttimestamp="1650226882502" timestamp="2343637">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="909" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="33" docActiveCodeLength="189" docExpressionCount="13" docLength="228" length="3" offset="93" starttimestamp="1650226882502" timestamp="2343639">
    <text><![CDATA[int]]></text>
  </DocumentChange>
  <DocumentChange __id="910" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="33" docActiveCodeLength="190" docExpressionCount="13" docLength="229" length="1" offset="93" starttimestamp="1650226882502" timestamp="2343641">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="911" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="33" docActiveCodeLength="204" docExpressionCount="14" docLength="243" length="14" offset="93" starttimestamp="1650226882502" timestamp="2343643">
    <text><![CDATA[SourcePosition]]></text>
  </DocumentChange>
  <DocumentChange __id="912" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="33" docActiveCodeLength="205" docExpressionCount="14" docLength="244" length="1" offset="93" starttimestamp="1650226882502" timestamp="2343644">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="913" _type="Insert" date="Sun Apr 17 17:00:26 EDT 2022" docASTNodeCount="34" docActiveCodeLength="211" docExpressionCount="14" docLength="250" length="6" offset="93" starttimestamp="1650226882502" timestamp="2343646">
    <text><![CDATA[public]]></text>
  </DocumentChange>
  <Command __id="915" _type="MoveCaretCommand" caretOffset="123" date="Sun Apr 17 17:00:27 EDT 2022" docOffset="123" starttimestamp="1650226882502" timestamp="2345066" />
  <DocumentChange __id="916" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="33" docActiveCodeLength="205" docExpressionCount="14" docLength="244" endLine="4" length="6" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353742">
    <text><![CDATA[public]]></text>
  </DocumentChange>
  <DocumentChange __id="917" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="33" docActiveCodeLength="204" docExpressionCount="14" docLength="243" endLine="4" length="1" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353744">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="918" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="33" docActiveCodeLength="190" docExpressionCount="13" docLength="229" endLine="4" length="14" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353747">
    <text><![CDATA[SourcePosition]]></text>
  </DocumentChange>
  <DocumentChange __id="919" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="33" docActiveCodeLength="189" docExpressionCount="13" docLength="228" endLine="4" length="1" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353749">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="920" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="29" docActiveCodeLength="186" docExpressionCount="12" docLength="225" endLine="4" length="3" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353751">
    <text><![CDATA[int]]></text>
  </DocumentChange>
  <DocumentChange __id="921" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="29" docActiveCodeLength="185" docExpressionCount="12" docLength="224" endLine="4" length="1" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353752">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="922" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="29" docActiveCodeLength="184" docExpressionCount="12" docLength="223" endLine="4" length="1" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353754">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="923" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="29" docActiveCodeLength="177" docExpressionCount="12" docLength="216" endLine="5" length="7" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353756">
    <text><![CDATA[) {
		]]></text>
  </DocumentChange>
  <DocumentChange __id="924" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="29" docActiveCodeLength="177" docExpressionCount="12" docLength="177" endLine="4" length="39" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353758">
    <text><![CDATA[// TODO Auto-generated constructor stub]]></text>
  </DocumentChange>
  <DocumentChange __id="925" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="27" docActiveCodeLength="173" docExpressionCount="12" docLength="173" endLine="5" length="4" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353763">
    <text><![CDATA[
	}]]></text>
  </DocumentChange>
  <DocumentChange __id="926" _type="Delete" date="Sun Apr 17 17:00:36 EDT 2022" docASTNodeCount="27" docActiveCodeLength="170" docExpressionCount="12" docLength="170" endLine="5" length="3" offset="93" startLine="4" starttimestamp="1650226882502" timestamp="2353767">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="927" _type="UndoCommand" date="Sun Apr 17 17:00:36 EDT 2022" starttimestamp="1650226882502" timestamp="2353775" />
  <Command __id="928" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:39 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="2356683">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="929" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 17:00:39 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="2356737" />
  <Command __id="930" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:39 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="2357097">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="931" _type="MoveCaretCommand" caretOffset="1360" date="Sun Apr 17 17:00:39 EDT 2022" docOffset="1360" starttimestamp="1650226882502" timestamp="2357150" />
  <Command __id="933" _type="MoveCaretCommand" caretOffset="2570" date="Sun Apr 17 17:00:43 EDT 2022" docOffset="2570" starttimestamp="1650226882502" timestamp="2360970" />
  <Command __id="934" _type="MoveCaretCommand" caretOffset="2640" date="Sun Apr 17 17:00:44 EDT 2022" docOffset="2640" starttimestamp="1650226882502" timestamp="2361954" />
  <Command __id="935" _type="MoveCaretCommand" caretOffset="2640" date="Sun Apr 17 17:00:44 EDT 2022" docOffset="2640" starttimestamp="1650226882502" timestamp="2361954" />
  <Command __id="936" _type="MoveCaretCommand" caretOffset="2625" date="Sun Apr 17 17:00:44 EDT 2022" docOffset="2625" starttimestamp="1650226882502" timestamp="2362314" />
  <Command __id="937" _type="MoveCaretCommand" caretOffset="2625" date="Sun Apr 17 17:00:44 EDT 2022" docOffset="2625" starttimestamp="1650226882502" timestamp="2362314" />
  <Command __id="932" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:43 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6546" docExpressionCount="664" docLength="7634" projectName="pa3" starttimestamp="1650226882502" timestamp="2360914">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition("), Diff(INSERT,"0"), Diff(EQUAL,");¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="938" _type="SelectTextCommand" caretOffset="2600" date="Sun Apr 17 17:00:49 EDT 2022" end="2624" start="2600" starttimestamp="1650226882502" timestamp="2366962" />
  <Command __id="939" _type="SelectTextCommand" caretOffset="2600" date="Sun Apr 17 17:00:49 EDT 2022" end="2624" start="2600" starttimestamp="1650226882502" timestamp="2366963" />
  <Command __id="941" _type="MoveCaretCommand" caretOffset="93" date="Sun Apr 17 17:00:51 EDT 2022" docOffset="93" starttimestamp="1650226882502" timestamp="2368871" />
  <Command __id="942" _type="ShellCommand" date="Sun Apr 17 17:01:15 EDT 2022" starttimestamp="1650226882502" timestamp="2392699" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="940" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:00:51 EDT 2022" docASTNodeCount="27" docActiveCodeLength="170" docExpressionCount="12" docLength="170" projectName="pa3" starttimestamp="1650226882502" timestamp="2368811">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\SourcePosition.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶public class SourcePosition {¶	public int lineNum;¶	public void SourcePosition(int lineNum) {¶		this.lineNum = lineNum;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="943" _type="ShellCommand" date="Sun Apr 17 17:01:32 EDT 2022" starttimestamp="1650226882502" timestamp="2410387" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="944" _type="MoveCaretCommand" caretOffset="102" date="Sun Apr 17 17:01:32 EDT 2022" docOffset="102" starttimestamp="1650226882502" timestamp="2410460" />
  <Command __id="945" _type="SelectTextCommand" caretOffset="104" date="Sun Apr 17 17:01:33 EDT 2022" end="104" start="100" starttimestamp="1650226882502" timestamp="2410602" />
  <DocumentChange __id="946" _type="Delete" date="Sun Apr 17 17:01:38 EDT 2022" docASTNodeCount="26" docActiveCodeLength="166" docExpressionCount="12" docLength="166" endLine="4" length="4" offset="100" startLine="4" starttimestamp="1650226882502" timestamp="2415661">
    <text><![CDATA[void]]></text>
  </DocumentChange>
  <Command __id="947" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:01:38 EDT 2022" starttimestamp="1650226882502" timestamp="2415665" />
  <DocumentChange __id="948" _type="Delete" date="Sun Apr 17 17:01:40 EDT 2022" docASTNodeCount="26" docActiveCodeLength="165" docExpressionCount="12" docLength="165" endLine="4" length="1" offset="99" startLine="4" starttimestamp="1650226882502" timestamp="2418138">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="949" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:01:40 EDT 2022" starttimestamp="1650226882502" timestamp="2418141" />
  <Command __id="950" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Apr 17 17:01:41 EDT 2022" starttimestamp="1650226882502" timestamp="2418550" />
  <Command __id="951" _type="EclipseCommand" commandID="" date="Sun Apr 17 17:01:41 EDT 2022" starttimestamp="1650226882502" timestamp="2418641" />
  <Command __id="952" _type="EclipseCommand" commandID="" date="Sun Apr 17 17:01:41 EDT 2022" starttimestamp="1650226882502" timestamp="2418827" />
  <Command __id="953" _type="MoveCaretCommand" caretOffset="110" date="Sun Apr 17 17:01:41 EDT 2022" docOffset="110" starttimestamp="1650226882502" timestamp="2419386" />
  <Command __id="954" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:01:46 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="2424416">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="955" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 17:01:46 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="2424469" />
  <Command __id="956" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:01:47 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="2425115">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="957" _type="MoveCaretCommand" caretOffset="1360" date="Sun Apr 17 17:01:47 EDT 2022" docOffset="1360" starttimestamp="1650226882502" timestamp="2425171" />
  <Command __id="959" _type="SelectTextCommand" caretOffset="2600" date="Sun Apr 17 17:01:49 EDT 2022" end="2624" start="2600" starttimestamp="1650226882502" timestamp="2427131" />
  <Command __id="960" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:50 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2427922" />
  <Command __id="961" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:50 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2427922" />
  <Command __id="962" _type="MoveCaretCommand" caretOffset="2625" date="Sun Apr 17 17:01:51 EDT 2022" docOffset="2625" starttimestamp="1650226882502" timestamp="2428562" />
  <Command __id="963" _type="MoveCaretCommand" caretOffset="2625" date="Sun Apr 17 17:01:51 EDT 2022" docOffset="2625" starttimestamp="1650226882502" timestamp="2428562" />
  <Command __id="964" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:52 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2430282" />
  <Command __id="965" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:52 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2430282" />
  <Command __id="966" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:53 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2430554" />
  <Command __id="967" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:53 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2430554" />
  <Command __id="968" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:01:53 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="2430978" />
  <Command __id="969" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:01:53 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="2430978" />
  <Command __id="970" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:53 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2431338" />
  <Command __id="971" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:01:53 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2431338" />
  <Command __id="972" _type="ShellCommand" date="Sun Apr 17 17:01:54 EDT 2022" starttimestamp="1650226882502" timestamp="2432367" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="958" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:01:49 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6546" docExpressionCount="664" docLength="7634" projectName="pa3" starttimestamp="1650226882502" timestamp="2427074">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="973" _type="ShellCommand" date="Sun Apr 17 17:03:51 EDT 2022" starttimestamp="1650226882502" timestamp="2548529" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="974" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:03:51 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="2548586" />
  <Command __id="975" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:03:51 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="2548586" />
  <Command __id="976" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:03:51 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2549026" />
  <Command __id="977" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:03:51 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2549026" />
  <Command __id="978" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:03:51 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2549450" />
  <Command __id="979" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:03:51 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2549450" />
  <Command __id="980" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:03:52 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2549970" />
  <Command __id="981" _type="MoveCaretCommand" caretOffset="2646" date="Sun Apr 17 17:03:52 EDT 2022" docOffset="2646" starttimestamp="1650226882502" timestamp="2549970" />
  <Command __id="982" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:03:52 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="2550465" />
  <Command __id="983" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:03:52 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="2550465" />
  <Command __id="984" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:04:15 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="2573153">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="985" _type="MoveCaretCommand" caretOffset="1360" date="Sun Apr 17 17:04:15 EDT 2022" docOffset="1360" starttimestamp="1650226882502" timestamp="2573212" />
  <Command __id="987" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:04:18 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="2576273" />
  <Command __id="988" _type="ShellCommand" date="Sun Apr 17 17:06:37 EDT 2022" starttimestamp="1650226882502" timestamp="2715144" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="986" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:04:18 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6546" docExpressionCount="664" docLength="7634" projectName="pa3" starttimestamp="1650226882502" timestamp="2576209">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="989" _type="ShellCommand" date="Sun Apr 17 17:14:05 EDT 2022" starttimestamp="1650226882502" timestamp="3162816" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="990" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:14:10 EDT 2022" docASTNodeCount="89" docActiveCodeLength="510" docExpressionCount="47" docLength="607" projectName="pa3" starttimestamp="1650226882502" timestamp="3168110">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\ClassDecl.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import  miniJava.SyntacticAnalyzer.SourcePosition;

public class ClassDecl extends Declaration {

  public ClassDecl(String cn, FieldDeclList fdl, MethodDeclList mdl, SourcePosition posn) {
	  super(cn, null, posn);
	  fieldDeclList = fdl;
	  methodDeclList = mdl;
  }
  
  public <A,R> R visit(Visitor<A, R> v, A o) {
      return v.visitClassDecl(this, o);
  }
      
  public FieldDeclList fieldDeclList;
  public MethodDeclList methodDeclList;
}
]]></snapshot>
  </Command>
  <Command __id="991" _type="SelectTextCommand" caretOffset="159" date="Sun Apr 17 17:14:10 EDT 2022" end="159" start="150" starttimestamp="1650226882502" timestamp="3168226" />
  <Command __id="993" _type="MoveCaretCommand" caretOffset="2650" date="Sun Apr 17 17:14:42 EDT 2022" docOffset="2650" starttimestamp="1650226882502" timestamp="3199712" />
  <Command __id="994" _type="InsertStringCommand" date="Sun Apr 17 17:14:57 EDT 2022" starttimestamp="1650226882502" timestamp="3215172" timestamp2="3215172">
    <data><![CDATA[F]]></data>
  </Command>
  <Command __id="995" _type="InsertStringCommand" date="Sun Apr 17 17:14:57 EDT 2022" starttimestamp="1650226882502" timestamp="3215403" timestamp2="3215403">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="996" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:14:59 EDT 2022" starttimestamp="1650226882502" timestamp="3216606" />
  <Command __id="997" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:14:59 EDT 2022" starttimestamp="1650226882502" timestamp="3216838" />
  <Command __id="998" _type="InsertStringCommand" date="Sun Apr 17 17:15:02 EDT 2022" starttimestamp="1650226882502" timestamp="3219567" timestamp2="3219567">
    <data><![CDATA[F]]></data>
  </Command>
  <Command __id="999" _type="InsertStringCommand" date="Sun Apr 17 17:15:02 EDT 2022" starttimestamp="1650226882502" timestamp="3220432" timestamp2="3220432">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1000" _type="InsertStringCommand" date="Sun Apr 17 17:15:03 EDT 2022" starttimestamp="1650226882502" timestamp="3220887" timestamp2="3220887">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1001" _type="InsertStringCommand" date="Sun Apr 17 17:15:03 EDT 2022" starttimestamp="1650226882502" timestamp="3221002" timestamp2="3221002">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="1002" _type="InsertStringCommand" date="Sun Apr 17 17:15:03 EDT 2022" starttimestamp="1650226882502" timestamp="3221319" timestamp2="3221319">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1003" _type="ShellCommand" date="Sun Apr 17 17:15:07 EDT 2022" starttimestamp="1650226882502" timestamp="3224731" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1004" _type="ShellCommand" date="Sun Apr 17 17:15:09 EDT 2022" starttimestamp="1650226882502" timestamp="3227236" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1005" _type="SelectTextCommand" caretOffset="2650" date="Sun Apr 17 17:15:10 EDT 2022" end="2655" start="2650" starttimestamp="1650226882502" timestamp="3227945" />
  <Command __id="1006" _type="SelectTextCommand" caretOffset="2666" date="Sun Apr 17 17:15:13 EDT 2022" end="2670" start="2666" starttimestamp="1650226882502" timestamp="3231113" />
  <Command __id="1007" _type="InsertStringCommand" date="Sun Apr 17 17:15:16 EDT 2022" starttimestamp="1650226882502" timestamp="3233706" timestamp2="3233706">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1008" _type="SelectTextCommand" caretOffset="2711" date="Sun Apr 17 17:15:18 EDT 2022" end="2715" start="2711" starttimestamp="1650226882502" timestamp="3236225" />
  <Command __id="1009" _type="InsertStringCommand" date="Sun Apr 17 17:15:18 EDT 2022" starttimestamp="1650226882502" timestamp="3236246" timestamp2="3236246">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1010" _type="MoveCaretCommand" caretOffset="2726" date="Sun Apr 17 17:15:19 EDT 2022" docOffset="2726" starttimestamp="1650226882502" timestamp="3236925" />
  <Command __id="1011" _type="MoveCaretCommand" caretOffset="2736" date="Sun Apr 17 17:15:20 EDT 2022" docOffset="2736" starttimestamp="1650226882502" timestamp="3237649" />
  <Command __id="1012" _type="InsertStringCommand" date="Sun Apr 17 17:15:20 EDT 2022" starttimestamp="1650226882502" timestamp="3238396" timestamp2="3238396">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1013" _type="ShellCommand" date="Sun Apr 17 17:15:22 EDT 2022" starttimestamp="1650226882502" timestamp="3240345" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="992" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:14:42 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6546" docExpressionCount="664" docLength="7634" projectName="pa3" starttimestamp="1650226882502" timestamp="3199602">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1014" _type="ShellCommand" date="Sun Apr 17 17:16:28 EDT 2022" starttimestamp="1650226882502" timestamp="3305816" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1015" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:16:38 EDT 2022" docASTNodeCount="60" docActiveCodeLength="295" docExpressionCount="32" docLength="399" projectName="pa3" starttimestamp="1650226882502" timestamp="3315777">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Token.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

/**
 *  A token has a kind and a spelling
 *  In a compiler it would also have a source position 
 */
public class Token {
	public TokenKind kind;
	public String spelling;
	public SourcePosition posn;

	public Token(TokenKind kind, String spelling, SourcePosition posn) {
		this.kind = kind;
		this.spelling = spelling;
		this.posn = posn;
	}
}
]]></snapshot>
  </Command>
  <Command __id="1016" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 17:16:38 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="3315877" />
  <Command __id="1017" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:16:54 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="3332162">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="1018" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 17:16:54 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="3332218" />
  <Command __id="1019" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:16:56 EDT 2022" docASTNodeCount="26" docActiveCodeLength="165" docExpressionCount="12" docLength="165" projectName="pa3" starttimestamp="1650226882502" timestamp="3333722">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\SourcePosition.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶public class SourcePosition {¶	public int lineNum;¶	public "), Diff(DELETE,"void "), Diff(EQUAL,"SourcePosition(int lineNum) {¶		this.lineNum = lineNum;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.SyntacticAnalyzer;

public class SourcePosition {
	public int lineNum;
	public SourcePosition(int lineNum) {
		this.lineNum = lineNum;
	}
}
]]></snapshot>
  </Command>
  <Command __id="1020" _type="MoveCaretCommand" caretOffset="110" date="Sun Apr 17 17:16:56 EDT 2022" docOffset="110" starttimestamp="1650226882502" timestamp="3333784" />
  <Command __id="1021" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:16:57 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="3335282">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="1022" _type="MoveCaretCommand" caretOffset="364" date="Sun Apr 17 17:16:57 EDT 2022" docOffset="421" starttimestamp="1650226882502" timestamp="3335378" />
  <Command __id="1024" _type="MoveCaretCommand" caretOffset="836" date="Sun Apr 17 17:16:58 EDT 2022" docOffset="993" starttimestamp="1650226882502" timestamp="3336249" />
  <Command __id="1023" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:16:58 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="3336186">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1026" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:17:04 EDT 2022" docASTNodeCount="1096" docActiveCodeLength="6636" docExpressionCount="672" docLength="7724" projectName="pa3" starttimestamp="1650226882502" timestamp="3341554">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		"), Diff(INSERT,"FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		"), Diff(EQUAL,"¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="1028" _type="Insert" date="Sun Apr 17 17:17:14 EDT 2022" docASTNodeCount="1098" docActiveCodeLength="6637" docExpressionCount="673" docLength="7725" length="1" offset="2740" starttimestamp="1650226882502" timestamp="3351558">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="1031" _type="Insert" date="Sun Apr 17 17:17:14 EDT 2022" docASTNodeCount="1098" docActiveCodeLength="6638" docExpressionCount="673" docLength="7726" length="1" offset="2741" starttimestamp="1650226882502" timestamp="3351821">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="1034" _type="Insert" date="Sun Apr 17 17:17:14 EDT 2022" docASTNodeCount="1098" docActiveCodeLength="6639" docExpressionCount="673" docLength="7727" length="1" offset="2742" starttimestamp="1650226882502" timestamp="3352191">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <DocumentChange __id="1037" _type="Insert" date="Sun Apr 17 17:17:14 EDT 2022" docASTNodeCount="1098" docActiveCodeLength="6640" docExpressionCount="673" docLength="7728" length="1" offset="2743" starttimestamp="1650226882502" timestamp="3352344">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="1040" _type="Insert" date="Sun Apr 17 17:17:15 EDT 2022" docASTNodeCount="1098" docActiveCodeLength="6641" docExpressionCount="673" docLength="7729" length="1" offset="2744" starttimestamp="1650226882502" timestamp="3352523">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="1043" _type="Insert" date="Sun Apr 17 17:17:15 EDT 2022" docASTNodeCount="1098" docActiveCodeLength="6642" docExpressionCount="673" docLength="7730" length="1" offset="2745" starttimestamp="1650226882502" timestamp="3352777">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="1046" _type="Insert" date="Sun Apr 17 17:17:15 EDT 2022" docASTNodeCount="1101" docActiveCodeLength="6643" docExpressionCount="674" docLength="7731" length="1" offset="2746" starttimestamp="1650226882502" timestamp="3353046">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="1049" _type="Insert" date="Sun Apr 17 17:17:16 EDT 2022" docASTNodeCount="1101" docActiveCodeLength="6644" docExpressionCount="674" docLength="7732" length="1" offset="2747" starttimestamp="1650226882502" timestamp="3353679">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="1052" _type="Insert" date="Sun Apr 17 17:17:16 EDT 2022" docASTNodeCount="1101" docActiveCodeLength="6645" docExpressionCount="674" docLength="7733" length="1" offset="2748" starttimestamp="1650226882502" timestamp="3353864">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="1055" _type="Insert" date="Sun Apr 17 17:17:16 EDT 2022" docASTNodeCount="1101" docActiveCodeLength="6646" docExpressionCount="674" docLength="7734" length="1" offset="2749" starttimestamp="1650226882502" timestamp="3354071">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="1058" _type="Insert" date="Sun Apr 17 17:17:16 EDT 2022" docASTNodeCount="1101" docActiveCodeLength="6647" docExpressionCount="674" docLength="7735" length="1" offset="2750" starttimestamp="1650226882502" timestamp="3354176">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1025" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 17:17:03 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="3341008" />
  <Command __id="1027" _type="MoveCaretCommand" caretOffset="2740" date="Sun Apr 17 17:17:04 EDT 2022" docOffset="2740" starttimestamp="1650226882502" timestamp="3341625" />
  <Command __id="1029" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3351574" timestamp2="3351574">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="1030" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3351574" timestamp2="3351574">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="1032" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3351827" timestamp2="3351827">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="1033" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3351827" timestamp2="3351827">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="1035" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3352191" timestamp2="3352191">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="1036" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3352191" timestamp2="3352191">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="1038" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3352360" timestamp2="3352360">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1039" _type="InsertStringCommand" date="Sun Apr 17 17:17:14 EDT 2022" starttimestamp="1650226882502" timestamp="3352360" timestamp2="3352360">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1041" _type="InsertStringCommand" date="Sun Apr 17 17:17:15 EDT 2022" starttimestamp="1650226882502" timestamp="3352529" timestamp2="3352529">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1042" _type="InsertStringCommand" date="Sun Apr 17 17:17:15 EDT 2022" starttimestamp="1650226882502" timestamp="3352529" timestamp2="3352529">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1044" _type="InsertStringCommand" date="Sun Apr 17 17:17:15 EDT 2022" starttimestamp="1650226882502" timestamp="3352792" timestamp2="3352792">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1045" _type="InsertStringCommand" date="Sun Apr 17 17:17:15 EDT 2022" starttimestamp="1650226882502" timestamp="3352792" timestamp2="3352792">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1047" _type="InsertStringCommand" date="Sun Apr 17 17:17:15 EDT 2022" starttimestamp="1650226882502" timestamp="3353046" timestamp2="3353046">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1048" _type="InsertStringCommand" date="Sun Apr 17 17:17:15 EDT 2022" starttimestamp="1650226882502" timestamp="3353046" timestamp2="3353046">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1050" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3353679" timestamp2="3353679">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1051" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3353679" timestamp2="3353679">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1053" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3353864" timestamp2="3353864">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1054" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3353864" timestamp2="3353864">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1056" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3354074" timestamp2="3354074">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1057" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3354074" timestamp2="3354074">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1059" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3354180" timestamp2="3354180">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1060" _type="InsertStringCommand" date="Sun Apr 17 17:17:16 EDT 2022" starttimestamp="1650226882502" timestamp="3354180" timestamp2="3354180">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1061" _type="Insert" date="Sun Apr 17 17:17:22 EDT 2022" docASTNodeCount="1102" docActiveCodeLength="6648" docExpressionCount="675" docLength="7736" length="1" offset="2751" starttimestamp="1650226882502" timestamp="3360162">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1062" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360177" timestamp2="3360177">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1063" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360177" timestamp2="3360177">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1064" _type="Insert" date="Sun Apr 17 17:17:22 EDT 2022" docASTNodeCount="1102" docActiveCodeLength="6649" docExpressionCount="675" docLength="7737" length="1" offset="2752" starttimestamp="1650226882502" timestamp="3360262">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1065" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360262" timestamp2="3360262">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1066" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360262" timestamp2="3360262">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1067" _type="Insert" date="Sun Apr 17 17:17:22 EDT 2022" docASTNodeCount="1096" docActiveCodeLength="6650" docExpressionCount="672" docLength="7738" length="1" offset="2753" starttimestamp="1650226882502" timestamp="3360308">
    <text><![CDATA[w]]></text>
  </DocumentChange>
  <Command __id="1068" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360308" timestamp2="3360308">
    <data><![CDATA[w]]></data>
  </Command>
  <Command __id="1069" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360308" timestamp2="3360308">
    <data><![CDATA[w]]></data>
  </Command>
  <DocumentChange __id="1070" _type="Insert" date="Sun Apr 17 17:17:22 EDT 2022" docASTNodeCount="1096" docActiveCodeLength="6651" docExpressionCount="672" docLength="7739" length="1" offset="2754" starttimestamp="1650226882502" timestamp="3360462">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1071" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360478" timestamp2="3360478">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1072" _type="InsertStringCommand" date="Sun Apr 17 17:17:22 EDT 2022" starttimestamp="1650226882502" timestamp="3360478" timestamp2="3360478">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1073" _type="Insert" date="Sun Apr 17 17:17:23 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6652" docExpressionCount="676" docLength="7740" length="1" offset="2755" starttimestamp="1650226882502" timestamp="3361047">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <Command __id="1074" _type="InsertStringCommand" date="Sun Apr 17 17:17:23 EDT 2022" starttimestamp="1650226882502" timestamp="3361047" timestamp2="3361047">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="1075" _type="InsertStringCommand" date="Sun Apr 17 17:17:23 EDT 2022" starttimestamp="1650226882502" timestamp="3361047" timestamp2="3361047">
    <data><![CDATA[T]]></data>
  </Command>
  <DocumentChange __id="1076" _type="Insert" date="Sun Apr 17 17:17:23 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6653" docExpressionCount="676" docLength="7741" length="1" offset="2756" starttimestamp="1650226882502" timestamp="3361230">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="1077" _type="InsertStringCommand" date="Sun Apr 17 17:17:23 EDT 2022" starttimestamp="1650226882502" timestamp="3361240" timestamp2="3361240">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="1078" _type="InsertStringCommand" date="Sun Apr 17 17:17:23 EDT 2022" starttimestamp="1650226882502" timestamp="3361240" timestamp2="3361240">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="1079" _type="Insert" date="Sun Apr 17 17:17:23 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6654" docExpressionCount="676" docLength="7742" length="1" offset="2757" starttimestamp="1650226882502" timestamp="3361418">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <Command __id="1080" _type="InsertStringCommand" date="Sun Apr 17 17:17:23 EDT 2022" starttimestamp="1650226882502" timestamp="3361418" timestamp2="3361418">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="1081" _type="InsertStringCommand" date="Sun Apr 17 17:17:23 EDT 2022" starttimestamp="1650226882502" timestamp="3361434" timestamp2="3361434">
    <data><![CDATA[k]]></data>
  </Command>
  <DocumentChange __id="1082" _type="Insert" date="Sun Apr 17 17:17:24 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6655" docExpressionCount="676" docLength="7743" length="1" offset="2758" starttimestamp="1650226882502" timestamp="3361503">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1083" _type="InsertStringCommand" date="Sun Apr 17 17:17:24 EDT 2022" starttimestamp="1650226882502" timestamp="3361503" timestamp2="3361503">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1084" _type="InsertStringCommand" date="Sun Apr 17 17:17:24 EDT 2022" starttimestamp="1650226882502" timestamp="3361503" timestamp2="3361503">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1085" _type="Insert" date="Sun Apr 17 17:17:24 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6656" docExpressionCount="676" docLength="7744" length="1" offset="2759" starttimestamp="1650226882502" timestamp="3361634">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1086" _type="InsertStringCommand" date="Sun Apr 17 17:17:24 EDT 2022" starttimestamp="1650226882502" timestamp="3361641" timestamp2="3361641">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1087" _type="InsertStringCommand" date="Sun Apr 17 17:17:24 EDT 2022" starttimestamp="1650226882502" timestamp="3361641" timestamp2="3361641">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1088" _type="Insert" date="Sun Apr 17 17:17:29 EDT 2022" docASTNodeCount="1032" docActiveCodeLength="6657" docExpressionCount="633" docLength="7745" length="1" offset="2760" starttimestamp="1650226882502" timestamp="3366573">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="1089" _type="InsertStringCommand" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3366588" timestamp2="3366588">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="1090" _type="InsertStringCommand" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3366588" timestamp2="3366588">
    <data><![CDATA[*]]></data>
  </Command>
  <DocumentChange __id="1091" _type="Delete" date="Sun Apr 17 17:17:29 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6656" docExpressionCount="676" docLength="7744" endLine="68" length="1" offset="2760" startLine="68" starttimestamp="1650226882502" timestamp="3366873">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="1092" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3366873" />
  <Command __id="1093" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3366873" />
  <DocumentChange __id="1094" _type="Insert" date="Sun Apr 17 17:17:29 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6657" docExpressionCount="653" docLength="7745" length="1" offset="2760" starttimestamp="1650226882502" timestamp="3367242">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="1095" _type="InsertStringCommand" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3367242" timestamp2="3367242">
    <data><![CDATA[)]]></data>
  </Command>
  <Command __id="1096" _type="InsertStringCommand" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3367242" timestamp2="3367242">
    <data><![CDATA[)]]></data>
  </Command>
  <DocumentChange __id="1097" _type="Insert" date="Sun Apr 17 17:17:29 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6659" docExpressionCount="676" docLength="7747" length="2" offset="2761" starttimestamp="1650226882502" timestamp="3367242">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="1098" _type="InsertStringCommand" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3367242" timestamp2="3367242">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="1099" _type="InsertStringCommand" date="Sun Apr 17 17:17:29 EDT 2022" starttimestamp="1650226882502" timestamp="3367242" timestamp2="3367242">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="1100" _type="Delete" date="Sun Apr 17 17:17:30 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6658" docExpressionCount="653" docLength="7746" endLine="68" length="1" offset="2761" startLine="68" starttimestamp="1650226882502" timestamp="3367612">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="1101" _type="Delete" date="Sun Apr 17 17:17:30 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6657" docExpressionCount="653" docLength="7745" endLine="68" length="1" offset="2761" startLine="68" starttimestamp="1650226882502" timestamp="3367612">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="1102" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3367612" />
  <Command __id="1103" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3367612" />
  <DocumentChange __id="1104" _type="Delete" date="Sun Apr 17 17:17:30 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6656" docExpressionCount="676" docLength="7744" endLine="68" length="1" offset="2760" startLine="68" starttimestamp="1650226882502" timestamp="3367774">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="1105" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3367774" />
  <Command __id="1106" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3367774" />
  <DocumentChange __id="1107" _type="Insert" date="Sun Apr 17 17:17:30 EDT 2022" docASTNodeCount="1069" docActiveCodeLength="6657" docExpressionCount="653" docLength="7745" length="1" offset="2760" starttimestamp="1650226882502" timestamp="3367959">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="1108" _type="InsertStringCommand" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3367975" timestamp2="3367975">
    <data><![CDATA[)]]></data>
  </Command>
  <Command __id="1109" _type="InsertStringCommand" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3367975" timestamp2="3367975">
    <data><![CDATA[)]]></data>
  </Command>
  <DocumentChange __id="1110" _type="Delete" date="Sun Apr 17 17:17:30 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6656" docExpressionCount="676" docLength="7744" endLine="68" length="1" offset="2760" startLine="68" starttimestamp="1650226882502" timestamp="3368476">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="1111" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3368492" />
  <Command __id="1112" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:30 EDT 2022" starttimestamp="1650226882502" timestamp="3368492" />
  <DocumentChange __id="1113" _type="Insert" date="Sun Apr 17 17:17:31 EDT 2022" docASTNodeCount="1032" docActiveCodeLength="6657" docExpressionCount="633" docLength="7745" length="1" offset="2760" starttimestamp="1650226882502" timestamp="3368761">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="1114" _type="InsertStringCommand" date="Sun Apr 17 17:17:31 EDT 2022" starttimestamp="1650226882502" timestamp="3368761" timestamp2="3368761">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="1115" _type="InsertStringCommand" date="Sun Apr 17 17:17:31 EDT 2022" starttimestamp="1650226882502" timestamp="3368761" timestamp2="3368761">
    <data><![CDATA[*]]></data>
  </Command>
  <DocumentChange __id="1116" _type="Insert" date="Sun Apr 17 17:17:31 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6659" docExpressionCount="676" docLength="7747" length="2" offset="2761" starttimestamp="1650226882502" timestamp="3368777">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="1117" _type="InsertStringCommand" date="Sun Apr 17 17:17:31 EDT 2022" starttimestamp="1650226882502" timestamp="3368777" timestamp2="3368777">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="1118" _type="InsertStringCommand" date="Sun Apr 17 17:17:31 EDT 2022" starttimestamp="1650226882502" timestamp="3368777" timestamp2="3368777">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="1119" _type="Delete" date="Sun Apr 17 17:17:32 EDT 2022" docASTNodeCount="1099" docActiveCodeLength="6658" docExpressionCount="675" docLength="7746" endLine="68" length="1" offset="2761" startLine="68" starttimestamp="1650226882502" timestamp="3370116">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="1120" _type="Delete" date="Sun Apr 17 17:17:32 EDT 2022" docASTNodeCount="1032" docActiveCodeLength="6657" docExpressionCount="633" docLength="7745" endLine="68" length="1" offset="2761" startLine="68" starttimestamp="1650226882502" timestamp="3370132">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="1121" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:32 EDT 2022" starttimestamp="1650226882502" timestamp="3370132" />
  <Command __id="1122" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:32 EDT 2022" starttimestamp="1650226882502" timestamp="3370132" />
  <DocumentChange __id="1123" _type="Delete" date="Sun Apr 17 17:17:32 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6656" docExpressionCount="676" docLength="7744" endLine="68" length="1" offset="2760" startLine="68" starttimestamp="1650226882502" timestamp="3370279">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="1124" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:32 EDT 2022" starttimestamp="1650226882502" timestamp="3370279" />
  <Command __id="1125" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:17:32 EDT 2022" starttimestamp="1650226882502" timestamp="3370279" />
  <DocumentChange __id="1126" _type="Insert" date="Sun Apr 17 17:17:33 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6658" docExpressionCount="676" docLength="7746" length="2" offset="2760" starttimestamp="1650226882502" timestamp="3370963">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="1127" _type="InsertStringCommand" date="Sun Apr 17 17:17:33 EDT 2022" starttimestamp="1650226882502" timestamp="3370963" timestamp2="3370963">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="1128" _type="InsertStringCommand" date="Sun Apr 17 17:17:33 EDT 2022" starttimestamp="1650226882502" timestamp="3370963" timestamp2="3370963">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="1129" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:17:34 EDT 2022" docASTNodeCount="60" docActiveCodeLength="295" docExpressionCount="32" docLength="399" projectName="pa3" starttimestamp="1650226882502" timestamp="3372266">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Token.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶/**¶ *  A token has a kind and a spelling¶ *  In a compiler it would also have a source position ¶ */¶public class Token {¶	public TokenKind kind;¶	public String spelling;¶	public SourcePosition posn;¶¶	public Token(TokenKind kind, String spelling, SourcePosition posn) {¶		this.kind = kind;¶		this.spelling = spelling;¶		this.posn = posn;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1130" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 17:17:34 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="3372334" />
  <Command __id="1132" _type="MoveCaretCommand" caretOffset="2761" date="Sun Apr 17 17:17:51 EDT 2022" docOffset="2761" starttimestamp="1650226882502" timestamp="3389133" />
  <Command __id="1133" _type="ShellCommand" date="Sun Apr 17 17:18:28 EDT 2022" starttimestamp="1650226882502" timestamp="3425523" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1131" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:17:51 EDT 2022" docASTNodeCount="1104" docActiveCodeLength="6658" docExpressionCount="676" docLength="7746" projectName="pa3" starttimestamp="1650226882502" timestamp="3389057">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		"), Diff(INSERT,"Token t1 = new Token()"), Diff(EQUAL,"¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		Token t1 = new Token()
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="1135" _type="Insert" date="Sun Apr 17 17:18:56 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6659" docExpressionCount="677" docLength="7747" length="1" offset="2761" starttimestamp="1650226882502" timestamp="3453950">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="1138" _type="Insert" date="Sun Apr 17 17:18:56 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6660" docExpressionCount="677" docLength="7748" length="1" offset="2762" starttimestamp="1650226882502" timestamp="3454135">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="1141" _type="Insert" date="Sun Apr 17 17:18:56 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6661" docExpressionCount="677" docLength="7749" length="1" offset="2763" starttimestamp="1650226882502" timestamp="3454331">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <DocumentChange __id="1144" _type="Insert" date="Sun Apr 17 17:18:56 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6662" docExpressionCount="677" docLength="7750" length="1" offset="2764" starttimestamp="1650226882502" timestamp="3454400">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="1147" _type="Insert" date="Sun Apr 17 17:18:57 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6663" docExpressionCount="677" docLength="7751" length="1" offset="2765" starttimestamp="1650226882502" timestamp="3454512">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="1150" _type="Insert" date="Sun Apr 17 17:18:57 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6664" docExpressionCount="677" docLength="7752" length="1" offset="2766" starttimestamp="1650226882502" timestamp="3454867">
    <text><![CDATA[K]]></text>
  </DocumentChange>
  <DocumentChange __id="1153" _type="Insert" date="Sun Apr 17 17:18:57 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6665" docExpressionCount="677" docLength="7753" length="1" offset="2767" starttimestamp="1650226882502" timestamp="3455052">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="1156" _type="Insert" date="Sun Apr 17 17:18:57 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6666" docExpressionCount="677" docLength="7754" length="1" offset="2768" starttimestamp="1650226882502" timestamp="3455099">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="1159" _type="Insert" date="Sun Apr 17 17:18:57 EDT 2022" docASTNodeCount="1105" docActiveCodeLength="6667" docExpressionCount="677" docLength="7755" length="1" offset="2769" starttimestamp="1650226882502" timestamp="3455215">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="1162" _type="Insert" date="Sun Apr 17 17:18:57 EDT 2022" docASTNodeCount="1080" docActiveCodeLength="6668" docExpressionCount="660" docLength="7756" length="1" offset="2770" starttimestamp="1650226882502" timestamp="3455353">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="1134" _type="ShellCommand" date="Sun Apr 17 17:18:55 EDT 2022" starttimestamp="1650226882502" timestamp="3453153" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1136" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3453950" timestamp2="3453950">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="1137" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3453950" timestamp2="3453950">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="1139" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3454151" timestamp2="3454151">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="1140" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3454151" timestamp2="3454151">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="1142" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3454334" timestamp2="3454334">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="1143" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3454334" timestamp2="3454334">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="1145" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3454404" timestamp2="3454404">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1146" _type="InsertStringCommand" date="Sun Apr 17 17:18:56 EDT 2022" starttimestamp="1650226882502" timestamp="3454404" timestamp2="3454404">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1148" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3454515" timestamp2="3454515">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1149" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3454515" timestamp2="3454515">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1151" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3454867" timestamp2="3454867">
    <data><![CDATA[K]]></data>
  </Command>
  <Command __id="1152" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3454867" timestamp2="3454867">
    <data><![CDATA[K]]></data>
  </Command>
  <Command __id="1154" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455052" timestamp2="3455052">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1155" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455052" timestamp2="3455052">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1157" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455099" timestamp2="3455099">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1158" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455099" timestamp2="3455099">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1160" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455215" timestamp2="3455215">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1161" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455215" timestamp2="3455215">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1163" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455369" timestamp2="3455369">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="1164" _type="InsertStringCommand" date="Sun Apr 17 17:18:57 EDT 2022" starttimestamp="1650226882502" timestamp="3455369" timestamp2="3455369">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="1165" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 17:18:57 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="3455369" />
  <DocumentChange __id="1166" _type="Insert" date="Sun Apr 17 17:18:59 EDT 2022" docASTNodeCount="1107" docActiveCodeLength="6669" docExpressionCount="679" docLength="7757" length="1" offset="2771" starttimestamp="1650226882502" timestamp="3456570">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="1167" _type="Insert" date="Sun Apr 17 17:18:59 EDT 2022" docASTNodeCount="1107" docActiveCodeLength="6670" docExpressionCount="679" docLength="7758" length="1" offset="2772" starttimestamp="1650226882502" timestamp="3457071">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1168" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 17:19:03 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="3461139" />
  <DocumentChange __id="1169" _type="Insert" date="Sun Apr 17 17:19:03 EDT 2022" docASTNodeCount="1113" docActiveCodeLength="6714" docExpressionCount="684" docLength="7802" length="44" offset="2120" starttimestamp="1650226882502" timestamp="3461161">
    <text><![CDATA[import miniJava.SyntacticAnalyzer.TokenKind;]]></text>
  </DocumentChange>
  <DocumentChange __id="1170" _type="Insert" date="Sun Apr 17 17:19:03 EDT 2022" docASTNodeCount="1113" docActiveCodeLength="6716" docExpressionCount="684" docLength="7804" length="2" offset="2120" starttimestamp="1650226882502" timestamp="3461161">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="1171" _type="Replace" date="Sun Apr 17 17:19:03 EDT 2022" docASTNodeCount="1113" docActiveCodeLength="6716" docExpressionCount="684" docLength="7804" endLine="69" insertionLength="2" int_docASTNodeCount="1086" int_docActiveCodeLength="6714" int_docExpressionCount="665" int_docLength="7802" length="2" offset="2817" startLine="69" starttimestamp="1650226882502" timestamp="3461177">
    <deletedText><![CDATA[id]]></deletedText>
    <insertedText><![CDATA[ID]]></insertedText>
  </DocumentChange>
  <Command __id="1172" _type="InsertStringCommand" date="Sun Apr 17 17:19:03 EDT 2022" starttimestamp="1650226882502" timestamp="3461177" timestamp2="3461177">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1173" _type="InsertStringCommand" date="Sun Apr 17 17:19:03 EDT 2022" starttimestamp="1650226882502" timestamp="3461177" timestamp2="3461177">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="1174" _type="Insert" date="Sun Apr 17 17:19:05 EDT 2022" docASTNodeCount="1087" docActiveCodeLength="6717" docExpressionCount="666" docLength="7805" length="1" offset="2819" starttimestamp="1650226882502" timestamp="3462603">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <Command __id="1175" _type="InsertStringCommand" date="Sun Apr 17 17:19:05 EDT 2022" starttimestamp="1650226882502" timestamp="3462603" timestamp2="3462603">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="1176" _type="InsertStringCommand" date="Sun Apr 17 17:19:05 EDT 2022" starttimestamp="1650226882502" timestamp="3462603" timestamp2="3462603">
    <data><![CDATA[,]]></data>
  </Command>
  <DocumentChange __id="1177" _type="Insert" date="Sun Apr 17 17:19:06 EDT 2022" docASTNodeCount="1087" docActiveCodeLength="6718" docExpressionCount="666" docLength="7806" length="1" offset="2820" starttimestamp="1650226882502" timestamp="3463736">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1178" _type="InsertStringCommand" date="Sun Apr 17 17:19:06 EDT 2022" starttimestamp="1650226882502" timestamp="3463736" timestamp2="3463736">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1179" _type="InsertStringCommand" date="Sun Apr 17 17:19:06 EDT 2022" starttimestamp="1650226882502" timestamp="3463736" timestamp2="3463736">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1180" _type="Insert" date="Sun Apr 17 17:19:06 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6720" docExpressionCount="685" docLength="7808" length="2" offset="2821" starttimestamp="1650226882502" timestamp="3464036">
    <text><![CDATA[""]]></text>
  </DocumentChange>
  <Command __id="1181" _type="InsertStringCommand" date="Sun Apr 17 17:19:06 EDT 2022" starttimestamp="1650226882502" timestamp="3464036" timestamp2="3464036">
    <data><![CDATA["]]></data>
  </Command>
  <Command __id="1182" _type="InsertStringCommand" date="Sun Apr 17 17:19:06 EDT 2022" starttimestamp="1650226882502" timestamp="3464036" timestamp2="3464036">
    <data><![CDATA["]]></data>
  </Command>
  <DocumentChange __id="1183" _type="Insert" date="Sun Apr 17 17:19:08 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6721" docExpressionCount="685" docLength="7809" length="1" offset="2822" starttimestamp="1650226882502" timestamp="3466049">
    <text><![CDATA[_]]></text>
  </DocumentChange>
  <Command __id="1184" _type="InsertStringCommand" date="Sun Apr 17 17:19:08 EDT 2022" starttimestamp="1650226882502" timestamp="3466059" timestamp2="3466059">
    <data><![CDATA[_]]></data>
  </Command>
  <Command __id="1185" _type="InsertStringCommand" date="Sun Apr 17 17:19:08 EDT 2022" starttimestamp="1650226882502" timestamp="3466059" timestamp2="3466059">
    <data><![CDATA[_]]></data>
  </Command>
  <DocumentChange __id="1186" _type="Insert" date="Sun Apr 17 17:19:08 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6722" docExpressionCount="685" docLength="7810" length="1" offset="2823" starttimestamp="1650226882502" timestamp="3466371">
    <text><![CDATA[P]]></text>
  </DocumentChange>
  <Command __id="1187" _type="InsertStringCommand" date="Sun Apr 17 17:19:08 EDT 2022" starttimestamp="1650226882502" timestamp="3466387" timestamp2="3466387">
    <data><![CDATA[P]]></data>
  </Command>
  <Command __id="1188" _type="InsertStringCommand" date="Sun Apr 17 17:19:08 EDT 2022" starttimestamp="1650226882502" timestamp="3466387" timestamp2="3466387">
    <data><![CDATA[P]]></data>
  </Command>
  <DocumentChange __id="1189" _type="Insert" date="Sun Apr 17 17:19:09 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6723" docExpressionCount="685" docLength="7811" length="1" offset="2824" starttimestamp="1650226882502" timestamp="3466671">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="1190" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3466671" timestamp2="3466671">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="1191" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3466671" timestamp2="3466671">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="1192" _type="Insert" date="Sun Apr 17 17:19:09 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6724" docExpressionCount="685" docLength="7812" length="1" offset="2825" starttimestamp="1650226882502" timestamp="3466703">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="1193" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3466703" timestamp2="3466703">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1194" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3466703" timestamp2="3466703">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1195" _type="Insert" date="Sun Apr 17 17:19:09 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6725" docExpressionCount="685" docLength="7813" length="1" offset="2826" starttimestamp="1650226882502" timestamp="3466887">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1196" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3466887" timestamp2="3466887">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1197" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3466887" timestamp2="3466887">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1198" _type="Insert" date="Sun Apr 17 17:19:09 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6726" docExpressionCount="685" docLength="7814" length="1" offset="2827" starttimestamp="1650226882502" timestamp="3467018">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <Command __id="1199" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3467018" timestamp2="3467018">
    <data><![CDATA[g]]></data>
  </Command>
  <Command __id="1200" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3467018" timestamp2="3467018">
    <data><![CDATA[g]]></data>
  </Command>
  <DocumentChange __id="1201" _type="Delete" date="Sun Apr 17 17:19:09 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6725" docExpressionCount="685" docLength="7813" endLine="69" length="1" offset="2827" startLine="69" starttimestamp="1650226882502" timestamp="3467419">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <Command __id="1202" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3467419" />
  <Command __id="1203" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3467419" />
  <DocumentChange __id="1204" _type="Insert" date="Sun Apr 17 17:19:09 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6726" docExpressionCount="685" docLength="7814" length="1" offset="2827" starttimestamp="1650226882502" timestamp="3467472">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1205" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3467472" timestamp2="3467472">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1206" _type="InsertStringCommand" date="Sun Apr 17 17:19:09 EDT 2022" starttimestamp="1650226882502" timestamp="3467472" timestamp2="3467472">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="1207" _type="Insert" date="Sun Apr 17 17:19:11 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6727" docExpressionCount="685" docLength="7815" length="1" offset="2828" starttimestamp="1650226882502" timestamp="3468936">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <Command __id="1208" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3468943" timestamp2="3468943">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="1209" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3468943" timestamp2="3468943">
    <data><![CDATA[S]]></data>
  </Command>
  <DocumentChange __id="1210" _type="Insert" date="Sun Apr 17 17:19:11 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6728" docExpressionCount="685" docLength="7816" length="1" offset="2829" starttimestamp="1650226882502" timestamp="3469271">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1211" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3469272" timestamp2="3469272">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1212" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3469273" timestamp2="3469273">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="1213" _type="Insert" date="Sun Apr 17 17:19:11 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6729" docExpressionCount="685" docLength="7817" length="1" offset="2830" starttimestamp="1650226882502" timestamp="3469431">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="1214" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3469433" timestamp2="3469433">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="1215" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3469433" timestamp2="3469433">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="1216" _type="Insert" date="Sun Apr 17 17:19:11 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6730" docExpressionCount="685" docLength="7818" length="1" offset="2831" starttimestamp="1650226882502" timestamp="3469458">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1217" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3469460" timestamp2="3469460">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1218" _type="InsertStringCommand" date="Sun Apr 17 17:19:11 EDT 2022" starttimestamp="1650226882502" timestamp="3469460" timestamp2="3469460">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1219" _type="Insert" date="Sun Apr 17 17:19:12 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6731" docExpressionCount="685" docLength="7819" length="1" offset="2832" starttimestamp="1650226882502" timestamp="3469546">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1220" _type="InsertStringCommand" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3469549" timestamp2="3469549">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1221" _type="InsertStringCommand" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3469549" timestamp2="3469549">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1222" _type="Insert" date="Sun Apr 17 17:19:12 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6732" docExpressionCount="685" docLength="7820" length="1" offset="2833" starttimestamp="1650226882502" timestamp="3469722">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="1223" _type="InsertStringCommand" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3469722" timestamp2="3469722">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="1224" _type="InsertStringCommand" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3469722" timestamp2="3469722">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="1225" _type="Insert" date="Sun Apr 17 17:19:12 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6733" docExpressionCount="685" docLength="7821" length="1" offset="2834" starttimestamp="1650226882502" timestamp="3469960">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1226" _type="InsertStringCommand" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3469960" timestamp2="3469960">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1227" _type="InsertStringCommand" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3469960" timestamp2="3469960">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1228" _type="Delete" date="Sun Apr 17 17:19:12 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6732" docExpressionCount="685" docLength="7820" endLine="69" length="1" offset="2834" startLine="69" starttimestamp="1650226882502" timestamp="3470176">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1229" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3470176" />
  <Command __id="1230" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3470176" />
  <DocumentChange __id="1231" _type="Delete" date="Sun Apr 17 17:19:12 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6731" docExpressionCount="685" docLength="7819" endLine="69" length="1" offset="2833" startLine="69" starttimestamp="1650226882502" timestamp="3470338">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="1232" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3470345" />
  <Command __id="1233" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3470345" />
  <DocumentChange __id="1234" _type="Delete" date="Sun Apr 17 17:19:12 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6730" docExpressionCount="685" docLength="7818" endLine="69" length="1" offset="2832" startLine="69" starttimestamp="1650226882502" timestamp="3470476">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1235" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3470476" />
  <Command __id="1236" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:19:12 EDT 2022" starttimestamp="1650226882502" timestamp="3470476" />
  <DocumentChange __id="1237" _type="Insert" date="Sun Apr 17 17:19:13 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6731" docExpressionCount="685" docLength="7819" length="1" offset="2832" starttimestamp="1650226882502" timestamp="3470592">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="1238" _type="InsertStringCommand" date="Sun Apr 17 17:19:13 EDT 2022" starttimestamp="1650226882502" timestamp="3470592" timestamp2="3470592">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="1239" _type="InsertStringCommand" date="Sun Apr 17 17:19:13 EDT 2022" starttimestamp="1650226882502" timestamp="3470592" timestamp2="3470592">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="1240" _type="Insert" date="Sun Apr 17 17:19:13 EDT 2022" docASTNodeCount="1114" docActiveCodeLength="6732" docExpressionCount="685" docLength="7820" length="1" offset="2833" starttimestamp="1650226882502" timestamp="3470692">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="1241" _type="InsertStringCommand" date="Sun Apr 17 17:19:13 EDT 2022" starttimestamp="1650226882502" timestamp="3470692" timestamp2="3470692">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="1242" _type="InsertStringCommand" date="Sun Apr 17 17:19:13 EDT 2022" starttimestamp="1650226882502" timestamp="3470692" timestamp2="3470692">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="1243" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:19:13 EDT 2022" starttimestamp="1650226882502" timestamp="3471362" />
  <Command __id="1244" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:19:13 EDT 2022" starttimestamp="1650226882502" timestamp="3471362" />
  <DocumentChange __id="1245" _type="Insert" date="Sun Apr 17 17:19:25 EDT 2022" docASTNodeCount="1088" docActiveCodeLength="6733" docExpressionCount="667" docLength="7821" length="1" offset="2835" starttimestamp="1650226882502" timestamp="3483054">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <Command __id="1246" _type="InsertStringCommand" date="Sun Apr 17 17:19:25 EDT 2022" starttimestamp="1650226882502" timestamp="3483061" timestamp2="3483061">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="1247" _type="InsertStringCommand" date="Sun Apr 17 17:19:25 EDT 2022" starttimestamp="1650226882502" timestamp="3483061" timestamp2="3483061">
    <data><![CDATA[,]]></data>
  </Command>
  <DocumentChange __id="1248" _type="Insert" date="Sun Apr 17 17:19:25 EDT 2022" docASTNodeCount="1088" docActiveCodeLength="6734" docExpressionCount="667" docLength="7822" length="1" offset="2836" starttimestamp="1650226882502" timestamp="3483292">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1249" _type="InsertStringCommand" date="Sun Apr 17 17:19:25 EDT 2022" starttimestamp="1650226882502" timestamp="3483292" timestamp2="3483292">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1250" _type="InsertStringCommand" date="Sun Apr 17 17:19:25 EDT 2022" starttimestamp="1650226882502" timestamp="3483292" timestamp2="3483292">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1251" _type="Insert" date="Sun Apr 17 17:19:25 EDT 2022" docASTNodeCount="1115" docActiveCodeLength="6735" docExpressionCount="686" docLength="7823" length="1" offset="2837" starttimestamp="1650226882502" timestamp="3483439">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="1252" _type="InsertStringCommand" date="Sun Apr 17 17:19:25 EDT 2022" starttimestamp="1650226882502" timestamp="3483439" timestamp2="3483439">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="1253" _type="InsertStringCommand" date="Sun Apr 17 17:19:25 EDT 2022" starttimestamp="1650226882502" timestamp="3483439" timestamp2="3483439">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="1255" _type="InsertStringCommand" date="Sun Apr 17 17:19:26 EDT 2022" starttimestamp="1650226882502" timestamp="3483593" timestamp2="3483593">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="1256" _type="InsertStringCommand" date="Sun Apr 17 17:19:26 EDT 2022" starttimestamp="1650226882502" timestamp="3483593" timestamp2="3483593">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="1254" _type="Insert" date="Sun Apr 17 17:19:26 EDT 2022" docASTNodeCount="1115" docActiveCodeLength="6736" docExpressionCount="686" docLength="7824" length="1" offset="2838" starttimestamp="1650226882502" timestamp="3483593">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="1259" _type="Insert" date="Sun Apr 17 17:19:28 EDT 2022" docASTNodeCount="1115" docActiveCodeLength="6737" docExpressionCount="686" docLength="7825" length="1" offset="2840" starttimestamp="1650226882502" timestamp="3485541">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="1262" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:20:43 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="3560580">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1257" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:19:27 EDT 2022" starttimestamp="1650226882502" timestamp="3484678" />
  <Command __id="1258" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:19:27 EDT 2022" starttimestamp="1650226882502" timestamp="3484678" />
  <Command __id="1260" _type="InsertStringCommand" date="Sun Apr 17 17:19:28 EDT 2022" starttimestamp="1650226882502" timestamp="3485541" timestamp2="3485541">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="1261" _type="InsertStringCommand" date="Sun Apr 17 17:19:28 EDT 2022" starttimestamp="1650226882502" timestamp="3485541" timestamp2="3485541">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="1263" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 17:20:43 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="3560682" />
  <Command __id="1265" _type="MoveCaretCommand" caretOffset="1360" date="Sun Apr 17 17:20:54 EDT 2022" docOffset="1360" starttimestamp="1650226882502" timestamp="3571841" />
  <Command __id="1264" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:20:54 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="3571778">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1266" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Apr 17 17:20:59 EDT 2022" starttimestamp="1650226882502" timestamp="3576857" />
  <Command __id="1267" _type="EclipseCommand" commandID="" date="Sun Apr 17 17:20:59 EDT 2022" starttimestamp="1650226882502" timestamp="3576973" />
  <Command __id="1268" _type="EclipseCommand" commandID="" date="Sun Apr 17 17:20:59 EDT 2022" starttimestamp="1650226882502" timestamp="3576989" />
  <Command __id="1269" _type="MoveCaretCommand" caretOffset="643" date="Sun Apr 17 17:20:59 EDT 2022" docOffset="643" starttimestamp="1650226882502" timestamp="3577281" />
  <Command __id="1270" _type="MoveCaretCommand" caretOffset="643" date="Sun Apr 17 17:20:59 EDT 2022" docOffset="643" starttimestamp="1650226882502" timestamp="3577281" />
  <Command __id="1271" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:21:01 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="3579453">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1272" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:21:02 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="3579502">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1273" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 17:21:02 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="3579607" />
  <Command __id="1274" _type="MoveCaretCommand" caretOffset="643" date="Sun Apr 17 17:21:02 EDT 2022" docOffset="643" starttimestamp="1650226882502" timestamp="3579616" />
  <Command __id="1275" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:21:03 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="3581380">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

public class FieldDecl extends MemberDecl {
	
	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){
    super(isPrivate, isStatic, t, name, posn);
	}
	
	public FieldDecl(MemberDecl md, SourcePosition posn) {
		super(md,posn);
	}
	
	public <A, R> R visit(Visitor<A, R> v, A o) {
        return v.visitFieldDecl(this, o);
    }
}

]]></snapshot>
  </Command>
  <Command __id="1276" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:21:03 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="3581411">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1277" _type="MoveCaretCommand" caretOffset="343" date="Sun Apr 17 17:21:04 EDT 2022" docOffset="400" starttimestamp="1650226882502" timestamp="3581511" />
  <Command __id="1278" _type="MoveCaretCommand" caretOffset="643" date="Sun Apr 17 17:21:04 EDT 2022" docOffset="643" starttimestamp="1650226882502" timestamp="3581527" />
  <Command __id="1280" _type="MoveCaretCommand" caretOffset="2841" date="Sun Apr 17 17:21:06 EDT 2022" docOffset="2841" starttimestamp="1650226882502" timestamp="3583501" />
  <Command __id="1281" _type="ShellCommand" date="Sun Apr 17 17:21:11 EDT 2022" starttimestamp="1650226882502" timestamp="3589359" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1282" _type="ShellCommand" date="Sun Apr 17 17:21:11 EDT 2022" starttimestamp="1650226882502" timestamp="3589491" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1285" _type="MoveCaretCommand" caretOffset="2883" date="Sun Apr 17 17:21:15 EDT 2022" docOffset="2883" starttimestamp="1650226882502" timestamp="3593100" />
  <Command __id="1286" _type="MoveCaretCommand" caretOffset="2883" date="Sun Apr 17 17:21:15 EDT 2022" docOffset="2883" starttimestamp="1650226882502" timestamp="3593113" />
  <Command __id="1279" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:21:05 EDT 2022" docASTNodeCount="1115" docActiveCodeLength="6737" docExpressionCount="686" docLength="7825" projectName="pa3" starttimestamp="1650226882502" timestamp="3583434">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;"), Diff(INSERT,"¶import miniJava.SyntacticAnalyzer.TokenKind;"), Diff(EQUAL,"¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		Token t1 = new Token("), Diff(DELETE,")"), Diff(INSERT,"TokenKind.ID, "_PrintStream", sp);"), Diff(EQUAL,"¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		Token t1 = new Token(TokenKind.ID, "_PrintStream", sp);
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="1283" _type="Insert" date="Sun Apr 17 17:21:12 EDT 2022" docASTNodeCount="1121" docActiveCodeLength="6777" docExpressionCount="691" docLength="7865" length="40" offset="2120" starttimestamp="1650226882502" timestamp="3589509">
    <text><![CDATA[import miniJava.SyntacticAnalyzer.Token;]]></text>
  </DocumentChange>
  <DocumentChange __id="1284" _type="Insert" date="Sun Apr 17 17:21:12 EDT 2022" docASTNodeCount="1121" docActiveCodeLength="6779" docExpressionCount="691" docLength="7867" length="2" offset="2120" starttimestamp="1650226882502" timestamp="3589510">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="1287" _type="MoveCaretCommand" caretOffset="2883" date="Sun Apr 17 17:21:53 EDT 2022" docOffset="2883" starttimestamp="1650226882502" timestamp="3631041" />
  <Command __id="1288" _type="MoveCaretCommand" caretOffset="2883" date="Sun Apr 17 17:21:53 EDT 2022" docOffset="2883" starttimestamp="1650226882502" timestamp="3631041" />
  <DocumentChange __id="1289" _type="Insert" date="Sun Apr 17 17:22:02 EDT 2022" docASTNodeCount="1121" docActiveCodeLength="6783" docExpressionCount="691" docLength="7871" length="4" offset="2883" starttimestamp="1650226882502" timestamp="3640183">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="1290" _type="InsertStringCommand" date="Sun Apr 17 17:22:02 EDT 2022" starttimestamp="1650226882502" timestamp="3640183" timestamp2="3640183">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1291" _type="InsertStringCommand" date="Sun Apr 17 17:22:02 EDT 2022" starttimestamp="1650226882502" timestamp="3640183" timestamp2="3640183">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="1292" _type="Insert" date="Sun Apr 17 17:22:03 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6784" docExpressionCount="692" docLength="7872" length="1" offset="2887" starttimestamp="1650226882502" timestamp="3640568">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <Command __id="1293" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3640568" timestamp2="3640568">
    <data><![CDATA[I]]></data>
  </Command>
  <Command __id="1294" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3640568" timestamp2="3640568">
    <data><![CDATA[I]]></data>
  </Command>
  <DocumentChange __id="1295" _type="Insert" date="Sun Apr 17 17:22:03 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6785" docExpressionCount="692" docLength="7873" length="1" offset="2888" starttimestamp="1650226882502" timestamp="3640868">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1296" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3640884" timestamp2="3640884">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1297" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3640884" timestamp2="3640884">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="1298" _type="Insert" date="Sun Apr 17 17:22:03 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6786" docExpressionCount="692" docLength="7874" length="1" offset="2889" starttimestamp="1650226882502" timestamp="3641100">
    <text><![CDATA[3]]></text>
  </DocumentChange>
  <Command __id="1299" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3641100" timestamp2="3641100">
    <data><![CDATA[3]]></data>
  </Command>
  <Command __id="1300" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3641100" timestamp2="3641100">
    <data><![CDATA[3]]></data>
  </Command>
  <DocumentChange __id="1301" _type="Insert" date="Sun Apr 17 17:22:03 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6787" docExpressionCount="692" docLength="7875" length="1" offset="2890" starttimestamp="1650226882502" timestamp="3641322">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1302" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3641322" timestamp2="3641322">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1303" _type="InsertStringCommand" date="Sun Apr 17 17:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="3641322" timestamp2="3641322">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1304" _type="Delete" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6786" docExpressionCount="692" docLength="7874" endLine="71" length="1" offset="2890" startLine="71" starttimestamp="1650226882502" timestamp="3641585">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1305" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641601" />
  <Command __id="1306" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641601" />
  <DocumentChange __id="1307" _type="Delete" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6785" docExpressionCount="692" docLength="7873" endLine="71" length="1" offset="2889" startLine="71" starttimestamp="1650226882502" timestamp="3641717">
    <text><![CDATA[3]]></text>
  </DocumentChange>
  <Command __id="1308" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641717" />
  <Command __id="1309" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641717" />
  <DocumentChange __id="1310" _type="Insert" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6786" docExpressionCount="692" docLength="7874" length="1" offset="2889" starttimestamp="1650226882502" timestamp="3641770">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1311" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641770" timestamp2="3641770">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1312" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641770" timestamp2="3641770">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1313" _type="Insert" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6787" docExpressionCount="692" docLength="7875" length="1" offset="2890" starttimestamp="1650226882502" timestamp="3641923">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1314" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641923" timestamp2="3641923">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1315" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3641923" timestamp2="3641923">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1316" _type="Insert" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6788" docExpressionCount="692" docLength="7876" length="1" offset="2891" starttimestamp="1650226882502" timestamp="3642024">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1317" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642024" timestamp2="3642024">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1318" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642024" timestamp2="3642024">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="1319" _type="Insert" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6789" docExpressionCount="692" docLength="7877" length="1" offset="2892" starttimestamp="1650226882502" timestamp="3642124">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="1320" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642139" timestamp2="3642139">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1321" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642139" timestamp2="3642139">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1322" _type="Insert" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6790" docExpressionCount="692" docLength="7878" length="1" offset="2893" starttimestamp="1650226882502" timestamp="3642340">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <Command __id="1323" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642340" timestamp2="3642340">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="1324" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642340" timestamp2="3642340">
    <data><![CDATA[f]]></data>
  </Command>
  <DocumentChange __id="1325" _type="Insert" date="Sun Apr 17 17:22:04 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6791" docExpressionCount="692" docLength="7879" length="1" offset="2894" starttimestamp="1650226882502" timestamp="3642424">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="1326" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642440" timestamp2="3642440">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1327" _type="InsertStringCommand" date="Sun Apr 17 17:22:04 EDT 2022" starttimestamp="1650226882502" timestamp="3642440" timestamp2="3642440">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1328" _type="Insert" date="Sun Apr 17 17:22:05 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6792" docExpressionCount="692" docLength="7880" length="1" offset="2895" starttimestamp="1650226882502" timestamp="3642572">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1329" _type="InsertStringCommand" date="Sun Apr 17 17:22:05 EDT 2022" starttimestamp="1650226882502" timestamp="3642572" timestamp2="3642572">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1330" _type="InsertStringCommand" date="Sun Apr 17 17:22:05 EDT 2022" starttimestamp="1650226882502" timestamp="3642572" timestamp2="3642572">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1331" _type="Insert" date="Sun Apr 17 17:22:05 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6793" docExpressionCount="692" docLength="7881" length="1" offset="2896" starttimestamp="1650226882502" timestamp="3642718">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="1332" _type="InsertStringCommand" date="Sun Apr 17 17:22:05 EDT 2022" starttimestamp="1650226882502" timestamp="3642725" timestamp2="3642725">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="1333" _type="InsertStringCommand" date="Sun Apr 17 17:22:05 EDT 2022" starttimestamp="1650226882502" timestamp="3642725" timestamp2="3642725">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="1334" _type="Insert" date="Sun Apr 17 17:22:05 EDT 2022" docASTNodeCount="1123" docActiveCodeLength="6794" docExpressionCount="692" docLength="7882" length="1" offset="2897" starttimestamp="1650226882502" timestamp="3643388">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1335" _type="InsertStringCommand" date="Sun Apr 17 17:22:05 EDT 2022" starttimestamp="1650226882502" timestamp="3643388" timestamp2="3643388">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1336" _type="InsertStringCommand" date="Sun Apr 17 17:22:05 EDT 2022" starttimestamp="1650226882502" timestamp="3643388" timestamp2="3643388">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1337" _type="Insert" date="Sun Apr 17 17:22:15 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6795" docExpressionCount="693" docLength="7883" length="1" offset="2898" starttimestamp="1650226882502" timestamp="3652584">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="1338" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3652584" timestamp2="3652584">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1339" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3652584" timestamp2="3652584">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1340" _type="Insert" date="Sun Apr 17 17:22:15 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6796" docExpressionCount="693" docLength="7884" length="1" offset="2899" starttimestamp="1650226882502" timestamp="3652700">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1341" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3652700" timestamp2="3652700">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1342" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3652700" timestamp2="3652700">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="1343" _type="Insert" date="Sun Apr 17 17:22:15 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6797" docExpressionCount="693" docLength="7885" length="1" offset="2900" starttimestamp="1650226882502" timestamp="3652854">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1344" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3652854" timestamp2="3652854">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1345" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3652854" timestamp2="3652854">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1346" _type="Insert" date="Sun Apr 17 17:22:15 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6798" docExpressionCount="693" docLength="7886" length="1" offset="2901" starttimestamp="1650226882502" timestamp="3653070">
    <text><![CDATA[-]]></text>
  </DocumentChange>
  <Command __id="1347" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3653070" timestamp2="3653070">
    <data><![CDATA[-]]></data>
  </Command>
  <Command __id="1348" _type="InsertStringCommand" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3653070" timestamp2="3653070">
    <data><![CDATA[-]]></data>
  </Command>
  <DocumentChange __id="1349" _type="Delete" date="Sun Apr 17 17:22:15 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6797" docExpressionCount="693" docLength="7885" endLine="71" length="1" offset="2901" startLine="71" starttimestamp="1650226882502" timestamp="3653401">
    <text><![CDATA[-]]></text>
  </DocumentChange>
  <Command __id="1350" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3653401" />
  <Command __id="1351" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:15 EDT 2022" starttimestamp="1650226882502" timestamp="3653401" />
  <DocumentChange __id="1352" _type="Delete" date="Sun Apr 17 17:22:16 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6796" docExpressionCount="693" docLength="7884" endLine="71" length="1" offset="2900" startLine="71" starttimestamp="1650226882502" timestamp="3653554">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1353" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3653554" />
  <Command __id="1354" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3653554" />
  <DocumentChange __id="1355" _type="Insert" date="Sun Apr 17 17:22:16 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6797" docExpressionCount="693" docLength="7885" length="1" offset="2900" starttimestamp="1650226882502" timestamp="3653717">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="1356" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3653732" timestamp2="3653732">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1357" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3653732" timestamp2="3653732">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1358" _type="Insert" date="Sun Apr 17 17:22:16 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6798" docExpressionCount="693" docLength="7886" length="1" offset="2901" starttimestamp="1650226882502" timestamp="3653917">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1359" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3653917" timestamp2="3653917">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1360" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3653933" timestamp2="3653933">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1361" _type="Insert" date="Sun Apr 17 17:22:16 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6799" docExpressionCount="693" docLength="7887" length="1" offset="2902" starttimestamp="1650226882502" timestamp="3654071">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1362" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3654071" timestamp2="3654071">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1363" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3654071" timestamp2="3654071">
    <data><![CDATA[=]]></data>
  </Command>
  <DocumentChange __id="1364" _type="Insert" date="Sun Apr 17 17:22:16 EDT 2022" docASTNodeCount="1126" docActiveCodeLength="6800" docExpressionCount="693" docLength="7888" length="1" offset="2903" starttimestamp="1650226882502" timestamp="3654218">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1365" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3654233" timestamp2="3654233">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1366" _type="InsertStringCommand" date="Sun Apr 17 17:22:16 EDT 2022" starttimestamp="1650226882502" timestamp="3654233" timestamp2="3654233">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1367" _type="Insert" date="Sun Apr 17 17:22:18 EDT 2022" docASTNodeCount="1127" docActiveCodeLength="6801" docExpressionCount="694" docLength="7889" length="1" offset="2904" starttimestamp="1650226882502" timestamp="3655773">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1368" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3655773" timestamp2="3655773">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1369" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3655773" timestamp2="3655773">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1370" _type="Insert" date="Sun Apr 17 17:22:18 EDT 2022" docASTNodeCount="1127" docActiveCodeLength="6802" docExpressionCount="694" docLength="7890" length="1" offset="2905" starttimestamp="1650226882502" timestamp="3655820">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1371" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3655820" timestamp2="3655820">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1372" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3655820" timestamp2="3655820">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1373" _type="Insert" date="Sun Apr 17 17:22:18 EDT 2022" docASTNodeCount="1121" docActiveCodeLength="6803" docExpressionCount="691" docLength="7891" length="1" offset="2906" starttimestamp="1650226882502" timestamp="3655889">
    <text><![CDATA[w]]></text>
  </DocumentChange>
  <Command __id="1374" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3655889" timestamp2="3655889">
    <data><![CDATA[w]]></data>
  </Command>
  <Command __id="1375" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3655889" timestamp2="3655889">
    <data><![CDATA[w]]></data>
  </Command>
  <DocumentChange __id="1376" _type="Insert" date="Sun Apr 17 17:22:18 EDT 2022" docASTNodeCount="1121" docActiveCodeLength="6804" docExpressionCount="691" docLength="7892" length="1" offset="2907" starttimestamp="1650226882502" timestamp="3656106">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1377" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3656106" timestamp2="3656106">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1378" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3656106" timestamp2="3656106">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1379" _type="Insert" date="Sun Apr 17 17:22:18 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6805" docExpressionCount="695" docLength="7893" length="1" offset="2908" starttimestamp="1650226882502" timestamp="3656344">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <Command __id="1380" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3656344" timestamp2="3656344">
    <data><![CDATA[I]]></data>
  </Command>
  <Command __id="1381" _type="InsertStringCommand" date="Sun Apr 17 17:22:18 EDT 2022" starttimestamp="1650226882502" timestamp="3656344" timestamp2="3656344">
    <data><![CDATA[I]]></data>
  </Command>
  <DocumentChange __id="1382" _type="Insert" date="Sun Apr 17 17:22:19 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6806" docExpressionCount="695" docLength="7894" length="1" offset="2909" starttimestamp="1650226882502" timestamp="3656607">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1383" _type="InsertStringCommand" date="Sun Apr 17 17:22:19 EDT 2022" starttimestamp="1650226882502" timestamp="3656607" timestamp2="3656607">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1384" _type="InsertStringCommand" date="Sun Apr 17 17:22:19 EDT 2022" starttimestamp="1650226882502" timestamp="3656607" timestamp2="3656607">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="1385" _type="Insert" date="Sun Apr 17 17:22:19 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6807" docExpressionCount="695" docLength="7895" length="1" offset="2910" starttimestamp="1650226882502" timestamp="3656807">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1386" _type="InsertStringCommand" date="Sun Apr 17 17:22:19 EDT 2022" starttimestamp="1650226882502" timestamp="3656807" timestamp2="3656807">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1387" _type="InsertStringCommand" date="Sun Apr 17 17:22:19 EDT 2022" starttimestamp="1650226882502" timestamp="3656807" timestamp2="3656807">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1388" _type="Insert" date="Sun Apr 17 17:22:19 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6808" docExpressionCount="695" docLength="7896" length="1" offset="2911" starttimestamp="1650226882502" timestamp="3656977">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="1389" _type="InsertStringCommand" date="Sun Apr 17 17:22:19 EDT 2022" starttimestamp="1650226882502" timestamp="3656977" timestamp2="3656977">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="1390" _type="InsertStringCommand" date="Sun Apr 17 17:22:19 EDT 2022" starttimestamp="1650226882502" timestamp="3656977" timestamp2="3656977">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="1391" _type="Insert" date="Sun Apr 17 17:22:20 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6809" docExpressionCount="695" docLength="7897" length="1" offset="2912" starttimestamp="1650226882502" timestamp="3657847">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1392" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3657847" timestamp2="3657847">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1393" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3657847" timestamp2="3657847">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="1394" _type="Insert" date="Sun Apr 17 17:22:20 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6810" docExpressionCount="695" docLength="7898" length="1" offset="2913" starttimestamp="1650226882502" timestamp="3657994">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="1395" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3657994" timestamp2="3657994">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1396" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3657994" timestamp2="3657994">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1397" _type="Insert" date="Sun Apr 17 17:22:20 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6811" docExpressionCount="695" docLength="7899" length="1" offset="2914" starttimestamp="1650226882502" timestamp="3658394">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <Command __id="1398" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3658394" timestamp2="3658394">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="1399" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3658394" timestamp2="3658394">
    <data><![CDATA[f]]></data>
  </Command>
  <DocumentChange __id="1400" _type="Insert" date="Sun Apr 17 17:22:20 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6812" docExpressionCount="695" docLength="7900" length="1" offset="2915" starttimestamp="1650226882502" timestamp="3658479">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="1401" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3658494" timestamp2="3658494">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1402" _type="InsertStringCommand" date="Sun Apr 17 17:22:20 EDT 2022" starttimestamp="1650226882502" timestamp="3658494" timestamp2="3658494">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1403" _type="Insert" date="Sun Apr 17 17:22:21 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6813" docExpressionCount="695" docLength="7901" length="1" offset="2916" starttimestamp="1650226882502" timestamp="3658610">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="1404" _type="InsertStringCommand" date="Sun Apr 17 17:22:21 EDT 2022" starttimestamp="1650226882502" timestamp="3658610" timestamp2="3658610">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="1405" _type="InsertStringCommand" date="Sun Apr 17 17:22:21 EDT 2022" starttimestamp="1650226882502" timestamp="3658610" timestamp2="3658610">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="1406" _type="Insert" date="Sun Apr 17 17:22:21 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6814" docExpressionCount="695" docLength="7902" length="1" offset="2917" starttimestamp="1650226882502" timestamp="3658726">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="1407" _type="InsertStringCommand" date="Sun Apr 17 17:22:21 EDT 2022" starttimestamp="1650226882502" timestamp="3658742" timestamp2="3658742">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="1408" _type="InsertStringCommand" date="Sun Apr 17 17:22:21 EDT 2022" starttimestamp="1650226882502" timestamp="3658742" timestamp2="3658742">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="1409" _type="Insert" date="Sun Apr 17 17:22:22 EDT 2022" docASTNodeCount="1129" docActiveCodeLength="6816" docExpressionCount="695" docLength="7904" length="2" offset="2918" starttimestamp="1650226882502" timestamp="3659514">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="1410" _type="InsertStringCommand" date="Sun Apr 17 17:22:22 EDT 2022" starttimestamp="1650226882502" timestamp="3659520" timestamp2="3659520">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="1411" _type="InsertStringCommand" date="Sun Apr 17 17:22:22 EDT 2022" starttimestamp="1650226882502" timestamp="3659520" timestamp2="3659520">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="1412" _type="Insert" date="Sun Apr 17 17:22:22 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6817" docExpressionCount="696" docLength="7905" length="1" offset="2919" starttimestamp="1650226882502" timestamp="3660411">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1413" _type="InsertStringCommand" date="Sun Apr 17 17:22:22 EDT 2022" starttimestamp="1650226882502" timestamp="3660411" timestamp2="3660411">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1414" _type="InsertStringCommand" date="Sun Apr 17 17:22:22 EDT 2022" starttimestamp="1650226882502" timestamp="3660411" timestamp2="3660411">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="1415" _type="Insert" date="Sun Apr 17 17:22:23 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6818" docExpressionCount="696" docLength="7906" length="1" offset="2920" starttimestamp="1650226882502" timestamp="3660912">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="1416" _type="InsertStringCommand" date="Sun Apr 17 17:22:23 EDT 2022" starttimestamp="1650226882502" timestamp="3660912" timestamp2="3660912">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1417" _type="InsertStringCommand" date="Sun Apr 17 17:22:23 EDT 2022" starttimestamp="1650226882502" timestamp="3660912" timestamp2="3660912">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1418" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:22:23 EDT 2022" starttimestamp="1650226882502" timestamp="3661366" />
  <Command __id="1419" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:22:23 EDT 2022" starttimestamp="1650226882502" timestamp="3661366" />
  <DocumentChange __id="1420" _type="Insert" date="Sun Apr 17 17:22:24 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6819" docExpressionCount="696" docLength="7907" length="1" offset="2922" starttimestamp="1650226882502" timestamp="3661830">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="1421" _type="InsertStringCommand" date="Sun Apr 17 17:22:24 EDT 2022" starttimestamp="1650226882502" timestamp="3661830" timestamp2="3661830">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="1422" _type="InsertStringCommand" date="Sun Apr 17 17:22:24 EDT 2022" starttimestamp="1650226882502" timestamp="3661830" timestamp2="3661830">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="1423" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:22:25 EDT 2022" docASTNodeCount="60" docActiveCodeLength="295" docExpressionCount="32" docLength="399" projectName="pa3" starttimestamp="1650226882502" timestamp="3663265">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Token.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶/**¶ *  A token has a kind and a spelling¶ *  In a compiler it would also have a source position ¶ */¶public class Token {¶	public TokenKind kind;¶	public String spelling;¶	public SourcePosition posn;¶¶	public Token(TokenKind kind, String spelling, SourcePosition posn) {¶		this.kind = kind;¶		this.spelling = spelling;¶		this.posn = posn;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1424" _type="MoveCaretCommand" caretOffset="0" date="Sun Apr 17 17:22:25 EDT 2022" docOffset="0" starttimestamp="1650226882502" timestamp="3663312" />
  <Command __id="1425" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:22:29 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6819" docExpressionCount="696" docLength="7907" projectName="pa3" starttimestamp="1650226882502" timestamp="3666697">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶"), Diff(INSERT,"import miniJava.SyntacticAnalyzer.Token;¶"), Diff(EQUAL,"import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		Token t1 = new Token(TokenKind.ID, "_PrintStream", sp);¶		"), Diff(INSERT,"Identifier id1 = new Identifier(t1);¶		"), Diff(EQUAL,"¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		Token t1 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id1 = new Identifier(t1);
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="1426" _type="MoveCaretCommand" caretOffset="2923" date="Sun Apr 17 17:22:29 EDT 2022" docOffset="2923" starttimestamp="1650226882502" timestamp="3666759" />
  <Command __id="1427" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:22:30 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="3667905">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1428" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 17:22:30 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="3667962" />
  <Command __id="1429" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:22:34 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6819" docExpressionCount="696" docLength="7907" projectName="pa3" starttimestamp="1650226882502" timestamp="3671657">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		Token t1 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id1 = new Identifier(t1);¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1430" _type="MoveCaretCommand" caretOffset="2923" date="Sun Apr 17 17:22:34 EDT 2022" docOffset="2923" starttimestamp="1650226882502" timestamp="3671728" />
  <DocumentChange __id="1431" _type="Insert" date="Sun Apr 17 17:22:37 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6823" docExpressionCount="696" docLength="7911" length="4" offset="2923" starttimestamp="1650226882502" timestamp="3674933">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="1432" _type="InsertStringCommand" date="Sun Apr 17 17:22:37 EDT 2022" starttimestamp="1650226882502" timestamp="3674933" timestamp2="3674933">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1433" _type="InsertStringCommand" date="Sun Apr 17 17:22:37 EDT 2022" starttimestamp="1650226882502" timestamp="3674933" timestamp2="3674933">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1434" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:22:58 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="3695769">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1435" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 17:22:58 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="3695818" />
  <Command __id="1436" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:23:00 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6823" docExpressionCount="696" docLength="7911" projectName="pa3" starttimestamp="1650226882502" timestamp="3698345">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		Token t1 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id1 = new Identifier(t1);¶		¶		"), Diff(INSERT,"¶		"), Diff(EQUAL,"for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		Token t1 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id1 = new Identifier(t1);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="1437" _type="MoveCaretCommand" caretOffset="2927" date="Sun Apr 17 17:23:00 EDT 2022" docOffset="2927" starttimestamp="1650226882502" timestamp="3698407" />
  <DocumentChange __id="1438" _type="Insert" date="Sun Apr 17 17:23:03 EDT 2022" docASTNodeCount="1132" docActiveCodeLength="6824" docExpressionCount="697" docLength="7912" length="1" offset="2927" starttimestamp="1650226882502" timestamp="3700889">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="1439" _type="InsertStringCommand" date="Sun Apr 17 17:23:03 EDT 2022" starttimestamp="1650226882502" timestamp="3700889" timestamp2="3700889">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1440" _type="InsertStringCommand" date="Sun Apr 17 17:23:03 EDT 2022" starttimestamp="1650226882502" timestamp="3700889" timestamp2="3700889">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1441" _type="Insert" date="Sun Apr 17 17:23:03 EDT 2022" docASTNodeCount="1132" docActiveCodeLength="6825" docExpressionCount="697" docLength="7913" length="1" offset="2928" starttimestamp="1650226882502" timestamp="3700974">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1442" _type="InsertStringCommand" date="Sun Apr 17 17:23:03 EDT 2022" starttimestamp="1650226882502" timestamp="3700974" timestamp2="3700974">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1443" _type="InsertStringCommand" date="Sun Apr 17 17:23:03 EDT 2022" starttimestamp="1650226882502" timestamp="3700974" timestamp2="3700974">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="1444" _type="Insert" date="Sun Apr 17 17:23:03 EDT 2022" docASTNodeCount="1132" docActiveCodeLength="6826" docExpressionCount="697" docLength="7914" length="1" offset="2929" starttimestamp="1650226882502" timestamp="3701228">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="1445" _type="InsertStringCommand" date="Sun Apr 17 17:23:03 EDT 2022" starttimestamp="1650226882502" timestamp="3701243" timestamp2="3701243">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1446" _type="InsertStringCommand" date="Sun Apr 17 17:23:03 EDT 2022" starttimestamp="1650226882502" timestamp="3701243" timestamp2="3701243">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1447" _type="Insert" date="Sun Apr 17 17:23:04 EDT 2022" docASTNodeCount="1132" docActiveCodeLength="6827" docExpressionCount="697" docLength="7915" length="1" offset="2930" starttimestamp="1650226882502" timestamp="3701876">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="1448" _type="InsertStringCommand" date="Sun Apr 17 17:23:04 EDT 2022" starttimestamp="1650226882502" timestamp="3701891" timestamp2="3701891">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="1449" _type="InsertStringCommand" date="Sun Apr 17 17:23:04 EDT 2022" starttimestamp="1650226882502" timestamp="3701891" timestamp2="3701891">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="1450" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 17:23:04 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="3701891" />
  <DocumentChange __id="1451" _type="Insert" date="Sun Apr 17 17:23:04 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6828" docExpressionCount="699" docLength="7916" length="1" offset="2931" starttimestamp="1650226882502" timestamp="3701976">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1452" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 17:23:05 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="3702630" />
  <DocumentChange __id="1453" _type="Replace" date="Sun Apr 17 17:23:05 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6831" docExpressionCount="699" docLength="7919" endLine="72" insertionLength="4" int_docASTNodeCount="1132" int_docActiveCodeLength="6827" int_docExpressionCount="697" int_docLength="7915" length="1" offset="2931" startLine="72" starttimestamp="1650226882502" timestamp="3702630">
    <deletedText><![CDATA[d]]></deletedText>
    <insertedText><![CDATA[decl]]></insertedText>
  </DocumentChange>
  <Command __id="1454" _type="InsertStringCommand" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3702630" timestamp2="3702630">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1455" _type="InsertStringCommand" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3702630" timestamp2="3702630">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="1456" _type="Insert" date="Sun Apr 17 17:23:05 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6832" docExpressionCount="699" docLength="7920" length="1" offset="2935" starttimestamp="1650226882502" timestamp="3703093">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1457" _type="InsertStringCommand" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3703100" timestamp2="3703100">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1458" _type="InsertStringCommand" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3703100" timestamp2="3703100">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1459" _type="Insert" date="Sun Apr 17 17:23:05 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6833" docExpressionCount="696" docLength="7921" length="1" offset="2936" starttimestamp="1650226882502" timestamp="3703247">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1460" _type="InsertStringCommand" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3703247" timestamp2="3703247">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1461" _type="InsertStringCommand" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3703247" timestamp2="3703247">
    <data><![CDATA[=]]></data>
  </Command>
  <DocumentChange __id="1462" _type="Delete" date="Sun Apr 17 17:23:05 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6832" docExpressionCount="699" docLength="7920" endLine="72" length="1" offset="2936" startLine="72" starttimestamp="1650226882502" timestamp="3703262">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1463" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3703262" />
  <Command __id="1464" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:05 EDT 2022" starttimestamp="1650226882502" timestamp="3703262" />
  <DocumentChange __id="1465" _type="Insert" date="Sun Apr 17 17:23:06 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6833" docExpressionCount="699" docLength="7921" length="1" offset="2936" starttimestamp="1650226882502" timestamp="3703763">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1466" _type="InsertStringCommand" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3703763" timestamp2="3703763">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1467" _type="InsertStringCommand" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3703763" timestamp2="3703763">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1468" _type="Insert" date="Sun Apr 17 17:23:06 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6834" docExpressionCount="696" docLength="7922" length="1" offset="2937" starttimestamp="1650226882502" timestamp="3703848">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1469" _type="InsertStringCommand" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3703848" timestamp2="3703848">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1470" _type="InsertStringCommand" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3703848" timestamp2="3703848">
    <data><![CDATA[=]]></data>
  </Command>
  <DocumentChange __id="1471" _type="Insert" date="Sun Apr 17 17:23:06 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6835" docExpressionCount="696" docLength="7923" length="1" offset="2938" starttimestamp="1650226882502" timestamp="3703964">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1472" _type="InsertStringCommand" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3703979" timestamp2="3703979">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1473" _type="InsertStringCommand" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3703979" timestamp2="3703979">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1474" _type="Delete" date="Sun Apr 17 17:23:06 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6834" docExpressionCount="696" docLength="7922" endLine="72" length="1" offset="2938" startLine="72" starttimestamp="1650226882502" timestamp="3704233">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1475" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3704248" />
  <Command __id="1476" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3704248" />
  <DocumentChange __id="1477" _type="Delete" date="Sun Apr 17 17:23:06 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6833" docExpressionCount="699" docLength="7921" endLine="72" length="1" offset="2937" startLine="72" starttimestamp="1650226882502" timestamp="3704401">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1478" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3704401" />
  <Command __id="1479" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="3704401" />
  <DocumentChange __id="1480" _type="Delete" date="Sun Apr 17 17:23:07 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6832" docExpressionCount="699" docLength="7920" endLine="72" length="1" offset="2936" startLine="72" starttimestamp="1650226882502" timestamp="3704539">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1481" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3704541" />
  <Command __id="1482" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3704541" />
  <DocumentChange __id="1483" _type="Insert" date="Sun Apr 17 17:23:07 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6833" docExpressionCount="699" docLength="7921" length="1" offset="2936" starttimestamp="1650226882502" timestamp="3704795">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1484" _type="InsertStringCommand" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3704797" timestamp2="3704797">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1485" _type="InsertStringCommand" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3704798" timestamp2="3704798">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="1486" _type="Insert" date="Sun Apr 17 17:23:07 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6834" docExpressionCount="696" docLength="7922" length="1" offset="2937" starttimestamp="1650226882502" timestamp="3704874">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1487" _type="InsertStringCommand" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3704874" timestamp2="3704874">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1488" _type="InsertStringCommand" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3704874" timestamp2="3704874">
    <data><![CDATA[=]]></data>
  </Command>
  <DocumentChange __id="1489" _type="Delete" date="Sun Apr 17 17:23:07 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6833" docExpressionCount="699" docLength="7921" endLine="72" length="1" offset="2937" startLine="72" starttimestamp="1650226882502" timestamp="3705180">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1490" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3705180" />
  <Command __id="1491" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3705180" />
  <DocumentChange __id="1492" _type="Delete" date="Sun Apr 17 17:23:07 EDT 2022" docASTNodeCount="1134" docActiveCodeLength="6832" docExpressionCount="699" docLength="7920" endLine="72" length="1" offset="2936" startLine="72" starttimestamp="1650226882502" timestamp="3705348">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="1493" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3705348" />
  <Command __id="1494" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:23:07 EDT 2022" starttimestamp="1650226882502" timestamp="3705348" />
  <DocumentChange __id="1495" _type="Insert" date="Sun Apr 17 17:23:08 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6833" docExpressionCount="696" docLength="7921" length="1" offset="2936" starttimestamp="1650226882502" timestamp="3705501">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="1496" _type="InsertStringCommand" date="Sun Apr 17 17:23:08 EDT 2022" starttimestamp="1650226882502" timestamp="3705501" timestamp2="3705501">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1497" _type="InsertStringCommand" date="Sun Apr 17 17:23:08 EDT 2022" starttimestamp="1650226882502" timestamp="3705501" timestamp2="3705501">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="1499" _type="InsertStringCommand" date="Sun Apr 17 17:23:08 EDT 2022" starttimestamp="1650226882502" timestamp="3705617" timestamp2="3705617">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1500" _type="InsertStringCommand" date="Sun Apr 17 17:23:08 EDT 2022" starttimestamp="1650226882502" timestamp="3705617" timestamp2="3705617">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="1501" _type="ShellCommand" date="Sun Apr 17 17:23:15 EDT 2022" starttimestamp="1650226882502" timestamp="3712877" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1502" _type="ShellCommand" date="Sun Apr 17 17:24:21 EDT 2022" starttimestamp="1650226882502" timestamp="3778656" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1503" _type="MoveCaretCommand" caretOffset="2730" date="Sun Apr 17 17:24:21 EDT 2022" docOffset="2730" starttimestamp="1650226882502" timestamp="3778745" />
  <Command __id="1504" _type="MoveCaretCommand" caretOffset="2730" date="Sun Apr 17 17:24:21 EDT 2022" docOffset="2730" starttimestamp="1650226882502" timestamp="3778745" />
  <Command __id="1506" _type="InsertStringCommand" date="Sun Apr 17 17:24:21 EDT 2022" starttimestamp="1650226882502" timestamp="3779419" timestamp2="3779419">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1507" _type="InsertStringCommand" date="Sun Apr 17 17:24:21 EDT 2022" starttimestamp="1650226882502" timestamp="3779419" timestamp2="3779419">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1509" _type="InsertStringCommand" date="Sun Apr 17 17:24:22 EDT 2022" starttimestamp="1650226882502" timestamp="3779535" timestamp2="3779535">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1510" _type="InsertStringCommand" date="Sun Apr 17 17:24:22 EDT 2022" starttimestamp="1650226882502" timestamp="3779535" timestamp2="3779535">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1512" _type="PasteCommand" date="Sun Apr 17 17:24:22 EDT 2022" starttimestamp="1650226882502" timestamp="3779988" />
  <Command __id="1513" _type="SelectTextCommand" caretOffset="2757" date="Sun Apr 17 17:24:24 EDT 2022" end="2758" start="2757" starttimestamp="1650226882502" timestamp="3782006" />
  <Command __id="1514" _type="SelectTextCommand" caretOffset="2757" date="Sun Apr 17 17:24:24 EDT 2022" end="2758" start="2757" starttimestamp="1650226882502" timestamp="3782009" />
  <Command __id="1515" _type="MoveCaretCommand" caretOffset="2757" date="Sun Apr 17 17:24:24 EDT 2022" docOffset="2757" starttimestamp="1650226882502" timestamp="3782400" />
  <Command __id="1516" _type="MoveCaretCommand" caretOffset="2757" date="Sun Apr 17 17:24:24 EDT 2022" docOffset="2757" starttimestamp="1650226882502" timestamp="3782400" />
  <Command __id="1517" _type="SelectTextCommand" caretOffset="3085" date="Sun Apr 17 17:24:27 EDT 2022" end="3086" start="3085" starttimestamp="1650226882502" timestamp="3785265" />
  <Command __id="1518" _type="SelectTextCommand" caretOffset="3085" date="Sun Apr 17 17:24:27 EDT 2022" end="3086" start="3085" starttimestamp="1650226882502" timestamp="3785265" />
  <Command __id="1520" _type="InsertStringCommand" date="Sun Apr 17 17:24:27 EDT 2022" starttimestamp="1650226882502" timestamp="3785496" timestamp2="3785496">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1521" _type="InsertStringCommand" date="Sun Apr 17 17:24:27 EDT 2022" starttimestamp="1650226882502" timestamp="3785496" timestamp2="3785496">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1522" _type="SelectTextCommand" caretOffset="3130" date="Sun Apr 17 17:24:28 EDT 2022" end="3131" start="3130" starttimestamp="1650226882502" timestamp="3786449" />
  <Command __id="1523" _type="SelectTextCommand" caretOffset="3130" date="Sun Apr 17 17:24:28 EDT 2022" end="3131" start="3130" starttimestamp="1650226882502" timestamp="3786449" />
  <Command __id="1525" _type="InsertStringCommand" date="Sun Apr 17 17:24:28 EDT 2022" starttimestamp="1650226882502" timestamp="3786465" timestamp2="3786465">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1526" _type="InsertStringCommand" date="Sun Apr 17 17:24:28 EDT 2022" starttimestamp="1650226882502" timestamp="3786465" timestamp2="3786465">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1527" _type="SelectTextCommand" caretOffset="3232" date="Sun Apr 17 17:24:30 EDT 2022" end="3232" start="3231" starttimestamp="1650226882502" timestamp="3788168" />
  <Command __id="1528" _type="SelectTextCommand" caretOffset="3232" date="Sun Apr 17 17:24:30 EDT 2022" end="3232" start="3231" starttimestamp="1650226882502" timestamp="3788177" />
  <Command __id="1530" _type="InsertStringCommand" date="Sun Apr 17 17:24:30 EDT 2022" starttimestamp="1650226882502" timestamp="3788253" timestamp2="3788253">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1531" _type="InsertStringCommand" date="Sun Apr 17 17:24:30 EDT 2022" starttimestamp="1650226882502" timestamp="3788253" timestamp2="3788253">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1532" _type="SelectTextCommand" caretOffset="3166" date="Sun Apr 17 17:24:31 EDT 2022" end="3167" start="3166" starttimestamp="1650226882502" timestamp="3789345" />
  <Command __id="1533" _type="SelectTextCommand" caretOffset="3166" date="Sun Apr 17 17:24:31 EDT 2022" end="3167" start="3166" starttimestamp="1650226882502" timestamp="3789345" />
  <Command __id="1535" _type="InsertStringCommand" date="Sun Apr 17 17:24:31 EDT 2022" starttimestamp="1650226882502" timestamp="3789358" timestamp2="3789358">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1536" _type="InsertStringCommand" date="Sun Apr 17 17:24:31 EDT 2022" starttimestamp="1650226882502" timestamp="3789358" timestamp2="3789358">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1537" _type="MoveCaretCommand" caretOffset="3189" date="Sun Apr 17 17:24:32 EDT 2022" docOffset="3189" starttimestamp="1650226882502" timestamp="3789888" />
  <Command __id="1538" _type="MoveCaretCommand" caretOffset="3189" date="Sun Apr 17 17:24:32 EDT 2022" docOffset="3189" starttimestamp="1650226882502" timestamp="3789888" />
  <Command __id="1539" _type="SelectTextCommand" caretOffset="2754" date="Sun Apr 17 17:24:36 EDT 2022" end="2757" start="2754" starttimestamp="1650226882502" timestamp="3793624" />
  <Command __id="1540" _type="SelectTextCommand" caretOffset="2754" date="Sun Apr 17 17:24:36 EDT 2022" end="2757" start="2754" starttimestamp="1650226882502" timestamp="3793624" />
  <Command __id="1542" _type="InsertStringCommand" date="Sun Apr 17 17:24:36 EDT 2022" starttimestamp="1650226882502" timestamp="3793672" timestamp2="3793672">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1543" _type="InsertStringCommand" date="Sun Apr 17 17:24:36 EDT 2022" starttimestamp="1650226882502" timestamp="3793672" timestamp2="3793672">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1544" _type="SelectTextCommand" caretOffset="2799" date="Sun Apr 17 17:24:37 EDT 2022" end="2802" start="2799" starttimestamp="1650226882502" timestamp="3794920" />
  <Command __id="1545" _type="SelectTextCommand" caretOffset="2799" date="Sun Apr 17 17:24:37 EDT 2022" end="2802" start="2799" starttimestamp="1650226882502" timestamp="3794921" />
  <Command __id="1547" _type="InsertStringCommand" date="Sun Apr 17 17:24:37 EDT 2022" starttimestamp="1650226882502" timestamp="3794934" timestamp2="3794934">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1548" _type="InsertStringCommand" date="Sun Apr 17 17:24:37 EDT 2022" starttimestamp="1650226882502" timestamp="3794934" timestamp2="3794934">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1498" _type="Insert" date="Sun Apr 17 17:23:08 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6834" docExpressionCount="696" docLength="7922" length="1" offset="2937" starttimestamp="1650226882502" timestamp="3705617">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="1505" _type="Insert" date="Sun Apr 17 17:24:21 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6838" docExpressionCount="696" docLength="7926" length="4" offset="2730" starttimestamp="1650226882502" timestamp="3779404">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="1508" _type="Insert" date="Sun Apr 17 17:24:22 EDT 2022" docASTNodeCount="1130" docActiveCodeLength="6842" docExpressionCount="696" docLength="7930" length="4" offset="2734" starttimestamp="1650226882502" timestamp="3779535">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="1511" _type="Replace" date="Sun Apr 17 17:24:22 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7165" docExpressionCount="731" docLength="8253" endLine="68" insertionLength="325" int_docASTNodeCount="1130" int_docActiveCodeLength="6840" int_docExpressionCount="696" int_docLength="7928" length="2" offset="2736" startLine="68" starttimestamp="1650226882502" timestamp="3779988">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		FieldDeclList flist = new FieldDeclList();
		MethodDeclList mlist = new MethodDeclList();
		StatementList slist = new StatementList();
		ParameterDeclList plist = new ParameterDeclList();
		BaseType ptype = new BaseType(TypeKind.INT, sp);
		ParameterDecl pdecl = new ParameterDecl(ptype, "n", sp);
		plist.add(pdecl);]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1519" _type="Replace" date="Sun Apr 17 17:24:27 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7165" docExpressionCount="731" docLength="8253" endLine="76" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7164" int_docExpressionCount="731" int_docLength="8252" length="1" offset="3085" startLine="76" starttimestamp="1650226882502" timestamp="3785496">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[2]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1524" _type="Replace" date="Sun Apr 17 17:24:28 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7165" docExpressionCount="731" docLength="8253" endLine="77" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7164" int_docExpressionCount="731" int_docLength="8252" length="1" offset="3130" startLine="77" starttimestamp="1650226882502" timestamp="3786465">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[2]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1529" _type="Replace" date="Sun Apr 17 17:24:30 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7165" docExpressionCount="731" docLength="8253" endLine="79" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7164" int_docExpressionCount="731" int_docLength="8252" length="1" offset="3231" startLine="79" starttimestamp="1650226882502" timestamp="3788253">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[2]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1534" _type="Replace" date="Sun Apr 17 17:24:31 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7165" docExpressionCount="731" docLength="8253" endLine="78" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7164" int_docExpressionCount="731" int_docLength="8252" length="1" offset="3166" startLine="78" starttimestamp="1650226882502" timestamp="3789353">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[2]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1541" _type="Replace" date="Sun Apr 17 17:24:36 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7163" docExpressionCount="731" docLength="8251" endLine="68" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7162" int_docExpressionCount="731" int_docLength="8250" length="3" offset="2754" startLine="68" starttimestamp="1650226882502" timestamp="3793672">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1546" _type="Replace" date="Sun Apr 17 17:24:37 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7161" docExpressionCount="731" docLength="8249" endLine="69" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7160" int_docExpressionCount="731" int_docLength="8248" length="3" offset="2799" startLine="69" starttimestamp="1650226882502" timestamp="3794929">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1551" _type="Replace" date="Sun Apr 17 17:24:39 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7159" docExpressionCount="731" docLength="8247" endLine="70" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7158" int_docExpressionCount="731" int_docLength="8246" length="3" offset="2844" startLine="70" starttimestamp="1650226882502" timestamp="3797401">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <Command __id="1549" _type="SelectTextCommand" caretOffset="2844" date="Sun Apr 17 17:24:39 EDT 2022" end="2847" start="2844" starttimestamp="1650226882502" timestamp="3797367" />
  <Command __id="1550" _type="SelectTextCommand" caretOffset="2844" date="Sun Apr 17 17:24:39 EDT 2022" end="2847" start="2844" starttimestamp="1650226882502" timestamp="3797369" />
  <Command __id="1552" _type="InsertStringCommand" date="Sun Apr 17 17:24:39 EDT 2022" starttimestamp="1650226882502" timestamp="3797401" timestamp2="3797401">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1553" _type="InsertStringCommand" date="Sun Apr 17 17:24:39 EDT 2022" starttimestamp="1650226882502" timestamp="3797401" timestamp2="3797401">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1555" _type="InsertStringCommand" date="Sun Apr 17 17:24:41 EDT 2022" starttimestamp="1650226882502" timestamp="3799032" timestamp2="3799032">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1556" _type="InsertStringCommand" date="Sun Apr 17 17:24:41 EDT 2022" starttimestamp="1650226882502" timestamp="3799032" timestamp2="3799032">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1557" _type="MoveCaretCommand" caretOffset="2893" date="Sun Apr 17 17:24:41 EDT 2022" docOffset="2893" starttimestamp="1650226882502" timestamp="3799032" />
  <Command __id="1558" _type="MoveCaretCommand" caretOffset="2893" date="Sun Apr 17 17:24:41 EDT 2022" docOffset="2893" starttimestamp="1650226882502" timestamp="3799035" />
  <Command __id="1559" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:24:44 EDT 2022" starttimestamp="1650226882502" timestamp="3801720" />
  <Command __id="1560" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 17:24:44 EDT 2022" starttimestamp="1650226882502" timestamp="3801720" />
  <Command __id="1562" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:24:44 EDT 2022" starttimestamp="1650226882502" timestamp="3802243" />
  <Command __id="1563" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:24:44 EDT 2022" starttimestamp="1650226882502" timestamp="3802243" />
  <Command __id="1564" _type="SelectTextCommand" caretOffset="2933" date="Sun Apr 17 17:25:15 EDT 2022" end="2938" start="2933" starttimestamp="1650226882502" timestamp="3833360" />
  <Command __id="1565" _type="SelectTextCommand" caretOffset="2933" date="Sun Apr 17 17:25:15 EDT 2022" end="2938" start="2933" starttimestamp="1650226882502" timestamp="3833360" />
  <Command __id="1567" _type="InsertStringCommand" date="Sun Apr 17 17:25:16 EDT 2022" starttimestamp="1650226882502" timestamp="3834255" timestamp2="3834255">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="1568" _type="InsertStringCommand" date="Sun Apr 17 17:25:16 EDT 2022" starttimestamp="1650226882502" timestamp="3834255" timestamp2="3834255">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="1570" _type="InsertStringCommand" date="Sun Apr 17 17:25:17 EDT 2022" starttimestamp="1650226882502" timestamp="3834724" timestamp2="3834724">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1571" _type="InsertStringCommand" date="Sun Apr 17 17:25:17 EDT 2022" starttimestamp="1650226882502" timestamp="3834724" timestamp2="3834724">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1573" _type="InsertStringCommand" date="Sun Apr 17 17:25:17 EDT 2022" starttimestamp="1650226882502" timestamp="3835062" timestamp2="3835062">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1574" _type="InsertStringCommand" date="Sun Apr 17 17:25:17 EDT 2022" starttimestamp="1650226882502" timestamp="3835062" timestamp2="3835062">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1554" _type="Replace" date="Sun Apr 17 17:24:41 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7158" docExpressionCount="731" docLength="8246" endLine="71" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7157" int_docExpressionCount="731" int_docLength="8245" length="2" offset="2892" startLine="71" starttimestamp="1650226882502" timestamp="3799016">
    <deletedText><![CDATA[is]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1561" _type="Delete" date="Sun Apr 17 17:24:44 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7157" docExpressionCount="731" docLength="8245" endLine="71" length="1" offset="2893" startLine="71" starttimestamp="1650226882502" timestamp="3802243">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="1566" _type="Replace" date="Sun Apr 17 17:25:16 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7153" docExpressionCount="731" docLength="8241" endLine="72" insertionLength="1" int_docASTNodeCount="1188" int_docActiveCodeLength="7152" int_docExpressionCount="731" int_docLength="8240" length="5" offset="2933" startLine="72" starttimestamp="1650226882502" timestamp="3834240">
    <deletedText><![CDATA[ptype]]></deletedText>
    <insertedText><![CDATA[b]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1569" _type="Insert" date="Sun Apr 17 17:25:17 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7154" docExpressionCount="731" docLength="8242" length="1" offset="2934" starttimestamp="1650226882502" timestamp="3834721">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="1572" _type="Insert" date="Sun Apr 17 17:25:17 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7155" docExpressionCount="731" docLength="8243" length="1" offset="2935" starttimestamp="1650226882502" timestamp="3835062">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="1575" _type="MoveCaretCommand" caretOffset="3017" date="Sun Apr 17 17:25:20 EDT 2022" docOffset="3017" starttimestamp="1650226882502" timestamp="3838264" />
  <Command __id="1576" _type="MoveCaretCommand" caretOffset="3017" date="Sun Apr 17 17:25:20 EDT 2022" docOffset="3017" starttimestamp="1650226882502" timestamp="3838264" />
  <Command __id="1577" _type="SelectTextCommand" caretOffset="3019" date="Sun Apr 17 17:25:20 EDT 2022" end="3019" start="3014" starttimestamp="1650226882502" timestamp="3838432" />
  <Command __id="1578" _type="SelectTextCommand" caretOffset="3019" date="Sun Apr 17 17:25:20 EDT 2022" end="3019" start="3014" starttimestamp="1650226882502" timestamp="3838432" />
  <DocumentChange __id="1579" _type="Replace" date="Sun Apr 17 17:25:22 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7151" docExpressionCount="731" docLength="8239" endLine="73" insertionLength="1" int_docASTNodeCount="1189" int_docActiveCodeLength="7150" int_docExpressionCount="730" int_docLength="8238" length="5" offset="3014" startLine="73" starttimestamp="1650226882502" timestamp="3840038">
    <deletedText><![CDATA[ptype]]></deletedText>
    <insertedText><![CDATA[b]]></insertedText>
  </DocumentChange>
  <Command __id="1580" _type="InsertStringCommand" date="Sun Apr 17 17:25:22 EDT 2022" starttimestamp="1650226882502" timestamp="3840054" timestamp2="3840054">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="1581" _type="InsertStringCommand" date="Sun Apr 17 17:25:22 EDT 2022" starttimestamp="1650226882502" timestamp="3840054" timestamp2="3840054">
    <data><![CDATA[b]]></data>
  </Command>
  <DocumentChange __id="1582" _type="Insert" date="Sun Apr 17 17:25:23 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7152" docExpressionCount="731" docLength="8240" length="1" offset="3015" starttimestamp="1650226882502" timestamp="3840634">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1583" _type="InsertStringCommand" date="Sun Apr 17 17:25:23 EDT 2022" starttimestamp="1650226882502" timestamp="3840634" timestamp2="3840634">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1584" _type="InsertStringCommand" date="Sun Apr 17 17:25:23 EDT 2022" starttimestamp="1650226882502" timestamp="3840634" timestamp2="3840634">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1586" _type="InsertStringCommand" date="Sun Apr 17 17:25:23 EDT 2022" starttimestamp="1650226882502" timestamp="3840802" timestamp2="3840802">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1587" _type="InsertStringCommand" date="Sun Apr 17 17:25:23 EDT 2022" starttimestamp="1650226882502" timestamp="3840802" timestamp2="3840802">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1588" _type="MoveCaretCommand" caretOffset="2970" date="Sun Apr 17 17:25:25 EDT 2022" docOffset="2970" starttimestamp="1650226882502" timestamp="3842992" />
  <Command __id="1589" _type="MoveCaretCommand" caretOffset="2970" date="Sun Apr 17 17:25:25 EDT 2022" docOffset="2970" starttimestamp="1650226882502" timestamp="3842992" />
  <Command __id="1590" _type="SelectTextCommand" caretOffset="3034" date="Sun Apr 17 17:26:08 EDT 2022" end="3037" start="3034" starttimestamp="1650226882502" timestamp="3885856" />
  <Command __id="1591" _type="SelectTextCommand" caretOffset="3034" date="Sun Apr 17 17:26:08 EDT 2022" end="3037" start="3034" starttimestamp="1650226882502" timestamp="3885856" />
  <Command __id="1593" _type="InsertStringCommand" date="Sun Apr 17 17:26:08 EDT 2022" starttimestamp="1650226882502" timestamp="3885869" timestamp2="3885869">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1594" _type="InsertStringCommand" date="Sun Apr 17 17:26:08 EDT 2022" starttimestamp="1650226882502" timestamp="3885869" timestamp2="3885869">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1585" _type="Insert" date="Sun Apr 17 17:25:23 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7153" docExpressionCount="731" docLength="8241" length="1" offset="3016" starttimestamp="1650226882502" timestamp="3840802">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="1592" _type="Replace" date="Sun Apr 17 17:26:08 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7151" docExpressionCount="731" docLength="8239" endLine="74" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7150" int_docExpressionCount="731" int_docLength="8238" length="3" offset="3034" startLine="74" starttimestamp="1650226882502" timestamp="3885865">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1597" _type="Replace" date="Sun Apr 17 17:26:12 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7149" docExpressionCount="731" docLength="8237" endLine="73" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7148" int_docExpressionCount="731" int_docLength="8236" length="3" offset="2990" startLine="73" starttimestamp="1650226882502" timestamp="3889945">
    <deletedText><![CDATA[ecl]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <Command __id="1595" _type="SelectTextCommand" caretOffset="2990" date="Sun Apr 17 17:26:12 EDT 2022" end="2993" start="2990" starttimestamp="1650226882502" timestamp="3889928" />
  <Command __id="1596" _type="SelectTextCommand" caretOffset="2990" date="Sun Apr 17 17:26:12 EDT 2022" end="2993" start="2990" starttimestamp="1650226882502" timestamp="3889928" />
  <Command __id="1598" _type="InsertStringCommand" date="Sun Apr 17 17:26:12 EDT 2022" starttimestamp="1650226882502" timestamp="3889951" timestamp2="3889951">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1599" _type="InsertStringCommand" date="Sun Apr 17 17:26:12 EDT 2022" starttimestamp="1650226882502" timestamp="3889951" timestamp2="3889951">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1601" _type="InsertStringCommand" date="Sun Apr 17 17:26:14 EDT 2022" starttimestamp="1650226882502" timestamp="3891576" timestamp2="3891576">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1602" _type="InsertStringCommand" date="Sun Apr 17 17:26:14 EDT 2022" starttimestamp="1650226882502" timestamp="3891576" timestamp2="3891576">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1603" _type="MoveCaretCommand" caretOffset="3041" date="Sun Apr 17 17:26:14 EDT 2022" docOffset="3041" starttimestamp="1650226882502" timestamp="3891576" />
  <Command __id="1604" _type="MoveCaretCommand" caretOffset="3041" date="Sun Apr 17 17:26:14 EDT 2022" docOffset="3041" starttimestamp="1650226882502" timestamp="3891576" />
  <Command __id="1605" _type="MoveCaretCommand" caretOffset="3043" date="Sun Apr 17 17:26:14 EDT 2022" docOffset="3043" starttimestamp="1650226882502" timestamp="3892015" />
  <Command __id="1606" _type="MoveCaretCommand" caretOffset="3043" date="Sun Apr 17 17:26:14 EDT 2022" docOffset="3043" starttimestamp="1650226882502" timestamp="3892024" />
  <Command __id="1607" _type="ShellCommand" date="Sun Apr 17 17:26:45 EDT 2022" starttimestamp="1650226882502" timestamp="3923190" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1608" _type="ShellCommand" date="Sun Apr 17 17:26:49 EDT 2022" starttimestamp="1650226882502" timestamp="3926505" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1609" _type="MoveCaretCommand" caretOffset="3043" date="Sun Apr 17 17:26:49 EDT 2022" docOffset="3043" starttimestamp="1650226882502" timestamp="3926593" />
  <Command __id="1610" _type="MoveCaretCommand" caretOffset="3043" date="Sun Apr 17 17:26:49 EDT 2022" docOffset="3043" starttimestamp="1650226882502" timestamp="3926593" />
  <Command __id="1612" _type="InsertStringCommand" date="Sun Apr 17 17:26:49 EDT 2022" starttimestamp="1650226882502" timestamp="3927129" timestamp2="3927129">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1613" _type="InsertStringCommand" date="Sun Apr 17 17:26:49 EDT 2022" starttimestamp="1650226882502" timestamp="3927129" timestamp2="3927129">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1615" _type="InsertStringCommand" date="Sun Apr 17 17:26:49 EDT 2022" starttimestamp="1650226882502" timestamp="3927283" timestamp2="3927283">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1616" _type="InsertStringCommand" date="Sun Apr 17 17:26:49 EDT 2022" starttimestamp="1650226882502" timestamp="3927283" timestamp2="3927283">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1618" _type="PasteCommand" date="Sun Apr 17 17:26:49 EDT 2022" starttimestamp="1650226882502" timestamp="3927468" />
  <DocumentChange __id="1600" _type="Replace" date="Sun Apr 17 17:26:14 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7147" docExpressionCount="731" docLength="8235" endLine="74" insertionLength="1" int_docASTNodeCount="1190" int_docActiveCodeLength="7146" int_docExpressionCount="731" int_docLength="8234" length="3" offset="3040" startLine="74" starttimestamp="1650226882502" timestamp="3891576">
    <deletedText><![CDATA[ecl]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1611" _type="Insert" date="Sun Apr 17 17:26:49 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7151" docExpressionCount="731" docLength="8239" length="4" offset="3043" starttimestamp="1650226882502" timestamp="3927114">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="1614" _type="Insert" date="Sun Apr 17 17:26:49 EDT 2022" docASTNodeCount="1190" docActiveCodeLength="7155" docExpressionCount="731" docLength="8243" length="4" offset="3047" starttimestamp="1650226882502" timestamp="3927283">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="1617" _type="Replace" date="Sun Apr 17 17:26:49 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7430" docExpressionCount="768" docLength="8518" endLine="76" insertionLength="277" int_docASTNodeCount="1190" int_docActiveCodeLength="7153" int_docExpressionCount="731" int_docLength="8241" length="2" offset="3049" startLine="76" starttimestamp="1650226882502" timestamp="3927468">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		BaseType mtype = new BaseType(TypeKind.VOID, sp);
		FieldDecl fdecl = new FieldDecl(false, false, mtype, "println", sp);
		MethodDecl mdecl = new MethodDecl(fdecl, plist, slist, sp);
		mlist.add(mdecl);
		ClassDecl cdecl = new ClassDecl("_PrintStream", flist, mlist, sp);]]></insertedText>
  </DocumentChange>
  <Command __id="1619" _type="MoveCaretCommand" caretOffset="3062" date="Sun Apr 17 17:26:52 EDT 2022" docOffset="3062" starttimestamp="1650226882502" timestamp="3929655" />
  <Command __id="1620" _type="MoveCaretCommand" caretOffset="3062" date="Sun Apr 17 17:26:52 EDT 2022" docOffset="3062" starttimestamp="1650226882502" timestamp="3929664" />
  <Command __id="1621" _type="SelectTextCommand" caretOffset="3065" date="Sun Apr 17 17:26:52 EDT 2022" end="3065" start="3060" starttimestamp="1650226882502" timestamp="3929800" />
  <Command __id="1622" _type="SelectTextCommand" caretOffset="3065" date="Sun Apr 17 17:26:52 EDT 2022" end="3065" start="3060" starttimestamp="1650226882502" timestamp="3929800" />
  <DocumentChange __id="1623" _type="Replace" date="Sun Apr 17 17:26:53 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7426" docExpressionCount="768" docLength="8514" endLine="76" insertionLength="1" int_docASTNodeCount="1242" int_docActiveCodeLength="7425" int_docExpressionCount="768" int_docLength="8513" length="5" offset="3060" startLine="76" starttimestamp="1650226882502" timestamp="3931119">
    <deletedText><![CDATA[mtype]]></deletedText>
    <insertedText><![CDATA[b]]></insertedText>
  </DocumentChange>
  <Command __id="1624" _type="InsertStringCommand" date="Sun Apr 17 17:26:53 EDT 2022" starttimestamp="1650226882502" timestamp="3931119" timestamp2="3931119">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="1625" _type="InsertStringCommand" date="Sun Apr 17 17:26:53 EDT 2022" starttimestamp="1650226882502" timestamp="3931119" timestamp2="3931119">
    <data><![CDATA[b]]></data>
  </Command>
  <DocumentChange __id="1626" _type="Insert" date="Sun Apr 17 17:26:54 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7427" docExpressionCount="768" docLength="8515" length="1" offset="3061" starttimestamp="1650226882502" timestamp="3931720">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1627" _type="InsertStringCommand" date="Sun Apr 17 17:26:54 EDT 2022" starttimestamp="1650226882502" timestamp="3931720" timestamp2="3931720">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1628" _type="InsertStringCommand" date="Sun Apr 17 17:26:54 EDT 2022" starttimestamp="1650226882502" timestamp="3931720" timestamp2="3931720">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1630" _type="InsertStringCommand" date="Sun Apr 17 17:26:54 EDT 2022" starttimestamp="1650226882502" timestamp="3932142" timestamp2="3932142">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1631" _type="InsertStringCommand" date="Sun Apr 17 17:26:54 EDT 2022" starttimestamp="1650226882502" timestamp="3932142" timestamp2="3932142">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1632" _type="SelectTextCommand" caretOffset="3113" date="Sun Apr 17 17:27:16 EDT 2022" end="3117" start="3113" starttimestamp="1650226882502" timestamp="3954056" />
  <Command __id="1633" _type="SelectTextCommand" caretOffset="3113" date="Sun Apr 17 17:27:16 EDT 2022" end="3117" start="3113" starttimestamp="1650226882502" timestamp="3954056" />
  <Command __id="1634" _type="MoveCaretCommand" caretOffset="3115" date="Sun Apr 17 17:27:17 EDT 2022" docOffset="3115" starttimestamp="1650226882502" timestamp="3954569" />
  <Command __id="1635" _type="MoveCaretCommand" caretOffset="3115" date="Sun Apr 17 17:27:17 EDT 2022" docOffset="3115" starttimestamp="1650226882502" timestamp="3954569" />
  <DocumentChange __id="1629" _type="Insert" date="Sun Apr 17 17:26:54 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7428" docExpressionCount="768" docLength="8516" length="1" offset="3062" starttimestamp="1650226882502" timestamp="3932142">
    <text><![CDATA[2]]></text>
  </DocumentChange>
  <Command __id="1636" _type="SelectTextCommand" caretOffset="3114" date="Sun Apr 17 17:27:18 EDT 2022" end="3117" start="3114" starttimestamp="1650226882502" timestamp="3956048" />
  <Command __id="1637" _type="SelectTextCommand" caretOffset="3114" date="Sun Apr 17 17:27:18 EDT 2022" end="3117" start="3114" starttimestamp="1650226882502" timestamp="3956049" />
  <Command __id="1639" _type="InsertStringCommand" date="Sun Apr 17 17:27:27 EDT 2022" starttimestamp="1650226882502" timestamp="3964945" timestamp2="3964945">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1640" _type="InsertStringCommand" date="Sun Apr 17 17:27:27 EDT 2022" starttimestamp="1650226882502" timestamp="3964945" timestamp2="3964945">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1638" _type="Replace" date="Sun Apr 17 17:27:27 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7426" docExpressionCount="768" docLength="8514" endLine="77" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7425" int_docExpressionCount="768" int_docLength="8513" length="3" offset="3114" startLine="77" starttimestamp="1650226882502" timestamp="3964940">
    <deletedText><![CDATA[ecl]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <Command __id="1641" _type="SelectTextCommand" caretOffset="3146" date="Sun Apr 17 17:27:34 EDT 2022" end="3151" start="3146" starttimestamp="1650226882502" timestamp="3971976" />
  <Command __id="1642" _type="SelectTextCommand" caretOffset="3146" date="Sun Apr 17 17:27:34 EDT 2022" end="3151" start="3146" starttimestamp="1650226882502" timestamp="3971976" />
  <DocumentChange __id="1643" _type="Replace" date="Sun Apr 17 17:27:45 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7422" docExpressionCount="768" docLength="8510" endLine="77" insertionLength="1" int_docASTNodeCount="1243" int_docActiveCodeLength="7421" int_docExpressionCount="767" int_docLength="8509" length="5" offset="3146" startLine="77" starttimestamp="1650226882502" timestamp="3983115">
    <deletedText><![CDATA[mtype]]></deletedText>
    <insertedText><![CDATA[b]]></insertedText>
  </DocumentChange>
  <Command __id="1644" _type="InsertStringCommand" date="Sun Apr 17 17:27:45 EDT 2022" starttimestamp="1650226882502" timestamp="3983130" timestamp2="3983130">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="1645" _type="InsertStringCommand" date="Sun Apr 17 17:27:45 EDT 2022" starttimestamp="1650226882502" timestamp="3983130" timestamp2="3983130">
    <data><![CDATA[b]]></data>
  </Command>
  <DocumentChange __id="1646" _type="Insert" date="Sun Apr 17 17:27:46 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7423" docExpressionCount="768" docLength="8511" length="1" offset="3147" starttimestamp="1650226882502" timestamp="3983531">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="1647" _type="InsertStringCommand" date="Sun Apr 17 17:27:46 EDT 2022" starttimestamp="1650226882502" timestamp="3983531" timestamp2="3983531">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1648" _type="InsertStringCommand" date="Sun Apr 17 17:27:46 EDT 2022" starttimestamp="1650226882502" timestamp="3983531" timestamp2="3983531">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="1649" _type="Insert" date="Sun Apr 17 17:27:46 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7424" docExpressionCount="768" docLength="8512" length="1" offset="3148" starttimestamp="1650226882502" timestamp="3983794">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="1650" _type="InsertStringCommand" date="Sun Apr 17 17:27:46 EDT 2022" starttimestamp="1650226882502" timestamp="3983794" timestamp2="3983794">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1651" _type="InsertStringCommand" date="Sun Apr 17 17:27:46 EDT 2022" starttimestamp="1650226882502" timestamp="3983794" timestamp2="3983794">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1652" _type="Delete" date="Sun Apr 17 17:27:53 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7422" docExpressionCount="768" docLength="8510" endLine="77" length="2" offset="3147" startLine="77" starttimestamp="1650226882502" timestamp="3991275">
    <text><![CDATA[t1]]></text>
  </DocumentChange>
  <Command __id="1653" _type="UndoCommand" date="Sun Apr 17 17:27:53 EDT 2022" starttimestamp="1650226882502" timestamp="3991290" />
  <Command __id="1655" _type="UndoCommand" date="Sun Apr 17 17:27:54 EDT 2022" starttimestamp="1650226882502" timestamp="3991829" />
  <Command __id="1656" _type="ShellCommand" date="Sun Apr 17 17:27:58 EDT 2022" starttimestamp="1650226882502" timestamp="3996069" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1657" _type="ShellCommand" date="Sun Apr 17 17:28:04 EDT 2022" starttimestamp="1650226882502" timestamp="4001710" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1658" _type="MoveCaretCommand" caretOffset="3062" date="Sun Apr 17 17:28:04 EDT 2022" docOffset="3062" starttimestamp="1650226882502" timestamp="4001760" />
  <Command __id="1659" _type="MoveCaretCommand" caretOffset="3062" date="Sun Apr 17 17:28:04 EDT 2022" docOffset="3062" starttimestamp="1650226882502" timestamp="4001760" />
  <Command __id="1660" _type="SelectTextCommand" caretOffset="3063" date="Sun Apr 17 17:28:04 EDT 2022" end="3063" start="3060" starttimestamp="1650226882502" timestamp="4001913" />
  <Command __id="1661" _type="SelectTextCommand" caretOffset="3063" date="Sun Apr 17 17:28:04 EDT 2022" end="3063" start="3060" starttimestamp="1650226882502" timestamp="4001913" />
  <Command __id="1662" _type="CopyCommand" date="Sun Apr 17 17:28:04 EDT 2022" starttimestamp="1650226882502" timestamp="4002097" />
  <Command __id="1663" _type="MoveCaretCommand" caretOffset="3147" date="Sun Apr 17 17:28:05 EDT 2022" docOffset="3147" starttimestamp="1650226882502" timestamp="4002899" />
  <Command __id="1664" _type="MoveCaretCommand" caretOffset="3147" date="Sun Apr 17 17:28:05 EDT 2022" docOffset="3147" starttimestamp="1650226882502" timestamp="4002904" />
  <Command __id="1665" _type="SelectTextCommand" caretOffset="3151" date="Sun Apr 17 17:28:05 EDT 2022" end="3151" start="3146" starttimestamp="1650226882502" timestamp="4003031" />
  <Command __id="1666" _type="SelectTextCommand" caretOffset="3151" date="Sun Apr 17 17:28:05 EDT 2022" end="3151" start="3146" starttimestamp="1650226882502" timestamp="4003031" />
  <Command __id="1668" _type="PasteCommand" date="Sun Apr 17 17:28:05 EDT 2022" starttimestamp="1650226882502" timestamp="4003168" />
  <Command __id="1669" _type="MoveCaretCommand" caretOffset="3166" date="Sun Apr 17 17:28:07 EDT 2022" docOffset="3166" starttimestamp="1650226882502" timestamp="4005048" />
  <Command __id="1670" _type="MoveCaretCommand" caretOffset="3166" date="Sun Apr 17 17:28:07 EDT 2022" docOffset="3166" starttimestamp="1650226882502" timestamp="4005049" />
  <Command __id="1671" _type="MoveCaretCommand" caretOffset="3193" date="Sun Apr 17 17:28:17 EDT 2022" docOffset="3193" starttimestamp="1650226882502" timestamp="4015444" />
  <Command __id="1672" _type="MoveCaretCommand" caretOffset="3193" date="Sun Apr 17 17:28:17 EDT 2022" docOffset="3193" starttimestamp="1650226882502" timestamp="4015448" />
  <Command __id="1673" _type="MoveCaretCommand" caretOffset="3179" date="Sun Apr 17 17:28:18 EDT 2022" docOffset="3179" starttimestamp="1650226882502" timestamp="4015798" />
  <Command __id="1674" _type="MoveCaretCommand" caretOffset="3179" date="Sun Apr 17 17:28:18 EDT 2022" docOffset="3179" starttimestamp="1650226882502" timestamp="4015808" />
  <Command __id="1675" _type="SelectTextCommand" caretOffset="3183" date="Sun Apr 17 17:28:38 EDT 2022" end="3186" start="3183" starttimestamp="1650226882502" timestamp="4035932" />
  <Command __id="1676" _type="SelectTextCommand" caretOffset="3183" date="Sun Apr 17 17:28:38 EDT 2022" end="3186" start="3183" starttimestamp="1650226882502" timestamp="4035932" />
  <Command __id="1678" _type="InsertStringCommand" date="Sun Apr 17 17:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="4035961" timestamp2="4035961">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1679" _type="InsertStringCommand" date="Sun Apr 17 17:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="4035961" timestamp2="4035961">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1680" _type="SelectTextCommand" caretOffset="3204" date="Sun Apr 17 17:28:42 EDT 2022" end="3207" start="3204" starttimestamp="1650226882502" timestamp="4039824" />
  <Command __id="1681" _type="SelectTextCommand" caretOffset="3204" date="Sun Apr 17 17:28:42 EDT 2022" end="3207" start="3204" starttimestamp="1650226882502" timestamp="4039824" />
  <Command __id="1683" _type="InsertStringCommand" date="Sun Apr 17 17:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="4040149" timestamp2="4040149">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1684" _type="InsertStringCommand" date="Sun Apr 17 17:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="4040149" timestamp2="4040149">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1654" _type="Replace" date="Sun Apr 17 17:27:54 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7426" docExpressionCount="768" docLength="8514" endLine="77" insertionLength="5" int_docASTNodeCount="1243" int_docActiveCodeLength="7421" int_docExpressionCount="767" int_docLength="8509" length="1" offset="3146" startLine="77" starttimestamp="1650226882502" timestamp="3991813">
    <deletedText><![CDATA[b]]></deletedText>
    <insertedText><![CDATA[mtype]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1667" _type="Replace" date="Sun Apr 17 17:28:05 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7424" docExpressionCount="768" docLength="8512" endLine="77" insertionLength="3" int_docASTNodeCount="1243" int_docActiveCodeLength="7421" int_docExpressionCount="767" int_docLength="8509" length="5" offset="3146" startLine="77" starttimestamp="1650226882502" timestamp="4003168">
    <deletedText><![CDATA[mtype]]></deletedText>
    <insertedText><![CDATA[bt2]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1677" _type="Replace" date="Sun Apr 17 17:28:38 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7422" docExpressionCount="768" docLength="8510" endLine="78" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7421" int_docExpressionCount="768" int_docLength="8509" length="3" offset="3183" startLine="78" starttimestamp="1650226882502" timestamp="4035961">
    <deletedText><![CDATA[ecl]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1682" _type="Replace" date="Sun Apr 17 17:28:42 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7420" docExpressionCount="768" docLength="8508" endLine="78" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7419" int_docExpressionCount="768" int_docLength="8507" length="3" offset="3204" startLine="78" starttimestamp="1650226882502" timestamp="4040144">
    <deletedText><![CDATA[ecl]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <Command __id="1685" _type="SelectTextCommand" caretOffset="3209" date="Sun Apr 17 17:28:44 EDT 2022" end="3212" start="3209" starttimestamp="1650226882502" timestamp="4041968" />
  <Command __id="1686" _type="SelectTextCommand" caretOffset="3209" date="Sun Apr 17 17:28:44 EDT 2022" end="3212" start="3209" starttimestamp="1650226882502" timestamp="4041968" />
  <Command __id="1688" _type="InsertStringCommand" date="Sun Apr 17 17:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="4043527" timestamp2="4043527">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1689" _type="InsertStringCommand" date="Sun Apr 17 17:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="4043527" timestamp2="4043527">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1687" _type="Replace" date="Sun Apr 17 17:28:46 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7418" docExpressionCount="768" docLength="8506" endLine="78" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7417" int_docExpressionCount="768" int_docLength="8505" length="3" offset="3209" startLine="78" starttimestamp="1650226882502" timestamp="4043527">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1692" _type="Replace" date="Sun Apr 17 17:28:47 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7416" docExpressionCount="768" docLength="8504" endLine="78" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7415" int_docExpressionCount="768" int_docLength="8503" length="3" offset="3214" startLine="78" starttimestamp="1650226882502" timestamp="4045473">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <Command __id="1697" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:29:18 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="4075913">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="1699" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:19 EDT 2022" docASTNodeCount="101" docActiveCodeLength="629" docExpressionCount="60" docLength="726" projectName="pa3" starttimestamp="1650226882502" timestamp="4316714">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MemberDecl.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

abstract public class MemberDecl extends Declaration {

    public MemberDecl(boolean isPrivate, boolean isStatic, TypeDenoter mt, String name, SourcePosition posn) {
        super(name, mt, posn);
        this.isPrivate = isPrivate;
        this.isStatic = isStatic;
    }
    
    public MemberDecl(MemberDecl md, SourcePosition posn){
    	super(md.name, md.type, posn);
    	this.isPrivate = md.isPrivate;
    	this.isStatic = md.isStatic;
    }
    
    public boolean isPrivate;
    public boolean isStatic;
}
]]></snapshot>
  </Command>
  <Command __id="1701" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:21 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="4318624">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="1703" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:37 EDT 2022" docASTNodeCount="101" docActiveCodeLength="629" docExpressionCount="60" docLength="726" projectName="pa3" starttimestamp="1650226882502" timestamp="4334752">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MemberDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶abstract public class MemberDecl extends Declaration {¶¶    public MemberDecl(boolean isPrivate, boolean isStatic, TypeDenoter mt, String name, SourcePosition posn) {¶        super(name, mt, posn);¶        this.isPrivate = isPrivate;¶        this.isStatic = isStatic;¶    }¶    ¶    public MemberDecl(MemberDecl md, SourcePosition posn){¶    	super(md.name, md.type, posn);¶    	this.isPrivate = md.isPrivate;¶    	this.isStatic = md.isStatic;¶    }¶    ¶    public boolean isPrivate;¶    public boolean isStatic;¶}¶")]]]></diff>
  </Command>
  <Command __id="1705" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:43 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="4340589">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="1707" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:44 EDT 2022" docASTNodeCount="101" docActiveCodeLength="629" docExpressionCount="60" docLength="726" projectName="pa3" starttimestamp="1650226882502" timestamp="4341504">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MemberDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶abstract public class MemberDecl extends Declaration {¶¶    public MemberDecl(boolean isPrivate, boolean isStatic, TypeDenoter mt, String name, SourcePosition posn) {¶        super(name, mt, posn);¶        this.isPrivate = isPrivate;¶        this.isStatic = isStatic;¶    }¶    ¶    public MemberDecl(MemberDecl md, SourcePosition posn){¶    	super(md.name, md.type, posn);¶    	this.isPrivate = md.isPrivate;¶    	this.isStatic = md.isStatic;¶    }¶    ¶    public boolean isPrivate;¶    public boolean isStatic;¶}¶")]]]></diff>
  </Command>
  <Command __id="1709" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:44 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="4342344">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="1711" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:45 EDT 2022" docASTNodeCount="101" docActiveCodeLength="629" docExpressionCount="60" docLength="726" projectName="pa3" starttimestamp="1650226882502" timestamp="4342936">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MemberDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶abstract public class MemberDecl extends Declaration {¶¶    public MemberDecl(boolean isPrivate, boolean isStatic, TypeDenoter mt, String name, SourcePosition posn) {¶        super(name, mt, posn);¶        this.isPrivate = isPrivate;¶        this.isStatic = isStatic;¶    }¶    ¶    public MemberDecl(MemberDecl md, SourcePosition posn){¶    	super(md.name, md.type, posn);¶    	this.isPrivate = md.isPrivate;¶    	this.isStatic = md.isStatic;¶    }¶    ¶    public boolean isPrivate;¶    public boolean isStatic;¶}¶")]]]></diff>
  </Command>
  <Command __id="1713" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:47 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="4344640">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="1715" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:33:52 EDT 2022" docASTNodeCount="101" docActiveCodeLength="629" docExpressionCount="60" docLength="726" projectName="pa3" starttimestamp="1650226882502" timestamp="4349649">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MemberDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶abstract public class MemberDecl extends Declaration {¶¶    public MemberDecl(boolean isPrivate, boolean isStatic, TypeDenoter mt, String name, SourcePosition posn) {¶        super(name, mt, posn);¶        this.isPrivate = isPrivate;¶        this.isStatic = isStatic;¶    }¶    ¶    public MemberDecl(MemberDecl md, SourcePosition posn){¶    	super(md.name, md.type, posn);¶    	this.isPrivate = md.isPrivate;¶    	this.isStatic = md.isStatic;¶    }¶    ¶    public boolean isPrivate;¶    public boolean isStatic;¶}¶")]]]></diff>
  </Command>
  <Command __id="1717" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:34:00 EDT 2022" docASTNodeCount="88" docActiveCodeLength="513" docExpressionCount="46" docLength="610" projectName="pa3" starttimestamp="1650226882502" timestamp="4358080">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MethodDecl.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

public class MethodDecl extends MemberDecl {
	
	public MethodDecl(MemberDecl md, ParameterDeclList pl, StatementList sl, SourcePosition posn){
    super(md,posn);
    parameterDeclList = pl;
    statementList = sl;
	}
	
	public <A, R> R visit(Visitor<A, R> v, A o) {
        return v.visitMethodDecl(this, o);
    }
	
	public ParameterDeclList parameterDeclList;
	public StatementList statementList;
}
]]></snapshot>
  </Command>
  <Command __id="1690" _type="SelectTextCommand" caretOffset="3214" date="Sun Apr 17 17:28:47 EDT 2022" end="3217" start="3214" starttimestamp="1650226882502" timestamp="4045440" />
  <Command __id="1691" _type="SelectTextCommand" caretOffset="3214" date="Sun Apr 17 17:28:47 EDT 2022" end="3217" start="3214" starttimestamp="1650226882502" timestamp="4045440" />
  <Command __id="1693" _type="InsertStringCommand" date="Sun Apr 17 17:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="4045473" timestamp2="4045473">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1694" _type="InsertStringCommand" date="Sun Apr 17 17:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="4045473" timestamp2="4045473">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1695" _type="MoveCaretCommand" caretOffset="3242" date="Sun Apr 17 17:28:48 EDT 2022" docOffset="3242" starttimestamp="1650226882502" timestamp="4045936" />
  <Command __id="1696" _type="MoveCaretCommand" caretOffset="3242" date="Sun Apr 17 17:28:48 EDT 2022" docOffset="3242" starttimestamp="1650226882502" timestamp="4045936" />
  <Command __id="1698" _type="MoveCaretCommand" caretOffset="343" date="Sun Apr 17 17:29:18 EDT 2022" docOffset="400" starttimestamp="1650226882502" timestamp="4075996" />
  <Command __id="1700" _type="SelectTextCommand" caretOffset="168" date="Sun Apr 17 17:33:19 EDT 2022" end="168" start="158" starttimestamp="1650226882502" timestamp="4316830" />
  <Command __id="1702" _type="MoveCaretCommand" caretOffset="343" date="Sun Apr 17 17:33:21 EDT 2022" docOffset="400" starttimestamp="1650226882502" timestamp="4318687" />
  <Command __id="1704" _type="SelectTextCommand" caretOffset="168" date="Sun Apr 17 17:33:37 EDT 2022" end="168" start="158" starttimestamp="1650226882502" timestamp="4334815" />
  <Command __id="1706" _type="MoveCaretCommand" caretOffset="343" date="Sun Apr 17 17:33:43 EDT 2022" docOffset="400" starttimestamp="1650226882502" timestamp="4340645" />
  <Command __id="1708" _type="SelectTextCommand" caretOffset="168" date="Sun Apr 17 17:33:44 EDT 2022" end="168" start="158" starttimestamp="1650226882502" timestamp="4341554" />
  <Command __id="1710" _type="MoveCaretCommand" caretOffset="343" date="Sun Apr 17 17:33:44 EDT 2022" docOffset="400" starttimestamp="1650226882502" timestamp="4342402" />
  <Command __id="1712" _type="SelectTextCommand" caretOffset="168" date="Sun Apr 17 17:33:45 EDT 2022" end="168" start="158" starttimestamp="1650226882502" timestamp="4342987" />
  <Command __id="1714" _type="MoveCaretCommand" caretOffset="343" date="Sun Apr 17 17:33:47 EDT 2022" docOffset="400" starttimestamp="1650226882502" timestamp="4344688" />
  <Command __id="1716" _type="SelectTextCommand" caretOffset="168" date="Sun Apr 17 17:33:52 EDT 2022" end="168" start="158" starttimestamp="1650226882502" timestamp="4349710" />
  <Command __id="1718" _type="SelectTextCommand" caretOffset="159" date="Sun Apr 17 17:34:00 EDT 2022" end="159" start="149" starttimestamp="1650226882502" timestamp="4358180" />
  <Command __id="1721" _type="MoveCaretCommand" caretOffset="343" date="Sun Apr 17 17:34:04 EDT 2022" docOffset="400" starttimestamp="1650226882502" timestamp="4362287" />
  <Command __id="1722" _type="SelectTextCommand" caretOffset="159" date="Sun Apr 17 17:34:04 EDT 2022" end="159" start="149" starttimestamp="1650226882502" timestamp="4362287" />
  <Command __id="1723" _type="ShellCommand" date="Sun Apr 17 17:34:58 EDT 2022" starttimestamp="1650226882502" timestamp="4415764" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1719" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:34:04 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="4362165">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="1720" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:34:04 EDT 2022" docASTNodeCount="88" docActiveCodeLength="513" docExpressionCount="46" docLength="610" projectName="pa3" starttimestamp="1650226882502" timestamp="4362187">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MethodDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class MethodDecl extends MemberDecl {¶	¶	public MethodDecl(MemberDecl md, ParameterDeclList pl, StatementList sl, SourcePosition posn){¶    super(md,posn);¶    parameterDeclList = pl;¶    statementList = sl;¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitMethodDecl(this, o);¶    }¶	¶	public ParameterDeclList parameterDeclList;¶	public StatementList statementList;¶}¶")]]]></diff>
  </Command>
  <Command __id="1726" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:41:52 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7416" docExpressionCount="768" docLength="8504" projectName="pa3" starttimestamp="1650226882502" timestamp="4829688">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		"), Diff(DELETE,"Token t1"), Diff(INSERT,"StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		mlist.add(mdecl);¶		ClassDecl cdecl = new ClassDecl("_PrintStream", flist, mlist, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2"), Diff(EQUAL," = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id"), Diff(DELETE,"1"), Diff(INSERT,"2"), Diff(EQUAL," = new Identifier(t1);¶		"), Diff(INSERT,"id1.decl = "), Diff(EQUAL,"¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		mlist.add(mdecl);
		ClassDecl cdecl = new ClassDecl("_PrintStream", flist, mlist, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t1);
		id1.decl = 
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="1724" _type="ShellCommand" date="Sun Apr 17 17:41:51 EDT 2022" starttimestamp="1650226882502" timestamp="4828931" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1725" _type="MoveCaretCommand" caretOffset="365" date="Sun Apr 17 17:41:51 EDT 2022" docOffset="422" starttimestamp="1650226882502" timestamp="4828993" />
  <Command __id="1727" _type="MoveCaretCommand" caretOffset="3406" date="Sun Apr 17 17:41:52 EDT 2022" docOffset="3406" starttimestamp="1650226882502" timestamp="4829735" />
  <Command __id="1728" _type="MoveCaretCommand" caretOffset="3406" date="Sun Apr 17 17:41:52 EDT 2022" docOffset="3406" starttimestamp="1650226882502" timestamp="4829745" />
  <Command __id="1729" _type="MoveCaretCommand" caretOffset="3290" date="Sun Apr 17 17:41:52 EDT 2022" docOffset="3290" starttimestamp="1650226882502" timestamp="4830239" />
  <Command __id="1730" _type="MoveCaretCommand" caretOffset="3290" date="Sun Apr 17 17:41:52 EDT 2022" docOffset="3290" starttimestamp="1650226882502" timestamp="4830239" />
  <Command __id="1731" _type="MoveCaretCommand" caretOffset="3242" date="Sun Apr 17 17:41:53 EDT 2022" docOffset="3242" starttimestamp="1650226882502" timestamp="4830969" />
  <Command __id="1732" _type="MoveCaretCommand" caretOffset="3242" date="Sun Apr 17 17:41:53 EDT 2022" docOffset="3242" starttimestamp="1650226882502" timestamp="4830983" />
  <Command __id="1734" _type="MoveCaretCommand" caretOffset="1474" date="Sun Apr 17 17:41:58 EDT 2022" docOffset="3814" starttimestamp="1650226882502" timestamp="4836437" />
  <Command __id="1735" _type="MoveCaretCommand" caretOffset="1798" date="Sun Apr 17 17:42:03 EDT 2022" docOffset="4138" starttimestamp="1650226882502" timestamp="4841075" />
  <Command __id="1736" _type="MoveCaretCommand" caretOffset="1798" date="Sun Apr 17 17:42:03 EDT 2022" docOffset="4138" starttimestamp="1650226882502" timestamp="4841087" />
  <Command __id="1738" _type="ShellCommand" date="Sun Apr 17 17:42:04 EDT 2022" starttimestamp="1650226882502" timestamp="4842063" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1739" _type="FindCommand" caseSensitive="false" date="Sun Apr 17 17:42:10 EDT 2022" forward="false" matchWord="false" offset="4138" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="4847725" wrapSearch="false">
    <searchString><![CDATA[methoddecl]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="1733" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:41:58 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="4836377">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1740" _type="ShellCommand" date="Sun Apr 17 17:42:15 EDT 2022" starttimestamp="1650226882502" timestamp="4853392" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1741" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:42:19 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="4857352">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1742" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 17:42:19 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="4857414" />
  <Command __id="1743" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:42:20 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="4857872">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1744" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 17:42:20 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="4857919" />
  <Command __id="1746" _type="MoveCaretCommand" caretOffset="3242" date="Sun Apr 17 17:42:21 EDT 2022" docOffset="3242" starttimestamp="1650226882502" timestamp="4858870" />
  <Command __id="1747" _type="MoveCaretCommand" caretOffset="3240" date="Sun Apr 17 17:42:23 EDT 2022" docOffset="3240" starttimestamp="1650226882502" timestamp="4860605" />
  <Command __id="1748" _type="MoveCaretCommand" caretOffset="3240" date="Sun Apr 17 17:42:23 EDT 2022" docOffset="3240" starttimestamp="1650226882502" timestamp="4860615" />
  <Command __id="1749" _type="ShellCommand" date="Sun Apr 17 17:42:46 EDT 2022" starttimestamp="1650226882502" timestamp="4883834" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1745" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:42:21 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7416" docExpressionCount="768" docLength="8504" projectName="pa3" starttimestamp="1650226882502" timestamp="4858816">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		mlist.add(mdecl);¶		ClassDecl cdecl = new ClassDecl("_PrintStream", flist, mlist, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t1);¶		id1.decl = ¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="1750" _type="ShellCommand" date="Sun Apr 17 17:42:50 EDT 2022" starttimestamp="1650226882502" timestamp="4888310" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1752" _type="InsertStringCommand" date="Sun Apr 17 17:42:51 EDT 2022" starttimestamp="1650226882502" timestamp="4889333" timestamp2="4889333">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1753" _type="InsertStringCommand" date="Sun Apr 17 17:42:51 EDT 2022" starttimestamp="1650226882502" timestamp="4889333" timestamp2="4889333">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1754" _type="MoveCaretCommand" caretOffset="3228" date="Sun Apr 17 17:42:51 EDT 2022" docOffset="3228" starttimestamp="1650226882502" timestamp="4889348" />
  <Command __id="1755" _type="MoveCaretCommand" caretOffset="3228" date="Sun Apr 17 17:42:51 EDT 2022" docOffset="3228" starttimestamp="1650226882502" timestamp="4889359" />
  <Command __id="1756" _type="SelectTextCommand" caretOffset="3235" date="Sun Apr 17 17:42:53 EDT 2022" end="3238" start="3235" starttimestamp="1650226882502" timestamp="4891206" />
  <Command __id="1757" _type="SelectTextCommand" caretOffset="3235" date="Sun Apr 17 17:42:53 EDT 2022" end="3238" start="3235" starttimestamp="1650226882502" timestamp="4891206" />
  <Command __id="1759" _type="InsertStringCommand" date="Sun Apr 17 17:42:53 EDT 2022" starttimestamp="1650226882502" timestamp="4891221" timestamp2="4891221">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1760" _type="InsertStringCommand" date="Sun Apr 17 17:42:53 EDT 2022" starttimestamp="1650226882502" timestamp="4891221" timestamp2="4891221">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1761" _type="MoveCaretCommand" caretOffset="3238" date="Sun Apr 17 17:42:54 EDT 2022" docOffset="3238" starttimestamp="1650226882502" timestamp="4891639" />
  <Command __id="1762" _type="MoveCaretCommand" caretOffset="3238" date="Sun Apr 17 17:42:54 EDT 2022" docOffset="3238" starttimestamp="1650226882502" timestamp="4891639" />
  <DocumentChange __id="1751" _type="Replace" date="Sun Apr 17 17:42:51 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7414" docExpressionCount="768" docLength="8502" endLine="79" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7413" int_docExpressionCount="768" int_docLength="8501" length="3" offset="3227" startLine="79" starttimestamp="1650226882502" timestamp="4889333">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1758" _type="Replace" date="Sun Apr 17 17:42:53 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7412" docExpressionCount="768" docLength="8500" endLine="79" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7411" int_docExpressionCount="768" int_docLength="8499" length="3" offset="3235" startLine="79" starttimestamp="1650226882502" timestamp="4891215">
    <deletedText><![CDATA[ecl]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1765" _type="Replace" date="Sun Apr 17 17:43:01 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7410" docExpressionCount="768" docLength="8498" endLine="80" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7409" int_docExpressionCount="768" int_docLength="8497" length="3" offset="3292" startLine="80" starttimestamp="1650226882502" timestamp="4899199">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <Command __id="1763" _type="SelectTextCommand" caretOffset="3292" date="Sun Apr 17 17:43:01 EDT 2022" end="3295" start="3292" starttimestamp="1650226882502" timestamp="4899191" />
  <Command __id="1764" _type="SelectTextCommand" caretOffset="3292" date="Sun Apr 17 17:43:01 EDT 2022" end="3295" start="3292" starttimestamp="1650226882502" timestamp="4899191" />
  <Command __id="1766" _type="InsertStringCommand" date="Sun Apr 17 17:43:01 EDT 2022" starttimestamp="1650226882502" timestamp="4899204" timestamp2="4899204">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1767" _type="InsertStringCommand" date="Sun Apr 17 17:43:01 EDT 2022" starttimestamp="1650226882502" timestamp="4899204" timestamp2="4899204">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1769" _type="InsertStringCommand" date="Sun Apr 17 17:43:03 EDT 2022" starttimestamp="1650226882502" timestamp="4900907" timestamp2="4900907">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1770" _type="InsertStringCommand" date="Sun Apr 17 17:43:03 EDT 2022" starttimestamp="1650226882502" timestamp="4900907" timestamp2="4900907">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1771" _type="MoveCaretCommand" caretOffset="3298" date="Sun Apr 17 17:43:03 EDT 2022" docOffset="3298" starttimestamp="1650226882502" timestamp="4900907" />
  <Command __id="1772" _type="MoveCaretCommand" caretOffset="3298" date="Sun Apr 17 17:43:03 EDT 2022" docOffset="3298" starttimestamp="1650226882502" timestamp="4900912" />
  <Command __id="1773" _type="MoveCaretCommand" caretOffset="3352" date="Sun Apr 17 17:43:03 EDT 2022" docOffset="3352" starttimestamp="1650226882502" timestamp="4901294" />
  <Command __id="1774" _type="MoveCaretCommand" caretOffset="3352" date="Sun Apr 17 17:43:03 EDT 2022" docOffset="3352" starttimestamp="1650226882502" timestamp="4901294" />
  <DocumentChange __id="1768" _type="Replace" date="Sun Apr 17 17:43:03 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7408" docExpressionCount="768" docLength="8496" endLine="80" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7407" int_docExpressionCount="768" int_docLength="8495" length="3" offset="3297" startLine="80" starttimestamp="1650226882502" timestamp="4900892">
    <deletedText><![CDATA[ist]]></deletedText>
    <insertedText><![CDATA[1]]></insertedText>
  </DocumentChange>
  <Command __id="1775" _type="MoveCaretCommand" caretOffset="3308" date="Sun Apr 17 17:43:12 EDT 2022" docOffset="3308" starttimestamp="1650226882502" timestamp="4909735" />
  <Command __id="1776" _type="MoveCaretCommand" caretOffset="3308" date="Sun Apr 17 17:43:12 EDT 2022" docOffset="3308" starttimestamp="1650226882502" timestamp="4909735" />
  <Command __id="1777" _type="MoveCaretCommand" caretOffset="3398" date="Sun Apr 17 17:43:12 EDT 2022" docOffset="3398" starttimestamp="1650226882502" timestamp="4910489" />
  <Command __id="1778" _type="MoveCaretCommand" caretOffset="3398" date="Sun Apr 17 17:43:13 EDT 2022" docOffset="3398" starttimestamp="1650226882502" timestamp="4910503" />
  <Command __id="1780" _type="InsertStringCommand" date="Sun Apr 17 17:43:38 EDT 2022" starttimestamp="1650226882502" timestamp="4935707" timestamp2="4935707">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1781" _type="InsertStringCommand" date="Sun Apr 17 17:43:38 EDT 2022" starttimestamp="1650226882502" timestamp="4935707" timestamp2="4935707">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1782" _type="MoveCaretCommand" caretOffset="3495" date="Sun Apr 17 17:43:38 EDT 2022" docOffset="3495" starttimestamp="1650226882502" timestamp="4935707" />
  <Command __id="1783" _type="MoveCaretCommand" caretOffset="3495" date="Sun Apr 17 17:43:38 EDT 2022" docOffset="3495" starttimestamp="1650226882502" timestamp="4935707" />
  <Command __id="1784" _type="ShellCommand" date="Sun Apr 17 17:43:42 EDT 2022" starttimestamp="1650226882502" timestamp="4939737" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="1779" _type="Replace" date="Sun Apr 17 17:43:38 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7408" docExpressionCount="768" docLength="8496" endLine="85" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7407" int_docExpressionCount="768" int_docLength="8495" length="1" offset="3494" startLine="85" starttimestamp="1650226882502" timestamp="4935707">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[2]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1788" _type="Replace" date="Sun Apr 17 17:43:52 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7408" docExpressionCount="768" docLength="8496" endLine="86" insertionLength="1" int_docASTNodeCount="1244" int_docActiveCodeLength="7407" int_docExpressionCount="768" int_docLength="8495" length="1" offset="3503" startLine="86" starttimestamp="1650226882502" timestamp="4949767">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[2]]></insertedText>
  </DocumentChange>
  <Command __id="1795" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:44:38 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="4995767">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1797" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:45:14 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="5031684">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="1799" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:45:14 EDT 2022" docASTNodeCount="1244" docActiveCodeLength="7408" docExpressionCount="768" docLength="8496" projectName="pa3" starttimestamp="1650226882502" timestamp="5032320">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml"), Diff(DELETE,"ist"), Diff(INSERT,"1"), Diff(EQUAL,".add(md"), Diff(DELETE,"ecl"), Diff(INSERT,"1"), Diff(EQUAL,");¶		ClassDecl cdecl = new ClassDecl("_PrintStream", fl"), Diff(DELETE,"ist"), Diff(INSERT,"1"), Diff(EQUAL,", ml"), Diff(DELETE,"ist"), Diff(INSERT,"1"), Diff(EQUAL,", sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t"), Diff(DELETE,"1"), Diff(INSERT,"2"), Diff(EQUAL,");¶		id"), Diff(DELETE,"1"), Diff(INSERT,"2"), Diff(EQUAL,".decl = ¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cdecl = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = 
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="1785" _type="ShellCommand" date="Sun Apr 17 17:43:51 EDT 2022" starttimestamp="1650226882502" timestamp="4949279" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1786" _type="SelectTextCommand" caretOffset="3503" date="Sun Apr 17 17:43:52 EDT 2022" end="3504" start="3503" starttimestamp="1650226882502" timestamp="4949758" />
  <Command __id="1787" _type="SelectTextCommand" caretOffset="3503" date="Sun Apr 17 17:43:52 EDT 2022" end="3504" start="3503" starttimestamp="1650226882502" timestamp="4949759" />
  <Command __id="1789" _type="InsertStringCommand" date="Sun Apr 17 17:43:52 EDT 2022" starttimestamp="1650226882502" timestamp="4949772" timestamp2="4949772">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1790" _type="InsertStringCommand" date="Sun Apr 17 17:43:52 EDT 2022" starttimestamp="1650226882502" timestamp="4949772" timestamp2="4949772">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1791" _type="MoveCaretCommand" caretOffset="3511" date="Sun Apr 17 17:43:52 EDT 2022" docOffset="3511" starttimestamp="1650226882502" timestamp="4950228" />
  <Command __id="1792" _type="MoveCaretCommand" caretOffset="3511" date="Sun Apr 17 17:43:52 EDT 2022" docOffset="3511" starttimestamp="1650226882502" timestamp="4950231" />
  <Command __id="1793" _type="MoveCaretCommand" caretOffset="3512" date="Sun Apr 17 17:43:53 EDT 2022" docOffset="3512" starttimestamp="1650226882502" timestamp="4950813" />
  <Command __id="1794" _type="MoveCaretCommand" caretOffset="3512" date="Sun Apr 17 17:43:53 EDT 2022" docOffset="3512" starttimestamp="1650226882502" timestamp="4950815" />
  <Command __id="1796" _type="SelectTextCommand" caretOffset="150" date="Sun Apr 17 17:44:38 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="4995814" />
  <Command __id="1798" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 17:45:14 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="5031739" />
  <Command __id="1800" _type="MoveCaretCommand" caretOffset="3512" date="Sun Apr 17 17:45:14 EDT 2022" docOffset="3512" starttimestamp="1650226882502" timestamp="5032381" />
  <Command __id="1802" _type="InsertStringCommand" date="Sun Apr 17 17:45:17 EDT 2022" starttimestamp="1650226882502" timestamp="5034499" timestamp2="5034499">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="1803" _type="InsertStringCommand" date="Sun Apr 17 17:45:17 EDT 2022" starttimestamp="1650226882502" timestamp="5034499" timestamp2="5034499">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="1805" _type="InsertStringCommand" date="Sun Apr 17 17:45:17 EDT 2022" starttimestamp="1650226882502" timestamp="5034684" timestamp2="5034684">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1806" _type="InsertStringCommand" date="Sun Apr 17 17:45:17 EDT 2022" starttimestamp="1650226882502" timestamp="5034684" timestamp2="5034684">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="1801" _type="Insert" date="Sun Apr 17 17:45:16 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7409" docExpressionCount="773" docLength="8497" length="1" offset="3512" starttimestamp="1650226882502" timestamp="5034484">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="1804" _type="Insert" date="Sun Apr 17 17:45:17 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7410" docExpressionCount="773" docLength="8498" length="1" offset="3513" starttimestamp="1650226882502" timestamp="5034684">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1807" _type="MoveCaretCommand" caretOffset="3257" date="Sun Apr 17 17:45:19 EDT 2022" docOffset="3257" starttimestamp="1650226882502" timestamp="5036735" />
  <Command __id="1808" _type="MoveCaretCommand" caretOffset="3257" date="Sun Apr 17 17:45:19 EDT 2022" docOffset="3257" starttimestamp="1650226882502" timestamp="5036735" />
  <DocumentChange __id="1809" _type="Delete" date="Sun Apr 17 17:45:20 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7409" docExpressionCount="773" docLength="8497" endLine="80" length="1" offset="3256" startLine="80" starttimestamp="1650226882502" timestamp="5038002">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="1810" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:45:20 EDT 2022" starttimestamp="1650226882502" timestamp="5038002" />
  <Command __id="1811" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:45:20 EDT 2022" starttimestamp="1650226882502" timestamp="5038002" />
  <DocumentChange __id="1812" _type="Delete" date="Sun Apr 17 17:45:20 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7408" docExpressionCount="773" docLength="8496" endLine="80" length="1" offset="3255" startLine="80" starttimestamp="1650226882502" timestamp="5038187">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="1813" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:45:20 EDT 2022" starttimestamp="1650226882502" timestamp="5038202" />
  <Command __id="1814" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:45:20 EDT 2022" starttimestamp="1650226882502" timestamp="5038202" />
  <Command __id="1816" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:45:20 EDT 2022" starttimestamp="1650226882502" timestamp="5038387" />
  <Command __id="1817" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:45:20 EDT 2022" starttimestamp="1650226882502" timestamp="5038387" />
  <DocumentChange __id="1815" _type="Delete" date="Sun Apr 17 17:45:20 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7407" docExpressionCount="773" docLength="8495" endLine="80" length="1" offset="3254" startLine="80" starttimestamp="1650226882502" timestamp="5038387">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="1820" _type="Insert" date="Sun Apr 17 17:45:22 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7408" docExpressionCount="773" docLength="8496" length="1" offset="3511" starttimestamp="1650226882502" timestamp="5040320">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="1818" _type="MoveCaretCommand" caretOffset="3511" date="Sun Apr 17 17:45:22 EDT 2022" docOffset="3511" starttimestamp="1650226882502" timestamp="5039573" />
  <Command __id="1819" _type="MoveCaretCommand" caretOffset="3511" date="Sun Apr 17 17:45:22 EDT 2022" docOffset="3511" starttimestamp="1650226882502" timestamp="5039575" />
  <Command __id="1821" _type="InsertStringCommand" date="Sun Apr 17 17:45:22 EDT 2022" starttimestamp="1650226882502" timestamp="5040320" timestamp2="5040320">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="1822" _type="InsertStringCommand" date="Sun Apr 17 17:45:22 EDT 2022" starttimestamp="1650226882502" timestamp="5040320" timestamp2="5040320">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="1824" _type="InsertStringCommand" date="Sun Apr 17 17:45:24 EDT 2022" starttimestamp="1650226882502" timestamp="5041682" timestamp2="5041682">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1825" _type="InsertStringCommand" date="Sun Apr 17 17:45:24 EDT 2022" starttimestamp="1650226882502" timestamp="5041682" timestamp2="5041682">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1827" _type="InsertStringCommand" date="Sun Apr 17 17:45:24 EDT 2022" starttimestamp="1650226882502" timestamp="5042337" timestamp2="5042337">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1828" _type="InsertStringCommand" date="Sun Apr 17 17:45:24 EDT 2022" starttimestamp="1650226882502" timestamp="5042337" timestamp2="5042337">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1829" _type="MoveCaretCommand" caretOffset="3253" date="Sun Apr 17 17:45:26 EDT 2022" docOffset="3253" starttimestamp="1650226882502" timestamp="5044039" />
  <Command __id="1830" _type="MoveCaretCommand" caretOffset="3253" date="Sun Apr 17 17:45:26 EDT 2022" docOffset="3253" starttimestamp="1650226882502" timestamp="5044039" />
  <Command __id="1831" _type="MoveCaretCommand" caretOffset="3254" date="Sun Apr 17 17:45:26 EDT 2022" docOffset="3254" starttimestamp="1650226882502" timestamp="5044431" />
  <Command __id="1832" _type="MoveCaretCommand" caretOffset="3254" date="Sun Apr 17 17:45:26 EDT 2022" docOffset="3254" starttimestamp="1650226882502" timestamp="5044431" />
  <Command __id="1834" _type="InsertStringCommand" date="Sun Apr 17 17:45:27 EDT 2022" starttimestamp="1650226882502" timestamp="5044595" timestamp2="5044595">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1835" _type="InsertStringCommand" date="Sun Apr 17 17:45:27 EDT 2022" starttimestamp="1650226882502" timestamp="5044595" timestamp2="5044595">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1837" _type="InsertStringCommand" date="Sun Apr 17 17:45:27 EDT 2022" starttimestamp="1650226882502" timestamp="5045391" timestamp2="5045391">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1838" _type="InsertStringCommand" date="Sun Apr 17 17:45:27 EDT 2022" starttimestamp="1650226882502" timestamp="5045391" timestamp2="5045391">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1839" _type="MoveCaretCommand" caretOffset="3522" date="Sun Apr 17 17:45:28 EDT 2022" docOffset="3522" starttimestamp="1650226882502" timestamp="5045911" />
  <Command __id="1840" _type="MoveCaretCommand" caretOffset="3522" date="Sun Apr 17 17:45:28 EDT 2022" docOffset="3522" starttimestamp="1650226882502" timestamp="5045911" />
  <Command __id="1841" _type="MoveCaretCommand" caretOffset="3522" date="Sun Apr 17 17:46:06 EDT 2022" docOffset="3522" starttimestamp="1650226882502" timestamp="5084021" />
  <Command __id="1842" _type="MoveCaretCommand" caretOffset="3522" date="Sun Apr 17 17:46:06 EDT 2022" docOffset="3522" starttimestamp="1650226882502" timestamp="5084023" />
  <Command __id="1843" _type="ShellCommand" date="Sun Apr 17 17:46:31 EDT 2022" starttimestamp="1650226882502" timestamp="5109372" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1844" _type="ShellCommand" date="Sun Apr 17 17:46:37 EDT 2022" starttimestamp="1650226882502" timestamp="5115001" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1845" _type="MoveCaretCommand" caretOffset="3518" date="Sun Apr 17 17:46:37 EDT 2022" docOffset="3518" starttimestamp="1650226882502" timestamp="5115062" />
  <Command __id="1846" _type="MoveCaretCommand" caretOffset="3518" date="Sun Apr 17 17:46:37 EDT 2022" docOffset="3518" starttimestamp="1650226882502" timestamp="5115062" />
  <Command __id="1848" _type="PasteCommand" date="Sun Apr 17 17:46:37 EDT 2022" starttimestamp="1650226882502" timestamp="5115357" />
  <Command __id="1849" _type="MoveCaretCommand" caretOffset="3524" date="Sun Apr 17 17:46:57 EDT 2022" docOffset="3524" starttimestamp="1650226882502" timestamp="5134907" />
  <Command __id="1850" _type="MoveCaretCommand" caretOffset="3524" date="Sun Apr 17 17:46:57 EDT 2022" docOffset="3524" starttimestamp="1650226882502" timestamp="5134911" />
  <Command __id="1851" _type="MoveCaretCommand" caretOffset="3533" date="Sun Apr 17 17:46:57 EDT 2022" docOffset="3533" starttimestamp="1650226882502" timestamp="5135354" />
  <Command __id="1852" _type="MoveCaretCommand" caretOffset="3533" date="Sun Apr 17 17:46:57 EDT 2022" docOffset="3533" starttimestamp="1650226882502" timestamp="5135367" />
  <Command __id="1853" _type="MoveCaretCommand" caretOffset="3532" date="Sun Apr 17 17:46:58 EDT 2022" docOffset="3532" starttimestamp="1650226882502" timestamp="5135924" />
  <Command __id="1854" _type="MoveCaretCommand" caretOffset="3532" date="Sun Apr 17 17:46:58 EDT 2022" docOffset="3532" starttimestamp="1650226882502" timestamp="5135927" />
  <Command __id="1855" _type="MoveCaretCommand" caretOffset="3577" date="Sun Apr 17 17:46:59 EDT 2022" docOffset="3577" starttimestamp="1650226882502" timestamp="5136590" />
  <Command __id="1856" _type="MoveCaretCommand" caretOffset="3577" date="Sun Apr 17 17:46:59 EDT 2022" docOffset="3577" starttimestamp="1650226882502" timestamp="5136590" />
  <Command __id="1857" _type="MoveCaretCommand" caretOffset="3534" date="Sun Apr 17 17:46:59 EDT 2022" docOffset="3534" starttimestamp="1650226882502" timestamp="5137135" />
  <Command __id="1858" _type="MoveCaretCommand" caretOffset="3534" date="Sun Apr 17 17:46:59 EDT 2022" docOffset="3534" starttimestamp="1650226882502" timestamp="5137135" />
  <Command __id="1859" _type="MoveCaretCommand" caretOffset="3532" date="Sun Apr 17 17:47:00 EDT 2022" docOffset="3532" starttimestamp="1650226882502" timestamp="5137742" />
  <Command __id="1860" _type="MoveCaretCommand" caretOffset="3532" date="Sun Apr 17 17:47:00 EDT 2022" docOffset="3532" starttimestamp="1650226882502" timestamp="5137743" />
  <Command __id="1861" _type="SelectTextCommand" caretOffset="3528" date="Sun Apr 17 17:47:05 EDT 2022" end="3533" start="3528" starttimestamp="1650226882502" timestamp="5143233" />
  <Command __id="1862" _type="SelectTextCommand" caretOffset="3528" date="Sun Apr 17 17:47:05 EDT 2022" end="3533" start="3528" starttimestamp="1650226882502" timestamp="5143233" />
  <Command __id="1864" _type="InsertStringCommand" date="Sun Apr 17 17:47:06 EDT 2022" starttimestamp="1650226882502" timestamp="5143849" timestamp2="5143849">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="1865" _type="InsertStringCommand" date="Sun Apr 17 17:47:06 EDT 2022" starttimestamp="1650226882502" timestamp="5143849" timestamp2="5143849">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="1867" _type="InsertStringCommand" date="Sun Apr 17 17:47:06 EDT 2022" starttimestamp="1650226882502" timestamp="5144296" timestamp2="5144296">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1868" _type="InsertStringCommand" date="Sun Apr 17 17:47:06 EDT 2022" starttimestamp="1650226882502" timestamp="5144296" timestamp2="5144296">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1870" _type="InsertStringCommand" date="Sun Apr 17 17:47:07 EDT 2022" starttimestamp="1650226882502" timestamp="5144618" timestamp2="5144618">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1871" _type="InsertStringCommand" date="Sun Apr 17 17:47:07 EDT 2022" starttimestamp="1650226882502" timestamp="5144618" timestamp2="5144618">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="1823" _type="Insert" date="Sun Apr 17 17:45:24 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7412" docExpressionCount="773" docLength="8500" length="4" offset="3512" starttimestamp="1650226882502" timestamp="5041678">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="1826" _type="Insert" date="Sun Apr 17 17:45:24 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7416" docExpressionCount="773" docLength="8504" length="4" offset="3516" starttimestamp="1650226882502" timestamp="5042322">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="1833" _type="Insert" date="Sun Apr 17 17:45:27 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7417" docExpressionCount="773" docLength="8505" length="1" offset="3254" starttimestamp="1650226882502" timestamp="5044579">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="1836" _type="Insert" date="Sun Apr 17 17:45:27 EDT 2022" docASTNodeCount="1250" docActiveCodeLength="7418" docExpressionCount="773" docLength="8506" length="1" offset="3512" starttimestamp="1650226882502" timestamp="5045391">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="1847" _type="Replace" date="Sun Apr 17 17:46:37 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7617" docExpressionCount="800" docLength="8705" endLine="87" insertionLength="201" int_docASTNodeCount="1250" int_docActiveCodeLength="7416" int_docExpressionCount="773" int_docLength="8504" length="2" offset="3516" startLine="87" starttimestamp="1650226882502" timestamp="5115342">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		ClassType ftype = new ClassType(fid, sp);
		FieldDecl fdecl2 = new FieldDecl(false, true, ftype, "out", sp);
		flist2.add(fdecl2);
		ClassDecl cdecl2 = new ClassDecl("System", flist2, mlist2, sp);]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1863" _type="Replace" date="Sun Apr 17 17:47:06 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7613" docExpressionCount="800" docLength="8701" endLine="87" insertionLength="1" int_docASTNodeCount="1288" int_docActiveCodeLength="7612" int_docExpressionCount="800" int_docLength="8700" length="5" offset="3528" startLine="87" starttimestamp="1650226882502" timestamp="5143849">
    <deletedText><![CDATA[ftype]]></deletedText>
    <insertedText><![CDATA[c]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1866" _type="Insert" date="Sun Apr 17 17:47:06 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7614" docExpressionCount="800" docLength="8702" length="1" offset="3529" starttimestamp="1650226882502" timestamp="5144280">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="1869" _type="Insert" date="Sun Apr 17 17:47:07 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7615" docExpressionCount="800" docLength="8703" length="1" offset="3530" starttimestamp="1650226882502" timestamp="5144618">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="1872" _type="MoveCaretCommand" caretOffset="3549" date="Sun Apr 17 17:47:16 EDT 2022" docOffset="3549" starttimestamp="1650226882502" timestamp="5153583" />
  <Command __id="1873" _type="MoveCaretCommand" caretOffset="3549" date="Sun Apr 17 17:47:16 EDT 2022" docOffset="3549" starttimestamp="1650226882502" timestamp="5153583" />
  <Command __id="1874" _type="SelectTextCommand" caretOffset="3551" date="Sun Apr 17 17:47:16 EDT 2022" end="3551" start="3548" starttimestamp="1650226882502" timestamp="5153781" />
  <Command __id="1875" _type="SelectTextCommand" caretOffset="3551" date="Sun Apr 17 17:47:16 EDT 2022" end="3551" start="3548" starttimestamp="1650226882502" timestamp="5153783" />
  <DocumentChange __id="1876" _type="Replace" date="Sun Apr 17 17:47:21 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7613" docExpressionCount="800" docLength="8701" endLine="87" insertionLength="1" int_docASTNodeCount="1289" int_docActiveCodeLength="7612" int_docExpressionCount="799" int_docLength="8700" length="3" offset="3548" startLine="87" starttimestamp="1650226882502" timestamp="5158827">
    <deletedText><![CDATA[fid]]></deletedText>
    <insertedText><![CDATA[i]]></insertedText>
  </DocumentChange>
  <Command __id="1877" _type="InsertStringCommand" date="Sun Apr 17 17:47:21 EDT 2022" starttimestamp="1650226882502" timestamp="5158827" timestamp2="5158827">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="1878" _type="InsertStringCommand" date="Sun Apr 17 17:47:21 EDT 2022" starttimestamp="1650226882502" timestamp="5158827" timestamp2="5158827">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="1879" _type="Insert" date="Sun Apr 17 17:47:21 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7614" docExpressionCount="800" docLength="8702" length="1" offset="3549" starttimestamp="1650226882502" timestamp="5158843">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="1880" _type="InsertStringCommand" date="Sun Apr 17 17:47:21 EDT 2022" starttimestamp="1650226882502" timestamp="5158843" timestamp2="5158843">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1881" _type="InsertStringCommand" date="Sun Apr 17 17:47:21 EDT 2022" starttimestamp="1650226882502" timestamp="5158843" timestamp2="5158843">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="1883" _type="InsertStringCommand" date="Sun Apr 17 17:47:21 EDT 2022" starttimestamp="1650226882502" timestamp="5159090" timestamp2="5159090">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1884" _type="InsertStringCommand" date="Sun Apr 17 17:47:21 EDT 2022" starttimestamp="1650226882502" timestamp="5159090" timestamp2="5159090">
    <data><![CDATA[2]]></data>
  </Command>
  <Command __id="1885" _type="MoveCaretCommand" caretOffset="3578" date="Sun Apr 17 17:47:24 EDT 2022" docOffset="3578" starttimestamp="1650226882502" timestamp="5162364" />
  <Command __id="1886" _type="MoveCaretCommand" caretOffset="3578" date="Sun Apr 17 17:47:24 EDT 2022" docOffset="3578" starttimestamp="1650226882502" timestamp="5162367" />
  <Command __id="1887" _type="SelectTextCommand" caretOffset="3573" date="Sun Apr 17 17:47:26 EDT 2022" end="3576" start="3573" starttimestamp="1650226882502" timestamp="5164129" />
  <Command __id="1888" _type="SelectTextCommand" caretOffset="3573" date="Sun Apr 17 17:47:26 EDT 2022" end="3576" start="3573" starttimestamp="1650226882502" timestamp="5164135" />
  <Command __id="1890" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:47:27 EDT 2022" starttimestamp="1650226882502" timestamp="5164867" />
  <Command __id="1891" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:47:27 EDT 2022" starttimestamp="1650226882502" timestamp="5164867" />
  <Command __id="1892" _type="SelectTextCommand" caretOffset="3606" date="Sun Apr 17 17:47:34 EDT 2022" end="3609" start="3606" starttimestamp="1650226882502" timestamp="5171638" />
  <Command __id="1893" _type="SelectTextCommand" caretOffset="3606" date="Sun Apr 17 17:47:34 EDT 2022" end="3609" start="3606" starttimestamp="1650226882502" timestamp="5171639" />
  <Command __id="1894" _type="ShellCommand" date="Sun Apr 17 17:47:36 EDT 2022" starttimestamp="1650226882502" timestamp="5173627" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1895" _type="ShellCommand" date="Sun Apr 17 17:47:50 EDT 2022" starttimestamp="1650226882502" timestamp="5188437" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1896" _type="MoveCaretCommand" caretOffset="3645" date="Sun Apr 17 17:47:51 EDT 2022" docOffset="3645" starttimestamp="1650226882502" timestamp="5188503" />
  <Command __id="1897" _type="MoveCaretCommand" caretOffset="3645" date="Sun Apr 17 17:47:51 EDT 2022" docOffset="3645" starttimestamp="1650226882502" timestamp="5188503" />
  <Command __id="1898" _type="MoveCaretCommand" caretOffset="3607" date="Sun Apr 17 17:47:51 EDT 2022" docOffset="3607" starttimestamp="1650226882502" timestamp="5188868" />
  <Command __id="1899" _type="MoveCaretCommand" caretOffset="3607" date="Sun Apr 17 17:47:51 EDT 2022" docOffset="3607" starttimestamp="1650226882502" timestamp="5188868" />
  <Command __id="1900" _type="SelectTextCommand" caretOffset="3609" date="Sun Apr 17 17:47:51 EDT 2022" end="3609" start="3604" starttimestamp="1650226882502" timestamp="5189037" />
  <Command __id="1901" _type="SelectTextCommand" caretOffset="3609" date="Sun Apr 17 17:47:51 EDT 2022" end="3609" start="3604" starttimestamp="1650226882502" timestamp="5189039" />
  <Command __id="1903" _type="InsertStringCommand" date="Sun Apr 17 17:47:51 EDT 2022" starttimestamp="1650226882502" timestamp="5189051" timestamp2="5189051">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="1904" _type="InsertStringCommand" date="Sun Apr 17 17:47:51 EDT 2022" starttimestamp="1650226882502" timestamp="5189052" timestamp2="5189052">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="1906" _type="InsertStringCommand" date="Sun Apr 17 17:47:51 EDT 2022" starttimestamp="1650226882502" timestamp="5189422" timestamp2="5189422">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1907" _type="InsertStringCommand" date="Sun Apr 17 17:47:51 EDT 2022" starttimestamp="1650226882502" timestamp="5189422" timestamp2="5189422">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="1909" _type="InsertStringCommand" date="Sun Apr 17 17:47:52 EDT 2022" starttimestamp="1650226882502" timestamp="5189622" timestamp2="5189622">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1910" _type="InsertStringCommand" date="Sun Apr 17 17:47:52 EDT 2022" starttimestamp="1650226882502" timestamp="5189622" timestamp2="5189622">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1911" _type="SelectTextCommand" caretOffset="3626" date="Sun Apr 17 17:48:14 EDT 2022" end="3629" start="3626" starttimestamp="1650226882502" timestamp="5212463" />
  <Command __id="1912" _type="SelectTextCommand" caretOffset="3626" date="Sun Apr 17 17:48:14 EDT 2022" end="3629" start="3626" starttimestamp="1650226882502" timestamp="5212463" />
  <Command __id="1914" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:15 EDT 2022" starttimestamp="1650226882502" timestamp="5213194" />
  <Command __id="1915" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:15 EDT 2022" starttimestamp="1650226882502" timestamp="5213194" />
  <Command __id="1916" _type="SelectTextCommand" caretOffset="3634" date="Sun Apr 17 17:48:25 EDT 2022" end="3637" start="3634" starttimestamp="1650226882502" timestamp="5222584" />
  <Command __id="1917" _type="SelectTextCommand" caretOffset="3634" date="Sun Apr 17 17:48:25 EDT 2022" end="3637" start="3634" starttimestamp="1650226882502" timestamp="5222591" />
  <Command __id="1919" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:25 EDT 2022" starttimestamp="1650226882502" timestamp="5223248" />
  <Command __id="1920" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:25 EDT 2022" starttimestamp="1650226882502" timestamp="5223248" />
  <DocumentChange __id="1882" _type="Insert" date="Sun Apr 17 17:47:21 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7615" docExpressionCount="800" docLength="8703" length="1" offset="3550" starttimestamp="1650226882502" timestamp="5159090">
    <text><![CDATA[2]]></text>
  </DocumentChange>
  <DocumentChange __id="1889" _type="Delete" date="Sun Apr 17 17:47:27 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7612" docExpressionCount="800" docLength="8700" endLine="88" length="3" offset="3573" startLine="88" starttimestamp="1650226882502" timestamp="5164867">
    <text><![CDATA[ecl]]></text>
  </DocumentChange>
  <DocumentChange __id="1902" _type="Replace" date="Sun Apr 17 17:47:51 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7608" docExpressionCount="800" docLength="8696" endLine="88" insertionLength="1" int_docASTNodeCount="1289" int_docActiveCodeLength="7607" int_docExpressionCount="799" int_docLength="8695" length="5" offset="3604" startLine="88" starttimestamp="1650226882502" timestamp="5189047">
    <deletedText><![CDATA[ftype]]></deletedText>
    <insertedText><![CDATA[c]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1905" _type="Insert" date="Sun Apr 17 17:47:51 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7609" docExpressionCount="800" docLength="8697" length="1" offset="3605" starttimestamp="1650226882502" timestamp="5189422">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="1908" _type="Insert" date="Sun Apr 17 17:47:52 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7610" docExpressionCount="800" docLength="8698" length="1" offset="3606" starttimestamp="1650226882502" timestamp="5189607">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="1913" _type="Delete" date="Sun Apr 17 17:48:15 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7607" docExpressionCount="800" docLength="8695" endLine="89" length="3" offset="3626" startLine="89" starttimestamp="1650226882502" timestamp="5213194">
    <text><![CDATA[ist]]></text>
  </DocumentChange>
  <DocumentChange __id="1918" _type="Delete" date="Sun Apr 17 17:48:25 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7604" docExpressionCount="800" docLength="8692" endLine="89" length="3" offset="3634" startLine="89" starttimestamp="1650226882502" timestamp="5223248">
    <text><![CDATA[ecl]]></text>
  </DocumentChange>
  <Command __id="1921" _type="SelectTextCommand" caretOffset="3653" date="Sun Apr 17 17:48:33 EDT 2022" end="3656" start="3653" starttimestamp="1650226882502" timestamp="5230562" />
  <Command __id="1922" _type="SelectTextCommand" caretOffset="3653" date="Sun Apr 17 17:48:33 EDT 2022" end="3656" start="3653" starttimestamp="1650226882502" timestamp="5230567" />
  <Command __id="1924" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:34 EDT 2022" starttimestamp="1650226882502" timestamp="5231570" />
  <Command __id="1925" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:34 EDT 2022" starttimestamp="1650226882502" timestamp="5231570" />
  <Command __id="1926" _type="SelectTextCommand" caretOffset="3683" date="Sun Apr 17 17:48:38 EDT 2022" end="3686" start="3683" starttimestamp="1650226882502" timestamp="5236309" />
  <Command __id="1927" _type="SelectTextCommand" caretOffset="3683" date="Sun Apr 17 17:48:38 EDT 2022" end="3686" start="3683" starttimestamp="1650226882502" timestamp="5236319" />
  <Command __id="1929" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:39 EDT 2022" starttimestamp="1650226882502" timestamp="5236916" />
  <Command __id="1930" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:39 EDT 2022" starttimestamp="1650226882502" timestamp="5236916" />
  <Command __id="1931" _type="MoveCaretCommand" caretOffset="3690" date="Sun Apr 17 17:48:44 EDT 2022" docOffset="3690" starttimestamp="1650226882502" timestamp="5241649" />
  <Command __id="1932" _type="MoveCaretCommand" caretOffset="3690" date="Sun Apr 17 17:48:44 EDT 2022" docOffset="3690" starttimestamp="1650226882502" timestamp="5241663" />
  <Command __id="1933" _type="SelectTextCommand" caretOffset="3688" date="Sun Apr 17 17:48:45 EDT 2022" end="3691" start="3688" starttimestamp="1650226882502" timestamp="5242689" />
  <Command __id="1934" _type="SelectTextCommand" caretOffset="3688" date="Sun Apr 17 17:48:45 EDT 2022" end="3691" start="3688" starttimestamp="1650226882502" timestamp="5242695" />
  <Command __id="1936" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:45 EDT 2022" starttimestamp="1650226882502" timestamp="5243289" />
  <Command __id="1937" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:48:45 EDT 2022" starttimestamp="1650226882502" timestamp="5243289" />
  <DocumentChange __id="1923" _type="Delete" date="Sun Apr 17 17:48:34 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7601" docExpressionCount="800" docLength="8689" endLine="90" length="3" offset="3653" startLine="90" starttimestamp="1650226882502" timestamp="5231570">
    <text><![CDATA[ecl]]></text>
  </DocumentChange>
  <DocumentChange __id="1928" _type="Delete" date="Sun Apr 17 17:48:39 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7598" docExpressionCount="800" docLength="8686" endLine="90" length="3" offset="3683" startLine="90" starttimestamp="1650226882502" timestamp="5236913">
    <text><![CDATA[ist]]></text>
  </DocumentChange>
  <DocumentChange __id="1935" _type="Delete" date="Sun Apr 17 17:48:45 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7595" docExpressionCount="800" docLength="8683" endLine="90" length="3" offset="3688" startLine="90" starttimestamp="1650226882502" timestamp="5243289">
    <text><![CDATA[ist]]></text>
  </DocumentChange>
  <Command __id="1938" _type="MoveCaretCommand" caretOffset="3699" date="Sun Apr 17 17:48:46 EDT 2022" docOffset="3699" starttimestamp="1650226882502" timestamp="5244423" />
  <Command __id="1939" _type="MoveCaretCommand" caretOffset="3699" date="Sun Apr 17 17:48:46 EDT 2022" docOffset="3699" starttimestamp="1650226882502" timestamp="5244423" />
  <Command __id="1940" _type="MoveCaretCommand" caretOffset="3695" date="Sun Apr 17 17:48:47 EDT 2022" docOffset="3695" starttimestamp="1650226882502" timestamp="5244838" />
  <Command __id="1941" _type="MoveCaretCommand" caretOffset="3695" date="Sun Apr 17 17:48:47 EDT 2022" docOffset="3695" starttimestamp="1650226882502" timestamp="5244839" />
  <DocumentChange __id="1942" _type="Insert" date="Sun Apr 17 17:48:49 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7599" docExpressionCount="800" docLength="8687" length="4" offset="3695" starttimestamp="1650226882502" timestamp="5247441">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="1943" _type="InsertStringCommand" date="Sun Apr 17 17:48:49 EDT 2022" starttimestamp="1650226882502" timestamp="5247457" timestamp2="5247457">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1944" _type="InsertStringCommand" date="Sun Apr 17 17:48:49 EDT 2022" starttimestamp="1650226882502" timestamp="5247457" timestamp2="5247457">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1946" _type="InsertStringCommand" date="Sun Apr 17 17:48:50 EDT 2022" starttimestamp="1650226882502" timestamp="5247673" timestamp2="5247673">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1947" _type="InsertStringCommand" date="Sun Apr 17 17:48:50 EDT 2022" starttimestamp="1650226882502" timestamp="5247673" timestamp2="5247673">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="1948" _type="ShellCommand" date="Sun Apr 17 17:49:32 EDT 2022" starttimestamp="1650226882502" timestamp="5290488" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="1949" _type="ShellCommand" date="Sun Apr 17 17:49:35 EDT 2022" starttimestamp="1650226882502" timestamp="5293343" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="1950" _type="MoveCaretCommand" caretOffset="3703" date="Sun Apr 17 17:49:35 EDT 2022" docOffset="3703" starttimestamp="1650226882502" timestamp="5293423" />
  <Command __id="1951" _type="MoveCaretCommand" caretOffset="3703" date="Sun Apr 17 17:49:35 EDT 2022" docOffset="3703" starttimestamp="1650226882502" timestamp="5293423" />
  <Command __id="1953" _type="PasteCommand" date="Sun Apr 17 17:49:36 EDT 2022" starttimestamp="1650226882502" timestamp="5293537" />
  <Command __id="1954" _type="MoveCaretCommand" caretOffset="3722" date="Sun Apr 17 17:49:38 EDT 2022" docOffset="3722" starttimestamp="1650226882502" timestamp="5295511" />
  <Command __id="1955" _type="MoveCaretCommand" caretOffset="3722" date="Sun Apr 17 17:49:38 EDT 2022" docOffset="3722" starttimestamp="1650226882502" timestamp="5295511" />
  <Command __id="1956" _type="SelectTextCommand" caretOffset="3723" date="Sun Apr 17 17:49:38 EDT 2022" end="3723" start="3717" starttimestamp="1650226882502" timestamp="5296196" />
  <Command __id="1957" _type="SelectTextCommand" caretOffset="3723" date="Sun Apr 17 17:49:38 EDT 2022" end="3723" start="3717" starttimestamp="1650226882502" timestamp="5296207" />
  <Command __id="1958" _type="MoveCaretCommand" caretOffset="3720" date="Sun Apr 17 17:49:38 EDT 2022" docOffset="3720" starttimestamp="1650226882502" timestamp="5296400" />
  <Command __id="1959" _type="MoveCaretCommand" caretOffset="3720" date="Sun Apr 17 17:49:38 EDT 2022" docOffset="3720" starttimestamp="1650226882502" timestamp="5296400" />
  <Command __id="1960" _type="SelectTextCommand" caretOffset="3719" date="Sun Apr 17 17:49:41 EDT 2022" end="3722" start="3719" starttimestamp="1650226882502" timestamp="5298752" />
  <Command __id="1961" _type="SelectTextCommand" caretOffset="3719" date="Sun Apr 17 17:49:41 EDT 2022" end="3722" start="3719" starttimestamp="1650226882502" timestamp="5298767" />
  <Command __id="1963" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:41 EDT 2022" starttimestamp="1650226882502" timestamp="5299354" />
  <Command __id="1964" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:41 EDT 2022" starttimestamp="1650226882502" timestamp="5299354" />
  <Command __id="1965" _type="SelectTextCommand" caretOffset="3765" date="Sun Apr 17 17:49:43 EDT 2022" end="3765" start="3723" starttimestamp="1650226882502" timestamp="5301320" />
  <Command __id="1966" _type="SelectTextCommand" caretOffset="3765" date="Sun Apr 17 17:49:43 EDT 2022" end="3765" start="3723" starttimestamp="1650226882502" timestamp="5301327" />
  <Command __id="1967" _type="MoveCaretCommand" caretOffset="3724" date="Sun Apr 17 17:49:44 EDT 2022" docOffset="3724" starttimestamp="1650226882502" timestamp="5301642" />
  <Command __id="1968" _type="MoveCaretCommand" caretOffset="3724" date="Sun Apr 17 17:49:44 EDT 2022" docOffset="3724" starttimestamp="1650226882502" timestamp="5301642" />
  <Command __id="1969" _type="SelectTextCommand" caretOffset="3764" date="Sun Apr 17 17:49:45 EDT 2022" end="3767" start="3764" starttimestamp="1650226882502" timestamp="5303322" />
  <Command __id="1970" _type="SelectTextCommand" caretOffset="3764" date="Sun Apr 17 17:49:45 EDT 2022" end="3767" start="3764" starttimestamp="1650226882502" timestamp="5303327" />
  <Command __id="1972" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:46 EDT 2022" starttimestamp="1650226882502" timestamp="5303807" />
  <Command __id="1973" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:46 EDT 2022" starttimestamp="1650226882502" timestamp="5303807" />
  <Command __id="1974" _type="SelectTextCommand" caretOffset="3805" date="Sun Apr 17 17:49:48 EDT 2022" end="3808" start="3805" starttimestamp="1650226882502" timestamp="5306261" />
  <Command __id="1975" _type="SelectTextCommand" caretOffset="3805" date="Sun Apr 17 17:49:48 EDT 2022" end="3808" start="3805" starttimestamp="1650226882502" timestamp="5306263" />
  <Command __id="1977" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:49 EDT 2022" starttimestamp="1650226882502" timestamp="5307209" />
  <Command __id="1978" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:49 EDT 2022" starttimestamp="1650226882502" timestamp="5307209" />
  <Command __id="1979" _type="SelectTextCommand" caretOffset="3835" date="Sun Apr 17 17:49:52 EDT 2022" end="3838" start="3835" starttimestamp="1650226882502" timestamp="5309867" />
  <Command __id="1980" _type="SelectTextCommand" caretOffset="3835" date="Sun Apr 17 17:49:52 EDT 2022" end="3838" start="3835" starttimestamp="1650226882502" timestamp="5309871" />
  <Command __id="1982" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:52 EDT 2022" starttimestamp="1650226882502" timestamp="5310461" />
  <Command __id="1983" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:52 EDT 2022" starttimestamp="1650226882502" timestamp="5310461" />
  <Command __id="1984" _type="SelectTextCommand" caretOffset="3840" date="Sun Apr 17 17:49:56 EDT 2022" end="3843" start="3840" starttimestamp="1650226882502" timestamp="5313867" />
  <Command __id="1985" _type="SelectTextCommand" caretOffset="3840" date="Sun Apr 17 17:49:56 EDT 2022" end="3843" start="3840" starttimestamp="1650226882502" timestamp="5313879" />
  <Command __id="1987" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:56 EDT 2022" starttimestamp="1650226882502" timestamp="5314431" />
  <Command __id="1988" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:49:56 EDT 2022" starttimestamp="1650226882502" timestamp="5314431" />
  <DocumentChange __id="1945" _type="Insert" date="Sun Apr 17 17:48:50 EDT 2022" docASTNodeCount="1290" docActiveCodeLength="7603" docExpressionCount="800" docLength="8691" length="4" offset="3699" starttimestamp="1650226882502" timestamp="5247673">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="1952" _type="Replace" date="Sun Apr 17 17:49:36 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7879" docExpressionCount="831" docLength="8967" endLine="92" insertionLength="278" int_docASTNodeCount="1290" int_docActiveCodeLength="7601" int_docExpressionCount="800" int_docLength="8689" length="2" offset="3701" startLine="92" starttimestamp="1650226882502" timestamp="5293521">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		FieldDeclList flist3 = new FieldDeclList();
		MethodDeclList mlist3 = new MethodDeclList();
		ClassDecl cdecl3 = new ClassDecl("String", flist3, mlist3, sp);
		
		table.enterID("_PrintStream", cdecl);
		table.enterID("System", cdecl2);
		table.enterID("String", cdecl3);]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="1962" _type="Delete" date="Sun Apr 17 17:49:41 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7876" docExpressionCount="831" docLength="8964" endLine="92" length="3" offset="3719" startLine="92" starttimestamp="1650226882502" timestamp="5299347">
    <text><![CDATA[ist]]></text>
  </DocumentChange>
  <DocumentChange __id="1971" _type="Delete" date="Sun Apr 17 17:49:46 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7873" docExpressionCount="831" docLength="8961" endLine="93" length="3" offset="3764" startLine="93" starttimestamp="1650226882502" timestamp="5303807">
    <text><![CDATA[ist]]></text>
  </DocumentChange>
  <DocumentChange __id="1976" _type="Delete" date="Sun Apr 17 17:49:49 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7870" docExpressionCount="831" docLength="8958" endLine="94" length="3" offset="3805" startLine="94" starttimestamp="1650226882502" timestamp="5307209">
    <text><![CDATA[ecl]]></text>
  </DocumentChange>
  <DocumentChange __id="1981" _type="Delete" date="Sun Apr 17 17:49:52 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7867" docExpressionCount="831" docLength="8955" endLine="94" length="3" offset="3835" startLine="94" starttimestamp="1650226882502" timestamp="5310461">
    <text><![CDATA[ist]]></text>
  </DocumentChange>
  <DocumentChange __id="1986" _type="Delete" date="Sun Apr 17 17:49:56 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7864" docExpressionCount="831" docLength="8952" endLine="94" length="3" offset="3840" startLine="94" starttimestamp="1650226882502" timestamp="5314431">
    <text><![CDATA[ist]]></text>
  </DocumentChange>
  <Command __id="1989" _type="SelectTextCommand" caretOffset="3887" date="Sun Apr 17 17:50:02 EDT 2022" end="3890" start="3887" starttimestamp="1650226882502" timestamp="5319574" />
  <Command __id="1990" _type="SelectTextCommand" caretOffset="3887" date="Sun Apr 17 17:50:02 EDT 2022" end="3890" start="3887" starttimestamp="1650226882502" timestamp="5319574" />
  <DocumentChange __id="1991" _type="Delete" date="Sun Apr 17 17:50:04 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7861" docExpressionCount="831" docLength="8949" endLine="96" length="3" offset="3887" startLine="96" starttimestamp="1650226882502" timestamp="5322093">
    <text><![CDATA[ecl]]></text>
  </DocumentChange>
  <Command __id="1992" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:04 EDT 2022" starttimestamp="1650226882502" timestamp="5322108" />
  <Command __id="1993" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:04 EDT 2022" starttimestamp="1650226882502" timestamp="5322108" />
  <Command __id="1995" _type="InsertStringCommand" date="Sun Apr 17 17:50:05 EDT 2022" starttimestamp="1650226882502" timestamp="5322914" timestamp2="5322914">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1996" _type="InsertStringCommand" date="Sun Apr 17 17:50:05 EDT 2022" starttimestamp="1650226882502" timestamp="5322914" timestamp2="5322914">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="1997" _type="SelectTextCommand" caretOffset="3920" date="Sun Apr 17 17:50:07 EDT 2022" end="3923" start="3920" starttimestamp="1650226882502" timestamp="5324655" />
  <Command __id="1998" _type="SelectTextCommand" caretOffset="3920" date="Sun Apr 17 17:50:07 EDT 2022" end="3923" start="3920" starttimestamp="1650226882502" timestamp="5324655" />
  <Command __id="2000" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:07 EDT 2022" starttimestamp="1650226882502" timestamp="5325334" />
  <Command __id="2001" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:07 EDT 2022" starttimestamp="1650226882502" timestamp="5325334" />
  <Command __id="2003" _type="InsertStringCommand" date="Sun Apr 17 17:50:07 EDT 2022" starttimestamp="1650226882502" timestamp="5325341" timestamp2="5325341">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="2004" _type="InsertStringCommand" date="Sun Apr 17 17:50:07 EDT 2022" starttimestamp="1650226882502" timestamp="5325341" timestamp2="5325341">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="2006" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:08 EDT 2022" starttimestamp="1650226882502" timestamp="5326141" />
  <Command __id="2007" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:08 EDT 2022" starttimestamp="1650226882502" timestamp="5326141" />
  <DocumentChange __id="1994" _type="Insert" date="Sun Apr 17 17:50:05 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7862" docExpressionCount="831" docLength="8950" length="1" offset="3887" starttimestamp="1650226882502" timestamp="5322898">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="1999" _type="Delete" date="Sun Apr 17 17:50:07 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7859" docExpressionCount="831" docLength="8947" endLine="97" length="3" offset="3920" startLine="97" starttimestamp="1650226882502" timestamp="5325334">
    <text><![CDATA[ecl]]></text>
  </DocumentChange>
  <DocumentChange __id="2002" _type="Insert" date="Sun Apr 17 17:50:07 EDT 2022" docASTNodeCount="1338" docActiveCodeLength="7860" docExpressionCount="833" docLength="8948" length="1" offset="3920" starttimestamp="1650226882502" timestamp="5325341">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="2005" _type="Delete" date="Sun Apr 17 17:50:08 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7859" docExpressionCount="831" docLength="8947" endLine="97" length="1" offset="3920" startLine="97" starttimestamp="1650226882502" timestamp="5326141">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="2010" _type="Delete" date="Sun Apr 17 17:50:12 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7856" docExpressionCount="831" docLength="8944" endLine="98" length="3" offset="3953" startLine="98" starttimestamp="1650226882502" timestamp="5329792">
    <text><![CDATA[ecl]]></text>
  </DocumentChange>
  <Command __id="2013" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:50:22 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="5340287">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2008" _type="SelectTextCommand" caretOffset="3953" date="Sun Apr 17 17:50:11 EDT 2022" end="3956" start="3953" starttimestamp="1650226882502" timestamp="5329260" />
  <Command __id="2009" _type="SelectTextCommand" caretOffset="3953" date="Sun Apr 17 17:50:11 EDT 2022" end="3956" start="3953" starttimestamp="1650226882502" timestamp="5329271" />
  <Command __id="2011" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:12 EDT 2022" starttimestamp="1650226882502" timestamp="5329792" />
  <Command __id="2012" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:12 EDT 2022" starttimestamp="1650226882502" timestamp="5329792" />
  <Command __id="2014" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 17:50:22 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="5340334" />
  <Command __id="2016" _type="MoveCaretCommand" caretOffset="3953" date="Sun Apr 17 17:50:24 EDT 2022" docOffset="3953" starttimestamp="1650226882502" timestamp="5341942" />
  <Command __id="2017" _type="MoveCaretCommand" caretOffset="3868" date="Sun Apr 17 17:50:25 EDT 2022" docOffset="3868" starttimestamp="1650226882502" timestamp="5342880" />
  <Command __id="2018" _type="MoveCaretCommand" caretOffset="3868" date="Sun Apr 17 17:50:25 EDT 2022" docOffset="3868" starttimestamp="1650226882502" timestamp="5342887" />
  <Command __id="2020" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:25 EDT 2022" starttimestamp="1650226882502" timestamp="5343343" />
  <Command __id="2021" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:25 EDT 2022" starttimestamp="1650226882502" timestamp="5343343" />
  <Command __id="2023" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:26 EDT 2022" starttimestamp="1650226882502" timestamp="5343512" />
  <Command __id="2024" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:26 EDT 2022" starttimestamp="1650226882502" timestamp="5343512" />
  <Command __id="2025" _type="MoveCaretCommand" caretOffset="3905" date="Sun Apr 17 17:50:26 EDT 2022" docOffset="3905" starttimestamp="1650226882502" timestamp="5343998" />
  <Command __id="2026" _type="MoveCaretCommand" caretOffset="3905" date="Sun Apr 17 17:50:26 EDT 2022" docOffset="3905" starttimestamp="1650226882502" timestamp="5343998" />
  <Command __id="2028" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:26 EDT 2022" starttimestamp="1650226882502" timestamp="5344082" />
  <Command __id="2029" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:26 EDT 2022" starttimestamp="1650226882502" timestamp="5344082" />
  <Command __id="2031" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:26 EDT 2022" starttimestamp="1650226882502" timestamp="5344245" />
  <Command __id="2032" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:26 EDT 2022" starttimestamp="1650226882502" timestamp="5344245" />
  <Command __id="2033" _type="MoveCaretCommand" caretOffset="3935" date="Sun Apr 17 17:50:27 EDT 2022" docOffset="3935" starttimestamp="1650226882502" timestamp="5345301" />
  <Command __id="2034" _type="MoveCaretCommand" caretOffset="3935" date="Sun Apr 17 17:50:27 EDT 2022" docOffset="3935" starttimestamp="1650226882502" timestamp="5345311" />
  <Command __id="2036" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:27 EDT 2022" starttimestamp="1650226882502" timestamp="5345470" />
  <Command __id="2037" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:27 EDT 2022" starttimestamp="1650226882502" timestamp="5345470" />
  <Command __id="2038" _type="MoveCaretCommand" caretOffset="3935" date="Sun Apr 17 17:50:28 EDT 2022" docOffset="3935" starttimestamp="1650226882502" timestamp="5346419" />
  <Command __id="2039" _type="MoveCaretCommand" caretOffset="3935" date="Sun Apr 17 17:50:28 EDT 2022" docOffset="3935" starttimestamp="1650226882502" timestamp="5346431" />
  <Command __id="2041" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:28 EDT 2022" starttimestamp="1650226882502" timestamp="5346473" />
  <Command __id="2042" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:28 EDT 2022" starttimestamp="1650226882502" timestamp="5346473" />
  <Command __id="2015" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:50:24 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7856" docExpressionCount="831" docLength="8944" projectName="pa3" starttimestamp="1650226882502" timestamp="5341880">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd"), Diff(DELETE,"ecl"), Diff(INSERT,"1"), Diff(EQUAL," = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶"), Diff(DELETE,""), Diff(EQUAL,"		id2.decl = "), Diff(INSERT,"cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enterID("_PrintStream", cd1);¶		table.enterID("System", cd2);¶		table.enterID("String", cd3);¶		"), Diff(EQUAL,"¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enterID("_PrintStream", cd1);
		table.enterID("System", cd2);
		table.enterID("String", cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="2019" _type="Delete" date="Sun Apr 17 17:50:25 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7855" docExpressionCount="831" docLength="8943" endLine="96" length="1" offset="3867" startLine="96" starttimestamp="1650226882502" timestamp="5343343">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <DocumentChange __id="2022" _type="Delete" date="Sun Apr 17 17:50:26 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7854" docExpressionCount="831" docLength="8942" endLine="96" length="1" offset="3866" startLine="96" starttimestamp="1650226882502" timestamp="5343512">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="2027" _type="Delete" date="Sun Apr 17 17:50:26 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7853" docExpressionCount="831" docLength="8941" endLine="97" length="1" offset="3904" startLine="97" starttimestamp="1650226882502" timestamp="5344067">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <DocumentChange __id="2030" _type="Delete" date="Sun Apr 17 17:50:26 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7852" docExpressionCount="831" docLength="8940" endLine="97" length="1" offset="3903" startLine="97" starttimestamp="1650226882502" timestamp="5344245">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="2035" _type="Delete" date="Sun Apr 17 17:50:27 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7851" docExpressionCount="831" docLength="8939" endLine="98" length="1" offset="3934" startLine="98" starttimestamp="1650226882502" timestamp="5345470">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="2040" _type="Delete" date="Sun Apr 17 17:50:28 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7850" docExpressionCount="831" docLength="8938" endLine="98" length="1" offset="3934" startLine="98" starttimestamp="1650226882502" timestamp="5346473">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="2043" _type="MoveCaretCommand" caretOffset="3789" date="Sun Apr 17 17:50:33 EDT 2022" docOffset="3789" starttimestamp="1650226882502" timestamp="5351009" />
  <Command __id="2044" _type="MoveCaretCommand" caretOffset="3789" date="Sun Apr 17 17:50:33 EDT 2022" docOffset="3789" starttimestamp="1650226882502" timestamp="5351021" />
  <Command __id="2045" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:50:36 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="5354335">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2046" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 17:50:36 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="5354398" />
  <Command __id="2048" _type="MoveCaretCommand" caretOffset="3789" date="Sun Apr 17 17:50:38 EDT 2022" docOffset="3789" starttimestamp="1650226882502" timestamp="5356434" />
  <Command __id="2049" _type="SelectTextCommand" caretOffset="3867" date="Sun Apr 17 17:50:42 EDT 2022" end="3882" start="3867" starttimestamp="1650226882502" timestamp="5360491" />
  <Command __id="2050" _type="SelectTextCommand" caretOffset="3867" date="Sun Apr 17 17:50:42 EDT 2022" end="3882" start="3867" starttimestamp="1650226882502" timestamp="5360495" />
  <Command __id="2052" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:43 EDT 2022" starttimestamp="1650226882502" timestamp="5360511" />
  <Command __id="2053" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:43 EDT 2022" starttimestamp="1650226882502" timestamp="5360511" />
  <Command __id="2054" _type="MoveCaretCommand" caretOffset="3868" date="Sun Apr 17 17:50:44 EDT 2022" docOffset="3868" starttimestamp="1650226882502" timestamp="5361822" />
  <Command __id="2055" _type="MoveCaretCommand" caretOffset="3868" date="Sun Apr 17 17:50:44 EDT 2022" docOffset="3868" starttimestamp="1650226882502" timestamp="5361822" />
  <Command __id="2057" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:44 EDT 2022" starttimestamp="1650226882502" timestamp="5361882" />
  <Command __id="2058" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:44 EDT 2022" starttimestamp="1650226882502" timestamp="5361882" />
  <Command __id="2059" _type="SelectTextCommand" caretOffset="3888" date="Sun Apr 17 17:50:46 EDT 2022" end="3898" start="3888" starttimestamp="1650226882502" timestamp="5363626" />
  <Command __id="2060" _type="SelectTextCommand" caretOffset="3888" date="Sun Apr 17 17:50:46 EDT 2022" end="3898" start="3888" starttimestamp="1650226882502" timestamp="5363631" />
  <Command __id="2062" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:46 EDT 2022" starttimestamp="1650226882502" timestamp="5363647" />
  <Command __id="2063" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:46 EDT 2022" starttimestamp="1650226882502" timestamp="5363647" />
  <Command __id="2064" _type="SelectTextCommand" caretOffset="3909" date="Sun Apr 17 17:50:48 EDT 2022" end="3919" start="3909" starttimestamp="1650226882502" timestamp="5365545" />
  <Command __id="2065" _type="SelectTextCommand" caretOffset="3909" date="Sun Apr 17 17:50:48 EDT 2022" end="3919" start="3909" starttimestamp="1650226882502" timestamp="5365558" />
  <Command __id="2067" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:48 EDT 2022" starttimestamp="1650226882502" timestamp="5365590" />
  <Command __id="2068" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 17:50:48 EDT 2022" starttimestamp="1650226882502" timestamp="5365590" />
  <Command __id="2069" _type="MoveCaretCommand" caretOffset="3914" date="Sun Apr 17 17:50:48 EDT 2022" docOffset="3914" starttimestamp="1650226882502" timestamp="5365993" />
  <Command __id="2070" _type="MoveCaretCommand" caretOffset="3914" date="Sun Apr 17 17:50:48 EDT 2022" docOffset="3914" starttimestamp="1650226882502" timestamp="5365999" />
  <Command __id="2071" _type="ShellCommand" date="Sun Apr 17 17:51:04 EDT 2022" starttimestamp="1650226882502" timestamp="5381864" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2072" _type="ShellCommand" date="Sun Apr 17 17:51:16 EDT 2022" starttimestamp="1650226882502" timestamp="5393785" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2073" _type="SelectTextCommand" caretOffset="2662" date="Sun Apr 17 17:51:17 EDT 2022" end="2680" start="2662" starttimestamp="1650226882502" timestamp="5395255" />
  <Command __id="2074" _type="SelectTextCommand" caretOffset="2662" date="Sun Apr 17 17:51:17 EDT 2022" end="2680" start="2662" starttimestamp="1650226882502" timestamp="5395255" />
  <Command __id="2075" _type="CopyCommand" date="Sun Apr 17 17:51:17 EDT 2022" starttimestamp="1650226882502" timestamp="5395454" />
  <Command __id="2076" _type="MoveCaretCommand" caretOffset="3918" date="Sun Apr 17 18:02:04 EDT 2022" docOffset="3918" starttimestamp="1650226882502" timestamp="6041722" />
  <Command __id="2077" _type="MoveCaretCommand" caretOffset="3918" date="Sun Apr 17 18:02:04 EDT 2022" docOffset="3918" starttimestamp="1650226882502" timestamp="6041726" />
  <Command __id="2047" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 17:50:38 EDT 2022" docASTNodeCount="1336" docActiveCodeLength="7850" docExpressionCount="831" docLength="8938" projectName="pa3" starttimestamp="1650226882502" timestamp="5356388">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter"), Diff(DELETE,"ID"), Diff(EQUAL,"("_PrintStream", cd1);¶		table.enter"), Diff(DELETE,"ID"), Diff(EQUAL,"("System", cd2);¶		table.enter"), Diff(DELETE,"ID"), Diff(EQUAL,"("String", cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enter("_PrintStream", cd1);
		table.enter("System", cd2);
		table.enter("String", cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="2051" _type="Delete" date="Sun Apr 17 17:50:43 EDT 2022" docASTNodeCount="1335" docActiveCodeLength="7835" docExpressionCount="830" docLength="8923" endLine="96" length="15" offset="3867" startLine="96" starttimestamp="1650226882502" timestamp="5360511">
    <text><![CDATA["_PrintStream",]]></text>
  </DocumentChange>
  <DocumentChange __id="2056" _type="Delete" date="Sun Apr 17 17:50:44 EDT 2022" docASTNodeCount="1335" docActiveCodeLength="7834" docExpressionCount="830" docLength="8922" endLine="96" length="1" offset="3867" startLine="96" starttimestamp="1650226882502" timestamp="5361879">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2061" _type="Delete" date="Sun Apr 17 17:50:46 EDT 2022" docASTNodeCount="1334" docActiveCodeLength="7824" docExpressionCount="829" docLength="8912" endLine="97" length="10" offset="3888" startLine="97" starttimestamp="1650226882502" timestamp="5363647">
    <text><![CDATA["System", ]]></text>
  </DocumentChange>
  <DocumentChange __id="2066" _type="Delete" date="Sun Apr 17 17:50:48 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8902" endLine="98" length="10" offset="3909" startLine="98" starttimestamp="1650226882502" timestamp="5365575">
    <text><![CDATA["String", ]]></text>
  </DocumentChange>
  <Command __id="2078" _type="MoveCaretCommand" caretOffset="2677" date="Sun Apr 17 18:02:06 EDT 2022" docOffset="2677" starttimestamp="1650226882502" timestamp="6043738" />
  <Command __id="2079" _type="MoveCaretCommand" caretOffset="2677" date="Sun Apr 17 18:02:06 EDT 2022" docOffset="2677" starttimestamp="1650226882502" timestamp="6043742" />
  <Command __id="2080" _type="MoveCaretCommand" caretOffset="2658" date="Sun Apr 17 18:02:06 EDT 2022" docOffset="2658" starttimestamp="1650226882502" timestamp="6044077" />
  <Command __id="2081" _type="MoveCaretCommand" caretOffset="2658" date="Sun Apr 17 18:02:06 EDT 2022" docOffset="2658" starttimestamp="1650226882502" timestamp="6044077" />
  <DocumentChange __id="2082" _type="Insert" date="Sun Apr 17 18:02:08 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7815" docExpressionCount="828" docLength="8903" length="1" offset="2658" starttimestamp="1650226882502" timestamp="6045646">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <Command __id="2083" _type="InsertStringCommand" date="Sun Apr 17 18:02:08 EDT 2022" starttimestamp="1650226882502" timestamp="6045646" timestamp2="6045646">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="2084" _type="InsertStringCommand" date="Sun Apr 17 18:02:08 EDT 2022" starttimestamp="1650226882502" timestamp="6045646" timestamp2="6045646">
    <data><![CDATA[/]]></data>
  </Command>
  <DocumentChange __id="2085" _type="Insert" date="Sun Apr 17 18:02:08 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8904" length="1" offset="2659" starttimestamp="1650226882502" timestamp="6045793">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <Command __id="2086" _type="InsertStringCommand" date="Sun Apr 17 18:02:08 EDT 2022" starttimestamp="1650226882502" timestamp="6045793" timestamp2="6045793">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="2087" _type="InsertStringCommand" date="Sun Apr 17 18:02:08 EDT 2022" starttimestamp="1650226882502" timestamp="6045793" timestamp2="6045793">
    <data><![CDATA[/]]></data>
  </Command>
  <DocumentChange __id="2088" _type="Insert" date="Sun Apr 17 18:02:08 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8905" length="1" offset="2660" starttimestamp="1650226882502" timestamp="6046125">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2089" _type="InsertStringCommand" date="Sun Apr 17 18:02:08 EDT 2022" starttimestamp="1650226882502" timestamp="6046125" timestamp2="6046125">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2090" _type="InsertStringCommand" date="Sun Apr 17 18:02:08 EDT 2022" starttimestamp="1650226882502" timestamp="6046125" timestamp2="6046125">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2091" _type="Insert" date="Sun Apr 17 18:02:09 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8906" length="1" offset="2661" starttimestamp="1650226882502" timestamp="6046662">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="2092" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6046678" timestamp2="6046678">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2093" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6046678" timestamp2="6046678">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="2094" _type="Insert" date="Sun Apr 17 18:02:09 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8907" length="1" offset="2662" starttimestamp="1650226882502" timestamp="6046824">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="2095" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6046824" timestamp2="6046824">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="2096" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6046824" timestamp2="6046824">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="2097" _type="Insert" date="Sun Apr 17 18:02:09 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8908" length="1" offset="2663" starttimestamp="1650226882502" timestamp="6046994">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="2098" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6047009" timestamp2="6047009">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="2099" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6047009" timestamp2="6047009">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="2100" _type="Insert" date="Sun Apr 17 18:02:09 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8909" length="1" offset="2664" starttimestamp="1650226882502" timestamp="6047209">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="2101" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6047209" timestamp2="6047209">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="2102" _type="InsertStringCommand" date="Sun Apr 17 18:02:09 EDT 2022" starttimestamp="1650226882502" timestamp="6047209" timestamp2="6047209">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="2103" _type="Insert" date="Sun Apr 17 18:02:10 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8910" length="1" offset="2665" starttimestamp="1650226882502" timestamp="6047704">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2104" _type="InsertStringCommand" date="Sun Apr 17 18:02:10 EDT 2022" starttimestamp="1650226882502" timestamp="6047707" timestamp2="6047707">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2105" _type="InsertStringCommand" date="Sun Apr 17 18:02:10 EDT 2022" starttimestamp="1650226882502" timestamp="6047707" timestamp2="6047707">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2106" _type="Insert" date="Sun Apr 17 18:02:10 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8911" length="1" offset="2666" starttimestamp="1650226882502" timestamp="6047911">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2107" _type="InsertStringCommand" date="Sun Apr 17 18:02:10 EDT 2022" starttimestamp="1650226882502" timestamp="6047916" timestamp2="6047916">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2108" _type="InsertStringCommand" date="Sun Apr 17 18:02:10 EDT 2022" starttimestamp="1650226882502" timestamp="6047916" timestamp2="6047916">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2110" _type="InsertStringCommand" date="Sun Apr 17 18:02:10 EDT 2022" starttimestamp="1650226882502" timestamp="6048427" timestamp2="6048427">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="2111" _type="InsertStringCommand" date="Sun Apr 17 18:02:10 EDT 2022" starttimestamp="1650226882502" timestamp="6048427" timestamp2="6048427">
    <data><![CDATA[1]]></data>
  </Command>
  <DocumentChange __id="2109" _type="Insert" date="Sun Apr 17 18:02:10 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7814" docExpressionCount="828" docLength="8912" length="1" offset="2667" starttimestamp="1650226882502" timestamp="6048427">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="2114" _type="Insert" date="Sun Apr 17 18:02:13 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" length="4" offset="2654" starttimestamp="1650226882502" timestamp="6051233">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="2117" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:03:23 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="6120830">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2119" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:03:27 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" projectName="pa3" starttimestamp="1650226882502" timestamp="6125182">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		"), Diff(INSERT,"// scope 1¶		"), Diff(EQUAL,"table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter("), Diff(DELETE,""_PrintStream", "), Diff(EQUAL,"cd1);¶		table.enter("), Diff(DELETE,""System", "), Diff(EQUAL,"cd2);¶		table.enter("), Diff(DELETE,""String", "), Diff(EQUAL,"cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		// scope 1
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enter(cd1);
		table.enter(cd2);
		table.enter(cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="2121" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:03:33 EDT 2022" docASTNodeCount="89" docActiveCodeLength="510" docExpressionCount="47" docLength="607" projectName="pa3" starttimestamp="1650226882502" timestamp="6130716">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\ClassDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import  miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class ClassDecl extends Declaration {¶¶  public ClassDecl(String cn, FieldDeclList fdl, MethodDeclList mdl, SourcePosition posn) {¶	  super(cn, null, posn);¶	  fieldDeclList = fdl;¶	  methodDeclList = mdl;¶  }¶  ¶  public <A,R> R visit(Visitor<A, R> v, A o) {¶      return v.visitClassDecl(this, o);¶  }¶      ¶  public FieldDeclList fieldDeclList;¶  public MethodDeclList methodDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2112" _type="MoveCaretCommand" caretOffset="2654" date="Sun Apr 17 18:02:13 EDT 2022" docOffset="2654" starttimestamp="1650226882502" timestamp="6050598" />
  <Command __id="2113" _type="MoveCaretCommand" caretOffset="2654" date="Sun Apr 17 18:02:13 EDT 2022" docOffset="2654" starttimestamp="1650226882502" timestamp="6050598" />
  <Command __id="2115" _type="InsertStringCommand" date="Sun Apr 17 18:02:13 EDT 2022" starttimestamp="1650226882502" timestamp="6051248" timestamp2="6051248">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2116" _type="InsertStringCommand" date="Sun Apr 17 18:02:13 EDT 2022" starttimestamp="1650226882502" timestamp="6051248" timestamp2="6051248">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2118" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 18:03:23 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="6120883" />
  <Command __id="2120" _type="MoveCaretCommand" caretOffset="2658" date="Sun Apr 17 18:03:27 EDT 2022" docOffset="2658" starttimestamp="1650226882502" timestamp="6125244" />
  <Command __id="2122" _type="SelectTextCommand" caretOffset="159" date="Sun Apr 17 18:03:33 EDT 2022" end="159" start="150" starttimestamp="1650226882502" timestamp="6130851" />
  <Command __id="2125" _type="MoveCaretCommand" caretOffset="2658" date="Sun Apr 17 18:03:37 EDT 2022" docOffset="2658" starttimestamp="1650226882502" timestamp="6134905" />
  <Command __id="2126" _type="SelectTextCommand" caretOffset="159" date="Sun Apr 17 18:03:37 EDT 2022" end="159" start="150" starttimestamp="1650226882502" timestamp="6134905" />
  <Command __id="2127" _type="ShellCommand" date="Sun Apr 17 18:03:46 EDT 2022" starttimestamp="1650226882502" timestamp="6143700" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2123" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:03:37 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" projectName="pa3" starttimestamp="1650226882502" timestamp="6134651">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="2124" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:03:37 EDT 2022" docASTNodeCount="89" docActiveCodeLength="510" docExpressionCount="47" docLength="607" projectName="pa3" starttimestamp="1650226882502" timestamp="6134705">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\ClassDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import  miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class ClassDecl extends Declaration {¶¶  public ClassDecl(String cn, FieldDeclList fdl, MethodDeclList mdl, SourcePosition posn) {¶	  super(cn, null, posn);¶	  fieldDeclList = fdl;¶	  methodDeclList = mdl;¶  }¶  ¶  public <A,R> R visit(Visitor<A, R> v, A o) {¶      return v.visitClassDecl(this, o);¶  }¶      ¶  public FieldDeclList fieldDeclList;¶  public MethodDeclList methodDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2129" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:04:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" projectName="pa3" starttimestamp="1650226882502" timestamp="6213269">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="2138" _type="Insert" date="Sun Apr 17 18:05:02 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7823" docExpressionCount="828" docLength="8921" length="5" offset="3980" starttimestamp="1650226882502" timestamp="6219738">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="2128" _type="ShellCommand" date="Sun Apr 17 18:04:55 EDT 2022" starttimestamp="1650226882502" timestamp="6213240" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2130" _type="MoveCaretCommand" caretOffset="4001" date="Sun Apr 17 18:04:55 EDT 2022" docOffset="4001" starttimestamp="1650226882502" timestamp="6213335" />
  <Command __id="2131" _type="MoveCaretCommand" caretOffset="4001" date="Sun Apr 17 18:04:55 EDT 2022" docOffset="4001" starttimestamp="1650226882502" timestamp="6213345" />
  <Command __id="2132" _type="MoveCaretCommand" caretOffset="3980" date="Sun Apr 17 18:04:56 EDT 2022" docOffset="3980" starttimestamp="1650226882502" timestamp="6213648" />
  <Command __id="2133" _type="MoveCaretCommand" caretOffset="3980" date="Sun Apr 17 18:04:56 EDT 2022" docOffset="3980" starttimestamp="1650226882502" timestamp="6213653" />
  <Command __id="2134" _type="MoveCaretCommand" caretOffset="3969" date="Sun Apr 17 18:04:56 EDT 2022" docOffset="3969" starttimestamp="1650226882502" timestamp="6214070" />
  <Command __id="2135" _type="MoveCaretCommand" caretOffset="3969" date="Sun Apr 17 18:04:56 EDT 2022" docOffset="3969" starttimestamp="1650226882502" timestamp="6214085" />
  <Command __id="2136" _type="MoveCaretCommand" caretOffset="3980" date="Sun Apr 17 18:04:57 EDT 2022" docOffset="3980" starttimestamp="1650226882502" timestamp="6215029" />
  <Command __id="2137" _type="MoveCaretCommand" caretOffset="3980" date="Sun Apr 17 18:04:57 EDT 2022" docOffset="3980" starttimestamp="1650226882502" timestamp="6215029" />
  <Command __id="2139" _type="InsertStringCommand" date="Sun Apr 17 18:05:02 EDT 2022" starttimestamp="1650226882502" timestamp="6219738" timestamp2="6219738">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2140" _type="InsertStringCommand" date="Sun Apr 17 18:05:02 EDT 2022" starttimestamp="1650226882502" timestamp="6219738" timestamp2="6219738">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2142" _type="InsertStringCommand" date="Sun Apr 17 18:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="6221438" timestamp2="6221438">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="2143" _type="InsertStringCommand" date="Sun Apr 17 18:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="6221438" timestamp2="6221438">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="2145" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6221675" timestamp2="6221675">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="2146" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6221675" timestamp2="6221675">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="2148" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6221838" timestamp2="6221838">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2149" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6221838" timestamp2="6221838">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2151" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6221976" timestamp2="6221976">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2152" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6221976" timestamp2="6221976">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2154" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6222270" timestamp2="6222270">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="2155" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6222270" timestamp2="6222270">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="2157" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6222276" timestamp2="6222276">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="2158" _type="InsertStringCommand" date="Sun Apr 17 18:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="6222276" timestamp2="6222276">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="2160" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 18:05:05 EDT 2022" starttimestamp="1650226882502" timestamp="6222676" />
  <DocumentChange __id="2141" _type="Insert" date="Sun Apr 17 18:05:03 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7824" docExpressionCount="829" docLength="8922" length="1" offset="3985" starttimestamp="1650226882502" timestamp="6221438">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <DocumentChange __id="2144" _type="Insert" date="Sun Apr 17 18:05:04 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7825" docExpressionCount="829" docLength="8923" length="1" offset="3986" starttimestamp="1650226882502" timestamp="6221675">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="2147" _type="Insert" date="Sun Apr 17 18:05:04 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8924" length="1" offset="3987" starttimestamp="1650226882502" timestamp="6221823">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2150" _type="Insert" date="Sun Apr 17 18:05:04 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7827" docExpressionCount="828" docLength="8925" length="1" offset="3988" starttimestamp="1650226882502" timestamp="6221976">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2153" _type="Insert" date="Sun Apr 17 18:05:04 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7829" docExpressionCount="828" docLength="8927" length="2" offset="3989" starttimestamp="1650226882502" timestamp="6222270">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="2156" _type="Insert" date="Sun Apr 17 18:05:04 EDT 2022" docASTNodeCount="1300" docActiveCodeLength="7830" docExpressionCount="805" docLength="8928" length="1" offset="3990" starttimestamp="1650226882502" timestamp="6222276">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <DocumentChange __id="2159" _type="Delete" date="Sun Apr 17 18:05:05 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7829" docExpressionCount="828" docLength="8927" endLine="103" length="1" offset="3990" startLine="103" starttimestamp="1650226882502" timestamp="6222676">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="2161" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 18:05:05 EDT 2022" starttimestamp="1650226882502" timestamp="6222676" />
  <DocumentChange __id="2162" _type="Insert" date="Sun Apr 17 18:05:07 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7830" docExpressionCount="805" docLength="8928" length="1" offset="3990" starttimestamp="1650226882502" timestamp="6224642">
    <text><![CDATA[F]]></text>
  </DocumentChange>
  <Command __id="2163" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6224642" timestamp2="6224642">
    <data><![CDATA[F]]></data>
  </Command>
  <Command __id="2164" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6224642" timestamp2="6224642">
    <data><![CDATA[F]]></data>
  </Command>
  <DocumentChange __id="2165" _type="Insert" date="Sun Apr 17 18:05:07 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7831" docExpressionCount="805" docLength="8929" length="1" offset="3991" starttimestamp="1650226882502" timestamp="6224811">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="2166" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6224811" timestamp2="6224811">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2167" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6224811" timestamp2="6224811">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="2168" _type="Insert" date="Sun Apr 17 18:05:07 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7832" docExpressionCount="805" docLength="8930" length="1" offset="3992" starttimestamp="1650226882502" timestamp="6224979">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2169" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6224995" timestamp2="6224995">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2170" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6224995" timestamp2="6224995">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2171" _type="Insert" date="Sun Apr 17 18:05:07 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7833" docExpressionCount="805" docLength="8931" length="1" offset="3993" starttimestamp="1650226882502" timestamp="6225126">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2172" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6225126" timestamp2="6225126">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2173" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6225126" timestamp2="6225126">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="2174" _type="Insert" date="Sun Apr 17 18:05:07 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7834" docExpressionCount="805" docLength="8932" length="1" offset="3994" starttimestamp="1650226882502" timestamp="6225242">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2175" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6225242" timestamp2="6225242">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2176" _type="InsertStringCommand" date="Sun Apr 17 18:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="6225242" timestamp2="6225242">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="2177" _type="Insert" date="Sun Apr 17 18:05:09 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7835" docExpressionCount="805" docLength="8933" length="1" offset="3995" starttimestamp="1650226882502" timestamp="6226514">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <Command __id="2178" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6226514" timestamp2="6226514">
    <data><![CDATA[D]]></data>
  </Command>
  <Command __id="2179" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6226514" timestamp2="6226514">
    <data><![CDATA[D]]></data>
  </Command>
  <DocumentChange __id="2180" _type="Insert" date="Sun Apr 17 18:05:09 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7836" docExpressionCount="805" docLength="8934" length="1" offset="3996" starttimestamp="1650226882502" timestamp="6226730">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2181" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6226730" timestamp2="6226730">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2182" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6226730" timestamp2="6226730">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2183" _type="Insert" date="Sun Apr 17 18:05:09 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7837" docExpressionCount="805" docLength="8935" length="1" offset="3997" starttimestamp="1650226882502" timestamp="6226999">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="2184" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6226999" timestamp2="6226999">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="2185" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6226999" timestamp2="6226999">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="2186" _type="Insert" date="Sun Apr 17 18:05:09 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7838" docExpressionCount="805" docLength="8936" length="1" offset="3998" starttimestamp="1650226882502" timestamp="6227284">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2187" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6227284" timestamp2="6227284">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2188" _type="InsertStringCommand" date="Sun Apr 17 18:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="6227284" timestamp2="6227284">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="2189" _type="Insert" date="Sun Apr 17 18:05:10 EDT 2022" docASTNodeCount="1298" docActiveCodeLength="7839" docExpressionCount="805" docLength="8937" length="1" offset="3999" starttimestamp="1650226882502" timestamp="6227909">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2190" _type="InsertStringCommand" date="Sun Apr 17 18:05:10 EDT 2022" starttimestamp="1650226882502" timestamp="6227912" timestamp2="6227912">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2191" _type="InsertStringCommand" date="Sun Apr 17 18:05:10 EDT 2022" starttimestamp="1650226882502" timestamp="6227912" timestamp2="6227912">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2192" _type="Insert" date="Sun Apr 17 18:05:10 EDT 2022" docASTNodeCount="1305" docActiveCodeLength="7840" docExpressionCount="808" docLength="8938" length="1" offset="4000" starttimestamp="1650226882502" timestamp="6228332">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <Command __id="2193" _type="InsertStringCommand" date="Sun Apr 17 18:05:10 EDT 2022" starttimestamp="1650226882502" timestamp="6228332" timestamp2="6228332">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="2194" _type="InsertStringCommand" date="Sun Apr 17 18:05:10 EDT 2022" starttimestamp="1650226882502" timestamp="6228332" timestamp2="6228332">
    <data><![CDATA[f]]></data>
  </Command>
  <DocumentChange __id="2195" _type="Insert" date="Sun Apr 17 18:05:10 EDT 2022" docASTNodeCount="1305" docActiveCodeLength="7841" docExpressionCount="808" docLength="8939" length="1" offset="4001" starttimestamp="1650226882502" timestamp="6228401">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2196" _type="InsertStringCommand" date="Sun Apr 17 18:05:10 EDT 2022" starttimestamp="1650226882502" timestamp="6228401" timestamp2="6228401">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2197" _type="InsertStringCommand" date="Sun Apr 17 18:05:10 EDT 2022" starttimestamp="1650226882502" timestamp="6228401" timestamp2="6228401">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="2198" _type="Insert" date="Sun Apr 17 18:05:11 EDT 2022" docASTNodeCount="1339" docActiveCodeLength="7842" docExpressionCount="831" docLength="8940" length="1" offset="4002" starttimestamp="1650226882502" timestamp="6229303">
    <text><![CDATA[:]]></text>
  </DocumentChange>
  <Command __id="2199" _type="InsertStringCommand" date="Sun Apr 17 18:05:11 EDT 2022" starttimestamp="1650226882502" timestamp="6229303" timestamp2="6229303">
    <data><![CDATA[:]]></data>
  </Command>
  <Command __id="2200" _type="InsertStringCommand" date="Sun Apr 17 18:05:11 EDT 2022" starttimestamp="1650226882502" timestamp="6229303" timestamp2="6229303">
    <data><![CDATA[:]]></data>
  </Command>
  <DocumentChange __id="2201" _type="Insert" date="Sun Apr 17 18:05:13 EDT 2022" docASTNodeCount="1339" docActiveCodeLength="7843" docExpressionCount="831" docLength="8941" length="1" offset="4003" starttimestamp="1650226882502" timestamp="6230752">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2202" _type="InsertStringCommand" date="Sun Apr 17 18:05:13 EDT 2022" starttimestamp="1650226882502" timestamp="6230752" timestamp2="6230752">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2203" _type="InsertStringCommand" date="Sun Apr 17 18:05:13 EDT 2022" starttimestamp="1650226882502" timestamp="6230752" timestamp2="6230752">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2204" _type="Insert" date="Sun Apr 17 18:05:14 EDT 2022" docASTNodeCount="1339" docActiveCodeLength="7844" docExpressionCount="831" docLength="8942" length="1" offset="4004" starttimestamp="1650226882502" timestamp="6232323">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="2205" _type="InsertStringCommand" date="Sun Apr 17 18:05:14 EDT 2022" starttimestamp="1650226882502" timestamp="6232323" timestamp2="6232323">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="2206" _type="InsertStringCommand" date="Sun Apr 17 18:05:14 EDT 2022" starttimestamp="1650226882502" timestamp="6232323" timestamp2="6232323">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="2207" _type="Insert" date="Sun Apr 17 18:05:15 EDT 2022" docASTNodeCount="1339" docActiveCodeLength="7845" docExpressionCount="831" docLength="8943" length="1" offset="4005" starttimestamp="1650226882502" timestamp="6232555">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2208" _type="InsertStringCommand" date="Sun Apr 17 18:05:15 EDT 2022" starttimestamp="1650226882502" timestamp="6232570" timestamp2="6232570">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2209" _type="InsertStringCommand" date="Sun Apr 17 18:05:15 EDT 2022" starttimestamp="1650226882502" timestamp="6232570" timestamp2="6232570">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2211" _type="InsertStringCommand" date="Sun Apr 17 18:05:15 EDT 2022" starttimestamp="1650226882502" timestamp="6232739" timestamp2="6232739">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2212" _type="InsertStringCommand" date="Sun Apr 17 18:05:15 EDT 2022" starttimestamp="1650226882502" timestamp="6232739" timestamp2="6232739">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2213" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 18:05:15 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="6232739" />
  <DocumentChange __id="2210" _type="Insert" date="Sun Apr 17 18:05:15 EDT 2022" docASTNodeCount="1341" docActiveCodeLength="7846" docExpressionCount="832" docLength="8944" length="1" offset="4006" starttimestamp="1650226882502" timestamp="6232724">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="2215" _type="Insert" date="Sun Apr 17 18:05:16 EDT 2022" docASTNodeCount="1341" docActiveCodeLength="7859" docExpressionCount="833" docLength="8957" length="13" offset="4007" starttimestamp="1650226882502" timestamp="6233994">
    <text><![CDATA[fieldDeclList]]></text>
  </DocumentChange>
  <DocumentChange __id="2220" _type="Insert" date="Sun Apr 17 18:05:17 EDT 2022" docASTNodeCount="1341" docActiveCodeLength="7860" docExpressionCount="833" docLength="8958" length="1" offset="4021" starttimestamp="1650226882502" timestamp="6234947">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2223" _type="Insert" date="Sun Apr 17 18:05:17 EDT 2022" docASTNodeCount="1342" docActiveCodeLength="7861" docExpressionCount="833" docLength="8959" length="1" offset="4022" starttimestamp="1650226882502" timestamp="6235191">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="2226" _type="Insert" date="Sun Apr 17 18:05:17 EDT 2022" docASTNodeCount="1342" docActiveCodeLength="7873" docExpressionCount="833" docLength="8971" length="12" offset="4023" starttimestamp="1650226882502" timestamp="6235323">
    <text><![CDATA[
				
			}]]></text>
  </DocumentChange>
  <DocumentChange __id="2229" _type="Insert" date="Sun Apr 17 18:05:20 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7874" docExpressionCount="834" docLength="8972" length="1" offset="4029" starttimestamp="1650226882502" timestamp="6237632">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <DocumentChange __id="2232" _type="Insert" date="Sun Apr 17 18:05:20 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7875" docExpressionCount="834" docLength="8973" length="1" offset="4030" starttimestamp="1650226882502" timestamp="6237729">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="2235" _type="Insert" date="Sun Apr 17 18:05:21 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7876" docExpressionCount="835" docLength="8974" length="1" offset="4031" starttimestamp="1650226882502" timestamp="6239478">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="2214" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 18:05:16 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="6233994" />
  <Command __id="2216" _type="InsertStringCommand" date="Sun Apr 17 18:05:16 EDT 2022" starttimestamp="1650226882502" timestamp="6234010" timestamp2="6234010">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2217" _type="InsertStringCommand" date="Sun Apr 17 18:05:16 EDT 2022" starttimestamp="1650226882502" timestamp="6234010" timestamp2="6234010">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2218" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6234511" />
  <Command __id="2219" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6234511" />
  <Command __id="2221" _type="InsertStringCommand" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6234950" timestamp2="6234950">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2222" _type="InsertStringCommand" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6234950" timestamp2="6234950">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2224" _type="InsertStringCommand" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6235191" timestamp2="6235191">
    <data><![CDATA[{]]></data>
  </Command>
  <Command __id="2225" _type="InsertStringCommand" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6235191" timestamp2="6235191">
    <data><![CDATA[{]]></data>
  </Command>
  <Command __id="2227" _type="InsertStringCommand" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6235323" timestamp2="6235323">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2228" _type="InsertStringCommand" date="Sun Apr 17 18:05:17 EDT 2022" starttimestamp="1650226882502" timestamp="6235323" timestamp2="6235323">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2230" _type="InsertStringCommand" date="Sun Apr 17 18:05:20 EDT 2022" starttimestamp="1650226882502" timestamp="6237632" timestamp2="6237632">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="2231" _type="InsertStringCommand" date="Sun Apr 17 18:05:20 EDT 2022" starttimestamp="1650226882502" timestamp="6237632" timestamp2="6237632">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="2233" _type="InsertStringCommand" date="Sun Apr 17 18:05:20 EDT 2022" starttimestamp="1650226882502" timestamp="6237729" timestamp2="6237729">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2234" _type="InsertStringCommand" date="Sun Apr 17 18:05:20 EDT 2022" starttimestamp="1650226882502" timestamp="6237729" timestamp2="6237729">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2236" _type="InsertStringCommand" date="Sun Apr 17 18:05:21 EDT 2022" starttimestamp="1650226882502" timestamp="6239478" timestamp2="6239478">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2237" _type="InsertStringCommand" date="Sun Apr 17 18:05:21 EDT 2022" starttimestamp="1650226882502" timestamp="6239478" timestamp2="6239478">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2238" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sun Apr 17 18:05:21 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="6239478" />
  <DocumentChange __id="2239" _type="Insert" date="Sun Apr 17 18:05:24 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7877" docExpressionCount="836" docLength="8975" length="1" offset="4032" starttimestamp="1650226882502" timestamp="6242219">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="2240" _type="Insert" date="Sun Apr 17 18:05:25 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7878" docExpressionCount="836" docLength="8976" length="1" offset="4033" starttimestamp="1650226882502" timestamp="6242997">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="2241" _type="Delete" date="Sun Apr 17 18:05:25 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7877" docExpressionCount="836" docLength="8975" endLine="104" length="1" offset="4033" startLine="104" starttimestamp="1650226882502" timestamp="6243419">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="2242" _type="Delete" date="Sun Apr 17 18:05:26 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7876" docExpressionCount="835" docLength="8974" endLine="104" length="1" offset="4032" startLine="104" starttimestamp="1650226882502" timestamp="6243634">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="2243" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sun Apr 17 18:06:06 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="6284416" />
  <Command __id="2244" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:06:20 EDT 2022" docASTNodeCount="55" docActiveCodeLength="298" docExpressionCount="29" docLength="395" projectName="pa3" starttimestamp="1650226882502" timestamp="6297602">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\BooleanLiteral.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.Token;

public class BooleanLiteral extends Terminal {

  public BooleanLiteral(Token t) {
    super (t);
  }
 
  public <A,R> R visit(Visitor<A,R> v, A o) {
      return v.visitBooleanLiteral(this, o);
  }
}
]]></snapshot>
  </Command>
  <Command __id="2245" _type="SelectTextCommand" caretOffset="154" date="Sun Apr 17 18:06:20 EDT 2022" end="154" start="140" starttimestamp="1650226882502" timestamp="6297702" />
  <Command __id="2247" _type="MoveCaretCommand" caretOffset="4032" date="Sun Apr 17 18:06:33 EDT 2022" docOffset="4032" starttimestamp="1650226882502" timestamp="6311353" />
  <Command __id="2248" _type="ShellCommand" date="Sun Apr 17 18:06:45 EDT 2022" starttimestamp="1650226882502" timestamp="6323234" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2246" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:06:33 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7876" docExpressionCount="835" docLength="8974" projectName="pa3" starttimestamp="1650226882502" timestamp="6311254">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			"), Diff(INSERT,"for (FieldDecl fd: cd.fieldDeclList) {¶				fd.¶			}¶			"), Diff(EQUAL,"table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		// scope 1
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enter(cd1);
		table.enter(cd2);
		table.enter(cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			for (FieldDecl fd: cd.fieldDeclList) {
				fd.
			}
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="2249" _type="ShellCommand" date="Sun Apr 17 18:06:59 EDT 2022" starttimestamp="1650226882502" timestamp="6337024" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2250" _type="SelectTextCommand" caretOffset="3985" date="Sun Apr 17 18:07:00 EDT 2022" end="4038" start="3985" starttimestamp="1650226882502" timestamp="6337906" />
  <Command __id="2251" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 18:07:01 EDT 2022" starttimestamp="1650226882502" timestamp="6338606" />
  <Command __id="2252" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 18:07:01 EDT 2022" starttimestamp="1650226882502" timestamp="6339092" />
  <Command __id="2253" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 18:07:01 EDT 2022" starttimestamp="1650226882502" timestamp="6339346" />
  <Command __id="2254" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 18:07:02 EDT 2022" starttimestamp="1650226882502" timestamp="6339662" />
  <Command __id="2255" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Apr 17 18:07:02 EDT 2022" starttimestamp="1650226882502" timestamp="6340024" />
  <Command __id="2256" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:10:50 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="6567942">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2257" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 18:10:50 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="6568004" />
  <Command __id="2258" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:11:02 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" projectName="pa3" starttimestamp="1650226882502" timestamp="6580173">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			"), Diff(DELETE,"for (FieldDecl fd: cd.fieldDeclList) {¶				fd.¶			}¶			"), Diff(EQUAL,"table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		// scope 1
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enter(cd1);
		table.enter(cd2);
		table.enter(cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="2259" _type="MoveCaretCommand" caretOffset="3980" date="Sun Apr 17 18:11:02 EDT 2022" docOffset="3980" starttimestamp="1650226882502" timestamp="6580243" />
  <Command __id="2260" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:11:07 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="6584950">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2261" _type="MoveCaretCommand" caretOffset="67" date="Sun Apr 17 18:11:07 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="6585005" />
  <Command __id="2263" _type="MoveCaretCommand" caretOffset="3980" date="Sun Apr 17 18:11:20 EDT 2022" docOffset="3980" starttimestamp="1650226882502" timestamp="6598231" />
  <Command __id="2264" _type="ShellCommand" date="Sun Apr 17 18:11:29 EDT 2022" starttimestamp="1650226882502" timestamp="6606512" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2265" _type="ShellCommand" date="Sun Apr 17 21:14:20 EDT 2022" starttimestamp="1650226882502" timestamp="17578038" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2266" _type="MoveCaretCommand" caretOffset="4054" date="Sun Apr 17 21:14:20 EDT 2022" docOffset="4054" starttimestamp="1650226882502" timestamp="17578096" />
  <Command __id="2267" _type="MoveCaretCommand" caretOffset="4054" date="Sun Apr 17 21:14:20 EDT 2022" docOffset="4054" starttimestamp="1650226882502" timestamp="17578096" />
  <Command __id="2268" _type="ShellCommand" date="Sun Apr 17 21:25:24 EDT 2022" starttimestamp="1650226882502" timestamp="18242439" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2269" _type="ShellCommand" date="Mon Apr 18 00:34:19 EDT 2022" starttimestamp="1650226882502" timestamp="29577395" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2270" _type="MoveCaretCommand" caretOffset="4085" date="Mon Apr 18 00:34:19 EDT 2022" docOffset="4085" starttimestamp="1650226882502" timestamp="29577461" />
  <Command __id="2271" _type="MoveCaretCommand" caretOffset="4085" date="Mon Apr 18 00:34:19 EDT 2022" docOffset="4085" starttimestamp="1650226882502" timestamp="29577461" />
  <Command __id="2272" _type="MoveCaretCommand" caretOffset="4054" date="Mon Apr 18 00:34:20 EDT 2022" docOffset="4054" starttimestamp="1650226882502" timestamp="29577833" />
  <Command __id="2273" _type="MoveCaretCommand" caretOffset="4054" date="Mon Apr 18 00:34:20 EDT 2022" docOffset="4054" starttimestamp="1650226882502" timestamp="29577836" />
  <Command __id="2274" _type="MoveCaretCommand" caretOffset="4080" date="Mon Apr 18 00:34:20 EDT 2022" docOffset="4080" starttimestamp="1650226882502" timestamp="29578218" />
  <Command __id="2275" _type="MoveCaretCommand" caretOffset="4080" date="Mon Apr 18 00:34:20 EDT 2022" docOffset="4080" starttimestamp="1650226882502" timestamp="29578228" />
  <Command __id="2276" _type="ShellCommand" date="Mon Apr 18 00:35:24 EDT 2022" starttimestamp="1650226882502" timestamp="29641775" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2277" _type="ShellCommand" date="Mon Apr 18 04:38:14 EDT 2022" starttimestamp="1650226882502" timestamp="44212468" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2278" _type="ShellCommand" date="Mon Apr 18 04:38:16 EDT 2022" starttimestamp="1650226882502" timestamp="44213620" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2262" _type="DiffBasedFileOpenCommand" date="Sun Apr 17 18:11:20 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" projectName="pa3" starttimestamp="1650226882502" timestamp="6598165">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="2279" _type="ShellCommand" date="Mon Apr 18 20:59:23 EDT 2022" starttimestamp="1650226882502" timestamp="103080544" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2281" _type="MoveCaretCommand" caretOffset="550" date="Mon Apr 18 20:59:24 EDT 2022" docOffset="607" starttimestamp="1650226882502" timestamp="103081768" />
  <Command __id="2282" _type="ShellCommand" date="Mon Apr 18 20:59:29 EDT 2022" starttimestamp="1650226882502" timestamp="103087236" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2283" _type="ShellCommand" date="Mon Apr 18 21:02:04 EDT 2022" starttimestamp="1650226882502" timestamp="103241918" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2285" _type="MoveCaretCommand" caretOffset="67" date="Mon Apr 18 21:02:04 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="103242133" />
  <Command __id="2286" _type="ShellCommand" date="Mon Apr 18 21:03:12 EDT 2022" starttimestamp="1650226882502" timestamp="103310473" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="2287" _type="ShellCommand" date="Mon Apr 18 21:04:47 EDT 2022" starttimestamp="1650226882502" timestamp="103405092" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2289" _type="SelectTextCommand" caretOffset="150" date="Mon Apr 18 21:04:47 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="103405236" />
  <Command __id="2291" _type="MoveCaretCommand" caretOffset="4080" date="Mon Apr 18 21:04:48 EDT 2022" docOffset="4080" starttimestamp="1650226882502" timestamp="103406222" />
  <Command __id="2280" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 20:59:24 EDT 2022" docASTNodeCount="89" docActiveCodeLength="510" docExpressionCount="47" docLength="607" projectName="pa3" starttimestamp="1650226882502" timestamp="103081619">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\ClassDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import  miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class ClassDecl extends Declaration {¶¶  public ClassDecl(String cn, FieldDeclList fdl, MethodDeclList mdl, SourcePosition posn) {¶	  super(cn, null, posn);¶	  fieldDeclList = fdl;¶	  methodDeclList = mdl;¶  }¶  ¶  public <A,R> R visit(Visitor<A, R> v, A o) {¶      return v.visitClassDecl(this, o);¶  }¶      ¶  public FieldDeclList fieldDeclList;¶  public MethodDeclList methodDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2284" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:02:04 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="103242040">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2288" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:04:47 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="103405185">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2290" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:04:48 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" projectName="pa3" starttimestamp="1650226882502" timestamp="103406168">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="2292" _type="MoveCaretCommand" caretOffset="4064" date="Mon Apr 18 21:04:49 EDT 2022" docOffset="4064" starttimestamp="1650226882502" timestamp="103407272" />
  <Command __id="2293" _type="MoveCaretCommand" caretOffset="4064" date="Mon Apr 18 21:04:49 EDT 2022" docOffset="4064" starttimestamp="1650226882502" timestamp="103407272" />
  <Command __id="2294" _type="MoveCaretCommand" caretOffset="4037" date="Mon Apr 18 21:04:50 EDT 2022" docOffset="4037" starttimestamp="1650226882502" timestamp="103407680" />
  <Command __id="2295" _type="MoveCaretCommand" caretOffset="4037" date="Mon Apr 18 21:04:50 EDT 2022" docOffset="4037" starttimestamp="1650226882502" timestamp="103407680" />
  <Command __id="2296" _type="MoveCaretCommand" caretOffset="4072" date="Mon Apr 18 21:04:50 EDT 2022" docOffset="4072" starttimestamp="1650226882502" timestamp="103408489" />
  <Command __id="2297" _type="MoveCaretCommand" caretOffset="4072" date="Mon Apr 18 21:04:50 EDT 2022" docOffset="4072" starttimestamp="1650226882502" timestamp="103408496" />
  <Command __id="2298" _type="MoveCaretCommand" caretOffset="4085" date="Mon Apr 18 21:04:51 EDT 2022" docOffset="4085" starttimestamp="1650226882502" timestamp="103408906" />
  <Command __id="2299" _type="MoveCaretCommand" caretOffset="4085" date="Mon Apr 18 21:04:51 EDT 2022" docOffset="4085" starttimestamp="1650226882502" timestamp="103408912" />
  <Command __id="2300" _type="MoveCaretCommand" caretOffset="4033" date="Mon Apr 18 21:04:51 EDT 2022" docOffset="4033" starttimestamp="1650226882502" timestamp="103409390" />
  <Command __id="2301" _type="MoveCaretCommand" caretOffset="4033" date="Mon Apr 18 21:04:51 EDT 2022" docOffset="4033" starttimestamp="1650226882502" timestamp="103409400" />
  <Command __id="2302" _type="MoveCaretCommand" caretOffset="4054" date="Mon Apr 18 21:04:52 EDT 2022" docOffset="4054" starttimestamp="1650226882502" timestamp="103410129" />
  <Command __id="2303" _type="MoveCaretCommand" caretOffset="4054" date="Mon Apr 18 21:04:52 EDT 2022" docOffset="4054" starttimestamp="1650226882502" timestamp="103410144" />
  <DocumentChange __id="2304" _type="Insert" date="Mon Apr 18 21:04:53 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7823" docExpressionCount="828" docLength="8921" length="5" offset="4054" starttimestamp="1650226882502" timestamp="103411410">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="2305" _type="InsertStringCommand" date="Mon Apr 18 21:04:53 EDT 2022" starttimestamp="1650226882502" timestamp="103411425" timestamp2="103411425">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2306" _type="InsertStringCommand" date="Mon Apr 18 21:04:53 EDT 2022" starttimestamp="1650226882502" timestamp="103411425" timestamp2="103411425">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="2307" _type="Insert" date="Mon Apr 18 21:04:58 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7824" docExpressionCount="828" docLength="8922" length="1" offset="4059" starttimestamp="1650226882502" timestamp="103415801">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="2308" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103415801" timestamp2="103415801">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2309" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103415801" timestamp2="103415801">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="2310" _type="Insert" date="Mon Apr 18 21:04:58 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7825" docExpressionCount="828" docLength="8923" length="1" offset="4060" starttimestamp="1650226882502" timestamp="103415932">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="2311" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103415939" timestamp2="103415939">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2312" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103415939" timestamp2="103415939">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="2313" _type="Insert" date="Mon Apr 18 21:04:58 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8924" length="1" offset="4061" starttimestamp="1650226882502" timestamp="103416333">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <Command __id="2314" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103416333" timestamp2="103416333">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="2315" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103416333" timestamp2="103416333">
    <data><![CDATA[b]]></data>
  </Command>
  <DocumentChange __id="2316" _type="Insert" date="Mon Apr 18 21:04:58 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7827" docExpressionCount="828" docLength="8925" length="1" offset="4062" starttimestamp="1650226882502" timestamp="103416471">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2317" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103416471" timestamp2="103416471">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2318" _type="InsertStringCommand" date="Mon Apr 18 21:04:58 EDT 2022" starttimestamp="1650226882502" timestamp="103416471" timestamp2="103416471">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="2319" _type="Insert" date="Mon Apr 18 21:04:59 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7828" docExpressionCount="828" docLength="8926" length="1" offset="4063" starttimestamp="1650226882502" timestamp="103416587">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2320" _type="InsertStringCommand" date="Mon Apr 18 21:04:59 EDT 2022" starttimestamp="1650226882502" timestamp="103416587" timestamp2="103416587">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2321" _type="InsertStringCommand" date="Mon Apr 18 21:04:59 EDT 2022" starttimestamp="1650226882502" timestamp="103416587" timestamp2="103416587">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2322" _type="Insert" date="Mon Apr 18 21:04:59 EDT 2022" docASTNodeCount="1335" docActiveCodeLength="7829" docExpressionCount="830" docLength="8927" length="1" offset="4064" starttimestamp="1650226882502" timestamp="103416922">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <Command __id="2323" _type="InsertStringCommand" date="Mon Apr 18 21:04:59 EDT 2022" starttimestamp="1650226882502" timestamp="103416924" timestamp2="103416924">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="2324" _type="InsertStringCommand" date="Mon Apr 18 21:04:59 EDT 2022" starttimestamp="1650226882502" timestamp="103416924" timestamp2="103416924">
    <data><![CDATA[,]]></data>
  </Command>
  <DocumentChange __id="2325" _type="Delete" date="Mon Apr 18 21:04:59 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7828" docExpressionCount="828" docLength="8926" endLine="107" length="1" offset="4064" startLine="107" starttimestamp="1650226882502" timestamp="103417387">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <Command __id="2326" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:04:59 EDT 2022" starttimestamp="1650226882502" timestamp="103417387" />
  <Command __id="2327" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:04:59 EDT 2022" starttimestamp="1650226882502" timestamp="103417387" />
  <DocumentChange __id="2328" _type="Insert" date="Mon Apr 18 21:05:00 EDT 2022" docASTNodeCount="1335" docActiveCodeLength="7829" docExpressionCount="830" docLength="8927" length="1" offset="4064" starttimestamp="1650226882502" timestamp="103418072">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="2329" _type="InsertStringCommand" date="Mon Apr 18 21:05:00 EDT 2022" starttimestamp="1650226882502" timestamp="103418088" timestamp2="103418088">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2330" _type="InsertStringCommand" date="Mon Apr 18 21:05:00 EDT 2022" starttimestamp="1650226882502" timestamp="103418088" timestamp2="103418088">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2331" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Mon Apr 18 21:05:00 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="103418088" />
  <DocumentChange __id="2332" _type="Insert" date="Mon Apr 18 21:05:00 EDT 2022" docASTNodeCount="1339" docActiveCodeLength="7830" docExpressionCount="831" docLength="8928" length="1" offset="4065" starttimestamp="1650226882502" timestamp="103418373">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="2333" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Mon Apr 18 21:05:01 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="103418957" />
  <DocumentChange __id="2334" _type="Replace" date="Mon Apr 18 21:05:01 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7841" docExpressionCount="831" docLength="8939" endLine="107" insertionLength="12" int_docASTNodeCount="1335" int_docActiveCodeLength="7829" int_docExpressionCount="830" int_docLength="8927" length="1" offset="4065" startLine="107" starttimestamp="1650226882502" timestamp="103419004">
    <deletedText><![CDATA[o]]></deletedText>
    <insertedText><![CDATA[openScope();]]></insertedText>
  </DocumentChange>
  <Command __id="2335" _type="InsertStringCommand" date="Mon Apr 18 21:05:01 EDT 2022" starttimestamp="1650226882502" timestamp="103419089" timestamp2="103419089">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2336" _type="InsertStringCommand" date="Mon Apr 18 21:05:01 EDT 2022" starttimestamp="1650226882502" timestamp="103419089" timestamp2="103419089">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="2337" _type="Insert" date="Mon Apr 18 21:05:02 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7846" docExpressionCount="831" docLength="8944" length="5" offset="4077" starttimestamp="1650226882502" timestamp="103420405">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="2338" _type="InsertStringCommand" date="Mon Apr 18 21:05:02 EDT 2022" starttimestamp="1650226882502" timestamp="103420405" timestamp2="103420405">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2339" _type="InsertStringCommand" date="Mon Apr 18 21:05:02 EDT 2022" starttimestamp="1650226882502" timestamp="103420405" timestamp2="103420405">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="2340" _type="Insert" date="Mon Apr 18 21:05:03 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7847" docExpressionCount="831" docLength="8945" length="1" offset="4082" starttimestamp="1650226882502" timestamp="103420974">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="2341" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103420974" timestamp2="103420974">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2342" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103420974" timestamp2="103420974">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="2343" _type="Insert" date="Mon Apr 18 21:05:03 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7848" docExpressionCount="831" docLength="8946" length="1" offset="4083" starttimestamp="1650226882502" timestamp="103421106">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="2344" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103421106" timestamp2="103421106">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2345" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103421106" timestamp2="103421106">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="2346" _type="Insert" date="Mon Apr 18 21:05:03 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7849" docExpressionCount="831" docLength="8947" length="1" offset="4084" starttimestamp="1650226882502" timestamp="103421390">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <Command __id="2347" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103421390" timestamp2="103421390">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="2348" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103421390" timestamp2="103421390">
    <data><![CDATA[b]]></data>
  </Command>
  <DocumentChange __id="2349" _type="Insert" date="Mon Apr 18 21:05:03 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7850" docExpressionCount="831" docLength="8948" length="1" offset="4085" starttimestamp="1650226882502" timestamp="103421406">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="2350" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103421406" timestamp2="103421406">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="2351" _type="InsertStringCommand" date="Mon Apr 18 21:05:03 EDT 2022" starttimestamp="1650226882502" timestamp="103421406" timestamp2="103421406">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="2352" _type="Delete" date="Mon Apr 18 21:05:04 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7849" docExpressionCount="831" docLength="8947" endLine="108" length="1" offset="4085" startLine="108" starttimestamp="1650226882502" timestamp="103421849">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="2353" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="103421851" />
  <Command __id="2354" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:05:04 EDT 2022" starttimestamp="1650226882502" timestamp="103421851" />
  <DocumentChange __id="2355" _type="Insert" date="Mon Apr 18 21:05:05 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7850" docExpressionCount="831" docLength="8948" length="1" offset="4085" starttimestamp="1650226882502" timestamp="103423077">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2356" _type="InsertStringCommand" date="Mon Apr 18 21:05:05 EDT 2022" starttimestamp="1650226882502" timestamp="103423077" timestamp2="103423077">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2357" _type="InsertStringCommand" date="Mon Apr 18 21:05:05 EDT 2022" starttimestamp="1650226882502" timestamp="103423077" timestamp2="103423077">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="2358" _type="Insert" date="Mon Apr 18 21:05:05 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7851" docExpressionCount="831" docLength="8949" length="1" offset="4086" starttimestamp="1650226882502" timestamp="103423208">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2359" _type="InsertStringCommand" date="Mon Apr 18 21:05:05 EDT 2022" starttimestamp="1650226882502" timestamp="103423208" timestamp2="103423208">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2360" _type="InsertStringCommand" date="Mon Apr 18 21:05:05 EDT 2022" starttimestamp="1650226882502" timestamp="103423208" timestamp2="103423208">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2361" _type="Insert" date="Mon Apr 18 21:05:06 EDT 2022" docASTNodeCount="1339" docActiveCodeLength="7852" docExpressionCount="833" docLength="8950" length="1" offset="4087" starttimestamp="1650226882502" timestamp="103424341">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="2362" _type="InsertStringCommand" date="Mon Apr 18 21:05:06 EDT 2022" starttimestamp="1650226882502" timestamp="103424341" timestamp2="103424341">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2363" _type="InsertStringCommand" date="Mon Apr 18 21:05:06 EDT 2022" starttimestamp="1650226882502" timestamp="103424341" timestamp2="103424341">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2364" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Mon Apr 18 21:05:06 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="103424341" />
  <DocumentChange __id="2365" _type="Insert" date="Mon Apr 18 21:05:06 EDT 2022" docASTNodeCount="1343" docActiveCodeLength="7853" docExpressionCount="834" docLength="8951" length="1" offset="4088" starttimestamp="1650226882502" timestamp="103424463">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2366" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Mon Apr 18 21:05:07 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="103425034" />
  <DocumentChange __id="2367" _type="Replace" date="Mon Apr 18 21:05:07 EDT 2022" docASTNodeCount="1342" docActiveCodeLength="7864" docExpressionCount="835" docLength="8962" endLine="108" insertionLength="12" int_docASTNodeCount="1339" int_docActiveCodeLength="7852" int_docExpressionCount="833" int_docLength="8950" length="1" offset="4088" startLine="108" starttimestamp="1650226882502" timestamp="103425044">
    <deletedText><![CDATA[e]]></deletedText>
    <insertedText><![CDATA[enter(decl);]]></insertedText>
  </DocumentChange>
  <Command __id="2368" _type="InsertStringCommand" date="Mon Apr 18 21:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="103425191" timestamp2="103425191">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2369" _type="InsertStringCommand" date="Mon Apr 18 21:05:07 EDT 2022" starttimestamp="1650226882502" timestamp="103425191" timestamp2="103425191">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="2370" _type="Replace" date="Mon Apr 18 21:05:09 EDT 2022" docASTNodeCount="1342" docActiveCodeLength="7861" docExpressionCount="835" docLength="8959" endLine="108" insertionLength="1" int_docASTNodeCount="1341" int_docActiveCodeLength="7860" int_docExpressionCount="834" int_docLength="8958" length="4" offset="4094" startLine="108" starttimestamp="1650226882502" timestamp="103427179">
    <deletedText><![CDATA[decl]]></deletedText>
    <insertedText><![CDATA[c]]></insertedText>
  </DocumentChange>
  <Command __id="2371" _type="InsertStringCommand" date="Mon Apr 18 21:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="103427179" timestamp2="103427179">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="2372" _type="InsertStringCommand" date="Mon Apr 18 21:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="103427179" timestamp2="103427179">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="2374" _type="InsertStringCommand" date="Mon Apr 18 21:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="103427410" timestamp2="103427410">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2375" _type="InsertStringCommand" date="Mon Apr 18 21:05:09 EDT 2022" starttimestamp="1650226882502" timestamp="103427410" timestamp2="103427410">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2376" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:05:12 EDT 2022" starttimestamp="1650226882502" timestamp="103429544" />
  <Command __id="2377" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:05:12 EDT 2022" starttimestamp="1650226882502" timestamp="103429544" />
  <Command __id="2378" _type="MoveCaretCommand" caretOffset="4098" date="Mon Apr 18 21:05:21 EDT 2022" docOffset="4098" starttimestamp="1650226882502" timestamp="103439312" />
  <Command __id="2379" _type="MoveCaretCommand" caretOffset="4098" date="Mon Apr 18 21:05:21 EDT 2022" docOffset="4098" starttimestamp="1650226882502" timestamp="103439320" />
  <Command __id="2380" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:05:29 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="103446675" />
  <Command __id="2381" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:05:29 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="103446680" />
  <Command __id="2383" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103447653" timestamp2="103447653">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2384" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103447653" timestamp2="103447653">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2386" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103448075" timestamp2="103448075">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2387" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103448075" timestamp2="103448075">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2389" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103448207" timestamp2="103448207">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2390" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103448207" timestamp2="103448207">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2392" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103448407" timestamp2="103448407">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="2393" _type="InsertStringCommand" date="Mon Apr 18 21:05:30 EDT 2022" starttimestamp="1650226882502" timestamp="103448407" timestamp2="103448407">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="2395" _type="InsertStringCommand" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103448677" timestamp2="103448677">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="2396" _type="InsertStringCommand" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103448677" timestamp2="103448677">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="2398" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103449109" />
  <Command __id="2399" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103449109" />
  <Command __id="2401" _type="InsertStringCommand" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103449371" timestamp2="103449371">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2402" _type="InsertStringCommand" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103449371" timestamp2="103449371">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2404" _type="InsertStringCommand" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103449478" timestamp2="103449478">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2405" _type="InsertStringCommand" date="Mon Apr 18 21:05:31 EDT 2022" starttimestamp="1650226882502" timestamp="103449478" timestamp2="103449478">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2407" _type="InsertStringCommand" date="Mon Apr 18 21:05:32 EDT 2022" starttimestamp="1650226882502" timestamp="103449678" timestamp2="103449678">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2408" _type="InsertStringCommand" date="Mon Apr 18 21:05:32 EDT 2022" starttimestamp="1650226882502" timestamp="103449678" timestamp2="103449678">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="2409" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Mon Apr 18 21:05:32 EDT 2022" start_end="START" starttimestamp="1650226882502" timestamp="103449694" />
  <Command __id="2411" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Mon Apr 18 21:05:32 EDT 2022" start_end="END" starttimestamp="1650226882502" timestamp="103450472" />
  <Command __id="2413" _type="InsertStringCommand" date="Mon Apr 18 21:05:32 EDT 2022" starttimestamp="1650226882502" timestamp="103450479" timestamp2="103450479">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2414" _type="InsertStringCommand" date="Mon Apr 18 21:05:32 EDT 2022" starttimestamp="1650226882502" timestamp="103450479" timestamp2="103450479">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2415" _type="MoveCaretCommand" caretOffset="4145" date="Mon Apr 18 21:06:56 EDT 2022" docOffset="4145" starttimestamp="1650226882502" timestamp="103533506" />
  <Command __id="2416" _type="MoveCaretCommand" caretOffset="4145" date="Mon Apr 18 21:06:56 EDT 2022" docOffset="4145" starttimestamp="1650226882502" timestamp="103533513" />
  <Command __id="2417" _type="MoveCaretCommand" caretOffset="4176" date="Mon Apr 18 21:06:56 EDT 2022" docOffset="4176" starttimestamp="1650226882502" timestamp="103533928" />
  <Command __id="2418" _type="MoveCaretCommand" caretOffset="4176" date="Mon Apr 18 21:06:56 EDT 2022" docOffset="4176" starttimestamp="1650226882502" timestamp="103533928" />
  <Command __id="2419" _type="MoveCaretCommand" caretOffset="4153" date="Mon Apr 18 21:06:57 EDT 2022" docOffset="4153" starttimestamp="1650226882502" timestamp="103534525" />
  <Command __id="2420" _type="MoveCaretCommand" caretOffset="4153" date="Mon Apr 18 21:06:57 EDT 2022" docOffset="4153" starttimestamp="1650226882502" timestamp="103534536" />
  <Command __id="2421" _type="MoveCaretCommand" caretOffset="4176" date="Mon Apr 18 21:06:57 EDT 2022" docOffset="4176" starttimestamp="1650226882502" timestamp="103535456" />
  <Command __id="2422" _type="MoveCaretCommand" caretOffset="4176" date="Mon Apr 18 21:06:57 EDT 2022" docOffset="4176" starttimestamp="1650226882502" timestamp="103535464" />
  <Command __id="2423" _type="ShellCommand" date="Mon Apr 18 21:08:03 EDT 2022" starttimestamp="1650226882502" timestamp="103601469" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="2373" _type="Insert" date="Mon Apr 18 21:05:09 EDT 2022" docASTNodeCount="1342" docActiveCodeLength="7862" docExpressionCount="835" docLength="8960" length="1" offset="4095" starttimestamp="1650226882502" timestamp="103427410">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="2382" _type="Insert" date="Mon Apr 18 21:05:30 EDT 2022" docASTNodeCount="1342" docActiveCodeLength="7867" docExpressionCount="835" docLength="8965" length="5" offset="4124" starttimestamp="1650226882502" timestamp="103447653">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <DocumentChange __id="2385" _type="Insert" date="Mon Apr 18 21:05:30 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7868" docExpressionCount="836" docLength="8966" length="1" offset="4129" starttimestamp="1650226882502" timestamp="103448075">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="2388" _type="Insert" date="Mon Apr 18 21:05:30 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7869" docExpressionCount="836" docLength="8967" length="1" offset="4130" starttimestamp="1650226882502" timestamp="103448191">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="2391" _type="Insert" date="Mon Apr 18 21:05:30 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7870" docExpressionCount="836" docLength="8968" length="1" offset="4131" starttimestamp="1650226882502" timestamp="103448407">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="2394" _type="Insert" date="Mon Apr 18 21:05:31 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7871" docExpressionCount="836" docLength="8969" length="1" offset="4132" starttimestamp="1650226882502" timestamp="103448677">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <DocumentChange __id="2397" _type="Delete" date="Mon Apr 18 21:05:31 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7870" docExpressionCount="836" docLength="8968" endLine="110" length="1" offset="4132" startLine="110" starttimestamp="1650226882502" timestamp="103449109">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <DocumentChange __id="2400" _type="Insert" date="Mon Apr 18 21:05:31 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7871" docExpressionCount="836" docLength="8969" length="1" offset="4132" starttimestamp="1650226882502" timestamp="103449371">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="2403" _type="Insert" date="Mon Apr 18 21:05:31 EDT 2022" docASTNodeCount="1344" docActiveCodeLength="7872" docExpressionCount="836" docLength="8970" length="1" offset="4133" starttimestamp="1650226882502" timestamp="103449478">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2406" _type="Insert" date="Mon Apr 18 21:05:32 EDT 2022" docASTNodeCount="1342" docActiveCodeLength="7873" docExpressionCount="835" docLength="8971" length="1" offset="4134" starttimestamp="1650226882502" timestamp="103449678">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="2410" _type="Insert" date="Mon Apr 18 21:05:32 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7874" docExpressionCount="838" docLength="8972" length="1" offset="4135" starttimestamp="1650226882502" timestamp="103450025">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="2412" _type="Replace" date="Mon Apr 18 21:05:32 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7886" docExpressionCount="838" docLength="8984" endLine="110" insertionLength="13" int_docASTNodeCount="1342" int_docActiveCodeLength="7873" int_docExpressionCount="835" int_docLength="8971" length="1" offset="4135" startLine="110" starttimestamp="1650226882502" timestamp="103450472">
    <deletedText><![CDATA[c]]></deletedText>
    <insertedText><![CDATA[closeScope();]]></insertedText>
  </DocumentChange>
  <Command __id="2424" _type="ShellCommand" date="Mon Apr 18 21:19:00 EDT 2022" starttimestamp="1650226882502" timestamp="104257504" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="2425" _type="MoveCaretCommand" caretOffset="4098" date="Mon Apr 18 21:19:00 EDT 2022" docOffset="4098" starttimestamp="1650226882502" timestamp="104257584" />
  <Command __id="2426" _type="MoveCaretCommand" caretOffset="4098" date="Mon Apr 18 21:19:00 EDT 2022" docOffset="4098" starttimestamp="1650226882502" timestamp="104257584" />
  <Command __id="2427" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:19:03 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="104261109">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2428" _type="MoveCaretCommand" caretOffset="67" date="Mon Apr 18 21:19:03 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="104261171" />
  <Command __id="2430" _type="MoveCaretCommand" caretOffset="4098" date="Mon Apr 18 21:19:06 EDT 2022" docOffset="4098" starttimestamp="1650226882502" timestamp="104264314" />
  <Command __id="2431" _type="MoveCaretCommand" caretOffset="4142" date="Mon Apr 18 21:19:24 EDT 2022" docOffset="4142" starttimestamp="1650226882502" timestamp="104281594" />
  <Command __id="2432" _type="MoveCaretCommand" caretOffset="4142" date="Mon Apr 18 21:19:24 EDT 2022" docOffset="4142" starttimestamp="1650226882502" timestamp="104281607" />
  <Command __id="2433" _type="MoveCaretCommand" caretOffset="4088" date="Mon Apr 18 21:19:24 EDT 2022" docOffset="4088" starttimestamp="1650226882502" timestamp="104281932" />
  <Command __id="2434" _type="MoveCaretCommand" caretOffset="4088" date="Mon Apr 18 21:19:24 EDT 2022" docOffset="4088" starttimestamp="1650226882502" timestamp="104281935" />
  <Command __id="2435" _type="MoveCaretCommand" caretOffset="4107" date="Mon Apr 18 21:19:24 EDT 2022" docOffset="4107" starttimestamp="1650226882502" timestamp="104282263" />
  <Command __id="2436" _type="MoveCaretCommand" caretOffset="4107" date="Mon Apr 18 21:19:24 EDT 2022" docOffset="4107" starttimestamp="1650226882502" timestamp="104282279" />
  <Command __id="2429" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:19:06 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7886" docExpressionCount="838" docLength="8984" projectName="pa3" starttimestamp="1650226882502" timestamp="104264263">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			"), Diff(DELETE,"cd.visit(this, null"), Diff(INSERT,"table.openScope();¶			table.enter(cd);¶			cd.visit(this, null);¶			table.closeScope("), Diff(EQUAL,");¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		// scope 1
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enter(cd1);
		table.enter(cd2);
		table.enter(cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			table.openScope();
			table.enter(cd);
			cd.visit(this, null);
			table.closeScope();
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="2437" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:26 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104283634" />
  <Command __id="2438" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:26 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104283634" />
  <Command __id="2439" _type="MoveCaretCommand" caretOffset="4119" date="Mon Apr 18 21:19:26 EDT 2022" docOffset="4119" starttimestamp="1650226882502" timestamp="104283981" />
  <Command __id="2440" _type="MoveCaretCommand" caretOffset="4119" date="Mon Apr 18 21:19:26 EDT 2022" docOffset="4119" starttimestamp="1650226882502" timestamp="104283991" />
  <Command __id="2441" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:26 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104284266" />
  <Command __id="2442" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:26 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104284271" />
  <Command __id="2443" _type="MoveCaretCommand" caretOffset="4118" date="Mon Apr 18 21:19:27 EDT 2022" docOffset="4118" starttimestamp="1650226882502" timestamp="104284582" />
  <Command __id="2444" _type="MoveCaretCommand" caretOffset="4118" date="Mon Apr 18 21:19:27 EDT 2022" docOffset="4118" starttimestamp="1650226882502" timestamp="104284591" />
  <Command __id="2445" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:27 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104284882" />
  <Command __id="2446" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:27 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104284887" />
  <Command __id="2447" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:27 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104285235" />
  <Command __id="2448" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:19:27 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104285247" />
  <Command __id="2449" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:20:29 EDT 2022" docASTNodeCount="59" docActiveCodeLength="340" docExpressionCount="32" docLength="437" projectName="pa3" starttimestamp="1650226882502" timestamp="104347051">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Declaration.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

public abstract class Declaration extends AST {
	
	public Declaration(String name, TypeDenoter type, SourcePosition posn) {
		super(posn);
		this.name = name;
		this.type = type;
	}
	
	public String name;
	public TypeDenoter type;
}
]]></snapshot>
  </Command>
  <Command __id="2450" _type="SelectTextCommand" caretOffset="169" date="Mon Apr 18 21:20:29 EDT 2022" end="169" start="158" starttimestamp="1650226882502" timestamp="104347236" />
  <Command __id="2452" _type="SelectTextCommand" caretOffset="150" date="Mon Apr 18 21:20:59 EDT 2022" end="150" start="140" starttimestamp="1650226882502" timestamp="104377423" />
  <Command __id="2453" _type="MoveCaretCommand" caretOffset="199" date="Mon Apr 18 21:21:01 EDT 2022" docOffset="256" starttimestamp="1650226882502" timestamp="104378564" />
  <Command __id="2454" _type="MoveCaretCommand" caretOffset="199" date="Mon Apr 18 21:21:01 EDT 2022" docOffset="256" starttimestamp="1650226882502" timestamp="104378575" />
  <Command __id="2451" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:20:59 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="104377361">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2455" _type="SelectTextCommand" caretOffset="171" date="Mon Apr 18 21:21:02 EDT 2022" end="197" start="171" starttimestamp="1650226882502" timestamp="104380433" />
  <Command __id="2456" _type="SelectTextCommand" caretOffset="171" date="Mon Apr 18 21:21:02 EDT 2022" end="197" start="171" starttimestamp="1650226882502" timestamp="104380439" />
  <Command __id="2457" _type="CopyCommand" date="Mon Apr 18 21:21:03 EDT 2022" starttimestamp="1650226882502" timestamp="104380749" />
  <Command __id="2459" _type="SelectTextCommand" caretOffset="169" date="Mon Apr 18 21:21:26 EDT 2022" end="169" start="158" starttimestamp="1650226882502" timestamp="104404222" />
  <Command __id="2458" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:21:26 EDT 2022" docASTNodeCount="59" docActiveCodeLength="340" docExpressionCount="32" docLength="437" projectName="pa3" starttimestamp="1650226882502" timestamp="104404175">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Declaration.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public abstract class Declaration extends AST {¶	¶	public Declaration(String name, TypeDenoter type, SourcePosition posn) {¶		super(posn);¶		this.name = name;¶		this.type = type;¶	}¶	¶	public String name;¶	public TypeDenoter type;¶}¶")]]]></diff>
  </Command>
  <Command __id="2460" _type="MoveCaretCommand" caretOffset="186" date="Mon Apr 18 21:21:27 EDT 2022" docOffset="243" starttimestamp="1650226882502" timestamp="104405225" />
  <Command __id="2462" _type="PasteCommand" date="Mon Apr 18 21:21:30 EDT 2022" starttimestamp="1650226882502" timestamp="104408125" />
  <Command __id="2463" _type="MoveCaretCommand" caretOffset="188" date="Mon Apr 18 21:21:31 EDT 2022" docOffset="245" starttimestamp="1650226882502" timestamp="104409268" />
  <Command __id="2465" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:21:32 EDT 2022" starttimestamp="1650226882502" timestamp="104409964" />
  <Command __id="2467" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:21:33 EDT 2022" starttimestamp="1650226882502" timestamp="104410717" />
  <Command __id="2469" _type="InsertStringCommand" date="Mon Apr 18 21:21:33 EDT 2022" starttimestamp="1650226882502" timestamp="104410717" timestamp2="104410717">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="2471" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:21:33 EDT 2022" starttimestamp="1650226882502" timestamp="104411318" />
  <DocumentChange __id="2461" _type="Replace" date="Mon Apr 18 21:21:30 EDT 2022" docASTNodeCount="65" docActiveCodeLength="366" docExpressionCount="34" docLength="463" endLine="10" insertionLength="27" int_docASTNodeCount="59" int_docActiveCodeLength="339" int_docExpressionCount="32" int_docLength="436" length="1" offset="242" startLine="10" starttimestamp="1650226882502" timestamp="104407543">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[	  public Declaration decl;]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="2464" _type="Delete" date="Mon Apr 18 21:21:32 EDT 2022" docASTNodeCount="65" docActiveCodeLength="365" docExpressionCount="34" docLength="462" endLine="10" length="1" offset="244" startLine="10" starttimestamp="1650226882502" timestamp="104409964">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2466" _type="Delete" date="Mon Apr 18 21:21:33 EDT 2022" docASTNodeCount="65" docActiveCodeLength="364" docExpressionCount="34" docLength="461" endLine="10" length="1" offset="243" startLine="10" starttimestamp="1650226882502" timestamp="104410717">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2468" _type="Insert" date="Mon Apr 18 21:21:33 EDT 2022" docASTNodeCount="65" docActiveCodeLength="365" docExpressionCount="34" docLength="462" length="1" offset="243" starttimestamp="1650226882502" timestamp="104410717">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="2470" _type="Delete" date="Mon Apr 18 21:21:33 EDT 2022" docASTNodeCount="65" docActiveCodeLength="364" docExpressionCount="34" docLength="461" endLine="10" length="1" offset="243" startLine="10" starttimestamp="1650226882502" timestamp="104411318">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="2473" _type="Insert" date="Mon Apr 18 21:21:36 EDT 2022" docASTNodeCount="65" docActiveCodeLength="367" docExpressionCount="34" docLength="464" length="3" offset="270" starttimestamp="1650226882502" timestamp="104414090">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="2478" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:21:38 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7886" docExpressionCount="838" docLength="8984" projectName="pa3" starttimestamp="1650226882502" timestamp="104415720">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.openScope();¶			table.enter(cd);¶			cd.visit(this, null);¶			table.closeScope();¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="2472" _type="MoveCaretCommand" caretOffset="213" date="Mon Apr 18 21:21:35 EDT 2022" docOffset="270" starttimestamp="1650226882502" timestamp="104413451" />
  <Command __id="2474" _type="InsertStringCommand" date="Mon Apr 18 21:21:36 EDT 2022" starttimestamp="1650226882502" timestamp="104414090" timestamp2="104414090">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2475" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:21:37 EDT 2022" starttimestamp="1650226882502" timestamp="104414838" />
  <Command __id="2476" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Apr 18 21:21:37 EDT 2022" starttimestamp="1650226882502" timestamp="104414890" />
  <Command __id="2477" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:21:38 EDT 2022" starttimestamp="1650226882502" timestamp="104415671" />
  <Command __id="2479" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:21:38 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104415824" />
  <Command __id="2481" _type="SelectTextCommand" caretOffset="171" date="Mon Apr 18 21:21:40 EDT 2022" end="197" start="171" starttimestamp="1650226882502" timestamp="104417681" />
  <Command __id="2480" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:21:40 EDT 2022" docASTNodeCount="61" docActiveCodeLength="316" docExpressionCount="31" docLength="413" projectName="pa3" starttimestamp="1650226882502" timestamp="104417623">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Identifier.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.Token;¶¶public class Identifier extends Terminal {¶  public Declaration decl;¶¶  public Identifier (Token t) {¶    super (t);¶  }¶¶  public <A,R> R visit(Visitor<A,R> v, A o) {¶      return v.visitIdentifier(this, o);¶  }¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2482" _type="MoveCaretCommand" caretOffset="199" date="Mon Apr 18 21:21:41 EDT 2022" docOffset="256" starttimestamp="1650226882502" timestamp="104418945" />
  <Command __id="2483" _type="MoveCaretCommand" caretOffset="199" date="Mon Apr 18 21:21:41 EDT 2022" docOffset="256" starttimestamp="1650226882502" timestamp="104418959" />
  <Command __id="2484" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:21:42 EDT 2022" docASTNodeCount="65" docActiveCodeLength="367" docExpressionCount="34" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="104420367">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Declaration.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public abstract class Declaration extends AST {¶	"), Diff(INSERT,"public Declaration decl;¶	"), Diff(EQUAL,"¶	public Declaration(String name, TypeDenoter type, SourcePosition posn) {¶		super(posn);¶		this.name = name;¶		this.type = type;¶	}¶	¶	public String name;¶	public TypeDenoter type;¶}¶")]]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

public abstract class Declaration extends AST {
	public Declaration decl;
	
	public Declaration(String name, TypeDenoter type, SourcePosition posn) {
		super(posn);
		this.name = name;
		this.type = type;
	}
	
	public String name;
	public TypeDenoter type;
}
]]></snapshot>
  </Command>
  <Command __id="2485" _type="MoveCaretCommand" caretOffset="216" date="Mon Apr 18 21:21:42 EDT 2022" docOffset="273" starttimestamp="1650226882502" timestamp="104420433" />
  <Command __id="2486" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:21:49 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7886" docExpressionCount="838" docLength="8984" projectName="pa3" starttimestamp="1650226882502" timestamp="104427439">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.openScope();¶			table.enter(cd);¶			cd.visit(this, null);¶			table.closeScope();¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="2487" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:21:50 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104427573" />
  <Command __id="2488" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:21:54 EDT 2022" docASTNodeCount="27" docActiveCodeLength="222" docExpressionCount="14" docLength="319" projectName="pa3" starttimestamp="1650226882502" timestamp="104432016">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Expression.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import  miniJava.SyntacticAnalyzer.SourcePosition;

public abstract class Expression extends AST {

  public Expression(SourcePosition posn) {
    super (posn);
  }
  
}
]]></snapshot>
  </Command>
  <Command __id="2489" _type="SelectTextCommand" caretOffset="169" date="Mon Apr 18 21:21:54 EDT 2022" end="169" start="159" starttimestamp="1650226882502" timestamp="104432163" />
  <Command __id="2490" _type="MoveCaretCommand" caretOffset="185" date="Mon Apr 18 21:21:55 EDT 2022" docOffset="242" starttimestamp="1650226882502" timestamp="104433054" />
  <DocumentChange __id="2491" _type="Insert" date="Mon Apr 18 21:21:57 EDT 2022" docASTNodeCount="27" docActiveCodeLength="223" docExpressionCount="14" docLength="320" length="1" offset="242" starttimestamp="1650226882502" timestamp="104434499">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2492" _type="InsertStringCommand" date="Mon Apr 18 21:21:57 EDT 2022" starttimestamp="1650226882502" timestamp="104434499" timestamp2="104434499">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2493" _type="Insert" date="Mon Apr 18 21:21:57 EDT 2022" docASTNodeCount="27" docActiveCodeLength="224" docExpressionCount="14" docLength="321" length="1" offset="243" starttimestamp="1650226882502" timestamp="104434621">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2494" _type="InsertStringCommand" date="Mon Apr 18 21:21:57 EDT 2022" starttimestamp="1650226882502" timestamp="104434636" timestamp2="104434636">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2496" _type="PasteCommand" date="Mon Apr 18 21:21:57 EDT 2022" starttimestamp="1650226882502" timestamp="104434973" />
  <DocumentChange __id="2495" _type="Replace" date="Mon Apr 18 21:21:57 EDT 2022" docASTNodeCount="33" docActiveCodeLength="249" docExpressionCount="16" docLength="346" endLine="10" insertionLength="27" int_docASTNodeCount="27" int_docActiveCodeLength="222" int_docExpressionCount="14" int_docLength="319" length="2" offset="242" startLine="10" starttimestamp="1650226882502" timestamp="104434921">
    <deletedText><![CDATA[  ]]></deletedText>
    <insertedText><![CDATA[	  public Declaration decl;]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="2498" _type="Delete" date="Mon Apr 18 21:21:59 EDT 2022" docASTNodeCount="33" docActiveCodeLength="248" docExpressionCount="16" docLength="345" endLine="10" length="1" offset="244" startLine="10" starttimestamp="1650226882502" timestamp="104436670">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2500" _type="Delete" date="Mon Apr 18 21:21:59 EDT 2022" docASTNodeCount="33" docActiveCodeLength="247" docExpressionCount="16" docLength="344" endLine="10" length="1" offset="243" startLine="10" starttimestamp="1650226882502" timestamp="104436854">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2502" _type="Delete" date="Mon Apr 18 21:21:59 EDT 2022" docASTNodeCount="33" docActiveCodeLength="246" docExpressionCount="16" docLength="343" endLine="10" length="1" offset="242" startLine="10" starttimestamp="1650226882502" timestamp="104437023">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="2504" _type="Delete" date="Mon Apr 18 21:21:59 EDT 2022" docASTNodeCount="33" docActiveCodeLength="244" docExpressionCount="16" docLength="341" endLine="10" length="2" offset="240" startLine="9" starttimestamp="1650226882502" timestamp="104437186">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="2497" _type="MoveCaretCommand" caretOffset="188" date="Mon Apr 18 21:21:58 EDT 2022" docOffset="245" starttimestamp="1650226882502" timestamp="104436122" />
  <Command __id="2499" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:21:59 EDT 2022" starttimestamp="1650226882502" timestamp="104436670" />
  <Command __id="2501" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:21:59 EDT 2022" starttimestamp="1650226882502" timestamp="104436854" />
  <Command __id="2503" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:21:59 EDT 2022" starttimestamp="1650226882502" timestamp="104437023" />
  <Command __id="2505" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:21:59 EDT 2022" starttimestamp="1650226882502" timestamp="104437186" />
  <Command __id="2507" _type="UndoCommand" date="Mon Apr 18 21:22:00 EDT 2022" starttimestamp="1650226882502" timestamp="104438255" />
  <Command __id="2508" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:22:02 EDT 2022" starttimestamp="1650226882502" timestamp="104439508" />
  <Command __id="2510" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:22:02 EDT 2022" starttimestamp="1650226882502" timestamp="104439987" />
  <Command __id="2512" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:22:02 EDT 2022" starttimestamp="1650226882502" timestamp="104440202" />
  <Command __id="2514" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:22:02 EDT 2022" starttimestamp="1650226882502" timestamp="104440388" />
  <Command __id="2516" _type="InsertStringCommand" date="Mon Apr 18 21:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="104441088" timestamp2="104441088">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2518" _type="InsertStringCommand" date="Mon Apr 18 21:22:03 EDT 2022" starttimestamp="1650226882502" timestamp="104441372" timestamp2="104441372">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2519" _type="MoveCaretCommand" caretOffset="252" date="Mon Apr 18 21:22:04 EDT 2022" docOffset="309" starttimestamp="1650226882502" timestamp="104442357" />
  <Command __id="2520" _type="MoveCaretCommand" caretOffset="211" date="Mon Apr 18 21:22:05 EDT 2022" docOffset="268" starttimestamp="1650226882502" timestamp="104442658" />
  <Command __id="2522" _type="InsertStringCommand" date="Mon Apr 18 21:22:05 EDT 2022" starttimestamp="1650226882502" timestamp="104443242" timestamp2="104443242">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="2506" _type="Insert" date="Mon Apr 18 21:22:00 EDT 2022" docASTNodeCount="33" docActiveCodeLength="249" docExpressionCount="16" docLength="346" length="5" offset="240" starttimestamp="1650226882502" timestamp="104438255">
    <text><![CDATA[
	  ]]></text>
  </DocumentChange>
  <DocumentChange __id="2509" _type="Delete" date="Mon Apr 18 21:22:02 EDT 2022" docASTNodeCount="33" docActiveCodeLength="248" docExpressionCount="16" docLength="345" endLine="10" length="1" offset="244" startLine="10" starttimestamp="1650226882502" timestamp="104439987">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2511" _type="Delete" date="Mon Apr 18 21:22:02 EDT 2022" docASTNodeCount="33" docActiveCodeLength="247" docExpressionCount="16" docLength="344" endLine="10" length="1" offset="243" startLine="10" starttimestamp="1650226882502" timestamp="104440187">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2513" _type="Delete" date="Mon Apr 18 21:22:02 EDT 2022" docASTNodeCount="33" docActiveCodeLength="246" docExpressionCount="16" docLength="343" endLine="10" length="1" offset="242" startLine="10" starttimestamp="1650226882502" timestamp="104440388">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="2515" _type="Insert" date="Mon Apr 18 21:22:03 EDT 2022" docASTNodeCount="33" docActiveCodeLength="247" docExpressionCount="16" docLength="344" length="1" offset="242" starttimestamp="1650226882502" timestamp="104441088">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2517" _type="Insert" date="Mon Apr 18 21:22:03 EDT 2022" docASTNodeCount="33" docActiveCodeLength="248" docExpressionCount="16" docLength="345" length="1" offset="243" starttimestamp="1650226882502" timestamp="104441372">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2521" _type="Insert" date="Mon Apr 18 21:22:05 EDT 2022" docASTNodeCount="33" docActiveCodeLength="252" docExpressionCount="16" docLength="349" length="4" offset="268" starttimestamp="1650226882502" timestamp="104443227">
    <text><![CDATA[
  ]]></text>
  </DocumentChange>
  <Command __id="2526" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:09 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7886" docExpressionCount="838" docLength="8984" projectName="pa3" starttimestamp="1650226882502" timestamp="104446783">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.openScope();¶			table.enter(cd);¶			cd.visit(this, null);¶			table.closeScope();¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="2523" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Apr 18 21:22:07 EDT 2022" starttimestamp="1650226882502" timestamp="104445486" />
  <Command __id="2524" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:22:08 EDT 2022" starttimestamp="1650226882502" timestamp="104445577" />
  <Command __id="2525" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:22:08 EDT 2022" starttimestamp="1650226882502" timestamp="104445915" />
  <Command __id="2527" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:22:09 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104446932" />
  <Command __id="2529" _type="SelectTextCommand" caretOffset="156" date="Mon Apr 18 21:22:15 EDT 2022" end="156" start="149" starttimestamp="1650226882502" timestamp="104453016" />
  <Command __id="2528" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:15 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="104452936">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2530" _type="MoveCaretCommand" caretOffset="198" date="Mon Apr 18 21:22:20 EDT 2022" docOffset="255" starttimestamp="1650226882502" timestamp="104457918" />
  <Command __id="2531" _type="MoveCaretCommand" caretOffset="198" date="Mon Apr 18 21:22:20 EDT 2022" docOffset="255" starttimestamp="1650226882502" timestamp="104457918" />
  <Command __id="2532" _type="MoveCaretCommand" caretOffset="172" date="Mon Apr 18 21:22:20 EDT 2022" docOffset="229" starttimestamp="1650226882502" timestamp="104458282" />
  <Command __id="2533" _type="MoveCaretCommand" caretOffset="172" date="Mon Apr 18 21:22:20 EDT 2022" docOffset="229" starttimestamp="1650226882502" timestamp="104458295" />
  <Command __id="2534" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:27 EDT 2022" docASTNodeCount="33" docActiveCodeLength="242" docExpressionCount="16" docLength="339" projectName="pa3" starttimestamp="1650226882502" timestamp="104465459">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Reference.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

public abstract class Reference extends AST
{
	public Declaration decl;
	  
	public Reference(SourcePosition posn){
		super(posn);
	}

}
]]></snapshot>
  </Command>
  <Command __id="2535" _type="SelectTextCommand" caretOffset="167" date="Mon Apr 18 21:22:28 EDT 2022" end="167" start="158" starttimestamp="1650226882502" timestamp="104465558" />
  <Command __id="2536" _type="MoveCaretCommand" caretOffset="182" date="Mon Apr 18 21:22:29 EDT 2022" docOffset="239" starttimestamp="1650226882502" timestamp="104466508" />
  <Command __id="2538" _type="SelectTextCommand" caretOffset="168" date="Mon Apr 18 21:22:32 EDT 2022" end="168" start="159" starttimestamp="1650226882502" timestamp="104470151" />
  <Command __id="2539" _type="MoveCaretCommand" caretOffset="184" date="Mon Apr 18 21:22:37 EDT 2022" docOffset="241" starttimestamp="1650226882502" timestamp="104475058" />
  <Command __id="2541" _type="InsertStringCommand" date="Mon Apr 18 21:22:38 EDT 2022" starttimestamp="1650226882502" timestamp="104475659" timestamp2="104475659">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2543" _type="PasteCommand" date="Mon Apr 18 21:22:38 EDT 2022" starttimestamp="1650226882502" timestamp="104476075" />
  <Command __id="2544" _type="SelectTextCommand" caretOffset="185" date="Mon Apr 18 21:22:40 EDT 2022" end="187" start="185" starttimestamp="1650226882502" timestamp="104478294" />
  <Command __id="2546" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:22:40 EDT 2022" starttimestamp="1650226882502" timestamp="104478317" />
  <Command __id="2548" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:22:41 EDT 2022" starttimestamp="1650226882502" timestamp="104478594" />
  <Command __id="2550" _type="InsertStringCommand" date="Mon Apr 18 21:22:41 EDT 2022" starttimestamp="1650226882502" timestamp="104479242" timestamp2="104479242">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2552" _type="InsertStringCommand" date="Mon Apr 18 21:22:41 EDT 2022" starttimestamp="1650226882502" timestamp="104479442" timestamp2="104479442">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2553" _type="MoveCaretCommand" caretOffset="210" date="Mon Apr 18 21:22:42 EDT 2022" docOffset="267" starttimestamp="1650226882502" timestamp="104480047" />
  <Command __id="2555" _type="InsertStringCommand" date="Mon Apr 18 21:22:43 EDT 2022" starttimestamp="1650226882502" timestamp="104480630" timestamp2="104480630">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2537" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:32 EDT 2022" docASTNodeCount="27" docActiveCodeLength="218" docExpressionCount="14" docLength="315" projectName="pa3" starttimestamp="1650226882502" timestamp="104470029">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Statement.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import  miniJava.SyntacticAnalyzer.SourcePosition;

public abstract class Statement extends AST {

  public Statement(SourcePosition posn) {
    super (posn);
  }

}
]]></snapshot>
  </Command>
  <DocumentChange __id="2540" _type="Insert" date="Mon Apr 18 21:22:38 EDT 2022" docASTNodeCount="27" docActiveCodeLength="219" docExpressionCount="14" docLength="316" length="1" offset="241" starttimestamp="1650226882502" timestamp="104475659">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2542" _type="Replace" date="Mon Apr 18 21:22:38 EDT 2022" docASTNodeCount="33" docActiveCodeLength="245" docExpressionCount="16" docLength="342" endLine="10" insertionLength="27" int_docASTNodeCount="27" int_docActiveCodeLength="218" int_docExpressionCount="14" int_docLength="315" length="1" offset="241" startLine="10" starttimestamp="1650226882502" timestamp="104476022">
    <deletedText><![CDATA[ ]]></deletedText>
    <insertedText><![CDATA[	  public Declaration decl;]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="2545" _type="Delete" date="Mon Apr 18 21:22:40 EDT 2022" docASTNodeCount="33" docActiveCodeLength="243" docExpressionCount="16" docLength="340" endLine="10" length="2" offset="242" startLine="10" starttimestamp="1650226882502" timestamp="104478317">
    <text><![CDATA[  ]]></text>
  </DocumentChange>
  <DocumentChange __id="2547" _type="Delete" date="Mon Apr 18 21:22:41 EDT 2022" docASTNodeCount="33" docActiveCodeLength="242" docExpressionCount="16" docLength="339" endLine="10" length="1" offset="241" startLine="10" starttimestamp="1650226882502" timestamp="104478594">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="2549" _type="Insert" date="Mon Apr 18 21:22:41 EDT 2022" docASTNodeCount="33" docActiveCodeLength="243" docExpressionCount="16" docLength="340" length="1" offset="241" starttimestamp="1650226882502" timestamp="104479242">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2551" _type="Insert" date="Mon Apr 18 21:22:41 EDT 2022" docASTNodeCount="33" docActiveCodeLength="244" docExpressionCount="16" docLength="341" length="1" offset="242" starttimestamp="1650226882502" timestamp="104479442">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2554" _type="Insert" date="Mon Apr 18 21:22:43 EDT 2022" docASTNodeCount="33" docActiveCodeLength="248" docExpressionCount="16" docLength="345" length="4" offset="267" starttimestamp="1650226882502" timestamp="104480630">
    <text><![CDATA[
  ]]></text>
  </DocumentChange>
  <Command __id="2559" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:45 EDT 2022" docASTNodeCount="33" docActiveCodeLength="242" docExpressionCount="16" docLength="339" projectName="pa3" starttimestamp="1650226882502" timestamp="104482607">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Reference.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public abstract class Reference extends AST¶{¶	public Declaration decl;¶	  ¶	public Reference(SourcePosition posn){¶		super(posn);¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2561" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:46 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="104483584">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2563" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:52 EDT 2022" docASTNodeCount="33" docActiveCodeLength="242" docExpressionCount="16" docLength="339" projectName="pa3" starttimestamp="1650226882502" timestamp="104489951">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Reference.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public abstract class Reference extends AST¶{¶	public Declaration decl;¶	  ¶	public Reference(SourcePosition posn){¶		super(posn);¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="2565" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:53 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="104491288">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2556" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Apr 18 21:22:44 EDT 2022" starttimestamp="1650226882502" timestamp="104481860" />
  <Command __id="2557" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:22:44 EDT 2022" starttimestamp="1650226882502" timestamp="104481889" />
  <Command __id="2558" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:22:44 EDT 2022" starttimestamp="1650226882502" timestamp="104482064" />
  <Command __id="2560" _type="MoveCaretCommand" caretOffset="182" date="Mon Apr 18 21:22:45 EDT 2022" docOffset="239" starttimestamp="1650226882502" timestamp="104482687" />
  <Command __id="2562" _type="MoveCaretCommand" caretOffset="172" date="Mon Apr 18 21:22:46 EDT 2022" docOffset="229" starttimestamp="1650226882502" timestamp="104483704" />
  <Command __id="2564" _type="SelectTextCommand" caretOffset="167" date="Mon Apr 18 21:22:52 EDT 2022" end="167" start="158" starttimestamp="1650226882502" timestamp="104490091" />
  <Command __id="2566" _type="MoveCaretCommand" caretOffset="172" date="Mon Apr 18 21:22:53 EDT 2022" docOffset="229" starttimestamp="1650226882502" timestamp="104491462" />
  <Command __id="2568" _type="SelectTextCommand" caretOffset="169" date="Mon Apr 18 21:22:58 EDT 2022" end="169" start="158" starttimestamp="1650226882502" timestamp="104495829" />
  <Command __id="2569" _type="MoveCaretCommand" caretOffset="189" date="Mon Apr 18 21:23:01 EDT 2022" docOffset="246" starttimestamp="1650226882502" timestamp="104499092" />
  <Command __id="2567" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:22:58 EDT 2022" docASTNodeCount="41" docActiveCodeLength="323" docExpressionCount="21" docLength="420" projectName="pa3" starttimestamp="1650226882502" timestamp="104495698">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\TypeDenoter.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[/**
 * miniJava Abstract Syntax Tree classes
 * @author prins
 * @version COMP 520 (v2.2)
 */
package miniJava.AbstractSyntaxTrees;

import miniJava.SyntacticAnalyzer.SourcePosition;

abstract public class TypeDenoter extends AST {
    
    public TypeDenoter(TypeKind type, SourcePosition posn){
        super(posn);
        typeKind = type;
    }
    
    public TypeKind typeKind;
    
}

        ]]></snapshot>
  </Command>
  <Command __id="2570" _type="MoveCaretCommand" caretOffset="186" date="Mon Apr 18 21:23:02 EDT 2022" docOffset="243" starttimestamp="1650226882502" timestamp="104500340" />
  <Command __id="2571" _type="MoveCaretCommand" caretOffset="185" date="Mon Apr 18 21:23:03 EDT 2022" docOffset="242" starttimestamp="1650226882502" timestamp="104500975" />
  <Command __id="2573" _type="PasteCommand" date="Mon Apr 18 21:23:04 EDT 2022" starttimestamp="1650226882502" timestamp="104502173" />
  <Command __id="2574" _type="MoveCaretCommand" caretOffset="188" date="Mon Apr 18 21:23:05 EDT 2022" docOffset="245" starttimestamp="1650226882502" timestamp="104503198" />
  <Command __id="2576" _type="InsertStringCommand" date="Mon Apr 18 21:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="104503660" timestamp2="104503660">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="2578" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="104503660" />
  <Command __id="2580" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="104504045" />
  <Command __id="2582" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:23:06 EDT 2022" starttimestamp="1650226882502" timestamp="104504145" />
  <DocumentChange __id="2572" _type="Insert" date="Mon Apr 18 21:23:04 EDT 2022" docASTNodeCount="47" docActiveCodeLength="350" docExpressionCount="23" docLength="447" length="27" offset="242" starttimestamp="1650226882502" timestamp="104502111">
    <text><![CDATA[	  public Declaration decl;]]></text>
  </DocumentChange>
  <DocumentChange __id="2575" _type="Insert" date="Mon Apr 18 21:23:06 EDT 2022" docASTNodeCount="47" docActiveCodeLength="351" docExpressionCount="23" docLength="448" length="1" offset="245" starttimestamp="1650226882502" timestamp="104503660">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="2577" _type="Delete" date="Mon Apr 18 21:23:06 EDT 2022" docASTNodeCount="47" docActiveCodeLength="350" docExpressionCount="23" docLength="447" endLine="10" length="1" offset="245" startLine="10" starttimestamp="1650226882502" timestamp="104503660">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="2579" _type="Delete" date="Mon Apr 18 21:23:06 EDT 2022" docASTNodeCount="47" docActiveCodeLength="349" docExpressionCount="23" docLength="446" endLine="10" length="1" offset="244" startLine="10" starttimestamp="1650226882502" timestamp="104504045">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2581" _type="Delete" date="Mon Apr 18 21:23:06 EDT 2022" docASTNodeCount="47" docActiveCodeLength="348" docExpressionCount="23" docLength="445" endLine="10" length="1" offset="243" startLine="10" starttimestamp="1650226882502" timestamp="104504145">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2584" _type="Replace" date="Mon Apr 18 21:23:08 EDT 2022" docASTNodeCount="47" docActiveCodeLength="350" docExpressionCount="23" docLength="447" endLine="10" insertionLength="3" int_docASTNodeCount="47" int_docActiveCodeLength="347" int_docExpressionCount="23" int_docLength="444" length="1" offset="270" startLine="10" starttimestamp="1650226882502" timestamp="104506014">
    <deletedText><![CDATA[ ]]></deletedText>
    <insertedText><![CDATA[
	]]></insertedText>
  </DocumentChange>
  <Command __id="2589" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:23:10 EDT 2022" docASTNodeCount="69" docActiveCodeLength="367" docExpressionCount="36" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="104507710">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Package.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class Package extends AST {¶¶	public Package(ClassDeclList cdl, SourcePosition posn) {¶		super(posn);¶		classDeclList = cdl;¶	}¶¶	public <A,R> R visit(Visitor<A,R> v, A o) {¶		return v.visitPackage(this, o);¶	}¶¶	public ClassDeclList classDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2583" _type="MoveCaretCommand" caretOffset="213" date="Mon Apr 18 21:23:07 EDT 2022" docOffset="270" starttimestamp="1650226882502" timestamp="104505214" />
  <Command __id="2585" _type="InsertStringCommand" date="Mon Apr 18 21:23:08 EDT 2022" starttimestamp="1650226882502" timestamp="104506014" timestamp2="104506014">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2586" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Apr 18 21:23:08 EDT 2022" starttimestamp="1650226882502" timestamp="104506478" />
  <Command __id="2587" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:23:09 EDT 2022" starttimestamp="1650226882502" timestamp="104506569" />
  <Command __id="2588" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:23:09 EDT 2022" starttimestamp="1650226882502" timestamp="104506684" />
  <Command __id="2590" _type="MoveCaretCommand" caretOffset="172" date="Mon Apr 18 21:23:10 EDT 2022" docOffset="229" starttimestamp="1650226882502" timestamp="104507834" />
  <Command __id="2592" _type="MoveCaretCommand" caretOffset="67" date="Mon Apr 18 21:23:28 EDT 2022" docOffset="224" starttimestamp="1650226882502" timestamp="104525720" />
  <Command __id="2591" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:23:28 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1005" docExpressionCount="100" docLength="1159" projectName="pa3" starttimestamp="1650226882502" timestamp="104525671">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="2594" _type="Insert" date="Mon Apr 18 21:23:34 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1008" docExpressionCount="100" docLength="1162" length="3" offset="1152" starttimestamp="1650226882502" timestamp="104531726">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="2596" _type="Insert" date="Mon Apr 18 21:23:34 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1011" docExpressionCount="100" docLength="1165" length="3" offset="1155" starttimestamp="1650226882502" timestamp="104532073">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="2598" _type="Insert" date="Mon Apr 18 21:23:35 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1012" docExpressionCount="100" docLength="1166" length="1" offset="1158" starttimestamp="1650226882502" timestamp="104533123">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="2600" _type="Insert" date="Mon Apr 18 21:23:35 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1013" docExpressionCount="100" docLength="1167" length="1" offset="1159" starttimestamp="1650226882502" timestamp="104533250">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="2602" _type="Insert" date="Mon Apr 18 21:23:35 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1014" docExpressionCount="100" docLength="1168" length="1" offset="1160" starttimestamp="1650226882502" timestamp="104533410">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="2604" _type="Insert" date="Mon Apr 18 21:23:36 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1015" docExpressionCount="100" docLength="1169" length="1" offset="1161" starttimestamp="1650226882502" timestamp="104533504">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="2606" _type="Insert" date="Mon Apr 18 21:23:36 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1016" docExpressionCount="100" docLength="1170" length="1" offset="1162" starttimestamp="1650226882502" timestamp="104533611">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="2608" _type="Insert" date="Mon Apr 18 21:23:36 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1017" docExpressionCount="100" docLength="1171" length="1" offset="1163" starttimestamp="1650226882502" timestamp="104533711">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="2610" _type="Insert" date="Mon Apr 18 21:23:36 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1018" docExpressionCount="100" docLength="1172" length="1" offset="1164" starttimestamp="1650226882502" timestamp="104533958">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2612" _type="Insert" date="Mon Apr 18 21:23:38 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1019" docExpressionCount="100" docLength="1173" length="1" offset="1165" starttimestamp="1650226882502" timestamp="104535841">
    <text><![CDATA[D]]></text>
  </DocumentChange>
  <DocumentChange __id="2614" _type="Insert" date="Mon Apr 18 21:23:38 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1020" docExpressionCount="100" docLength="1174" length="1" offset="1166" starttimestamp="1650226882502" timestamp="104536176">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2616" _type="Insert" date="Mon Apr 18 21:23:38 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1021" docExpressionCount="100" docLength="1175" length="1" offset="1167" starttimestamp="1650226882502" timestamp="104536392">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="2618" _type="Insert" date="Mon Apr 18 21:23:39 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1022" docExpressionCount="100" docLength="1176" length="1" offset="1168" starttimestamp="1650226882502" timestamp="104536529">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="2620" _type="Insert" date="Mon Apr 18 21:23:39 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1023" docExpressionCount="100" docLength="1177" length="1" offset="1169" starttimestamp="1650226882502" timestamp="104536677">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="2622" _type="Insert" date="Mon Apr 18 21:23:39 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1024" docExpressionCount="100" docLength="1178" length="1" offset="1170" starttimestamp="1650226882502" timestamp="104537061">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2624" _type="Insert" date="Mon Apr 18 21:23:39 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1025" docExpressionCount="100" docLength="1179" length="1" offset="1171" starttimestamp="1650226882502" timestamp="104537176">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="2626" _type="Delete" date="Mon Apr 18 21:23:40 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1024" docExpressionCount="100" docLength="1178" endLine="42" length="1" offset="1171" startLine="42" starttimestamp="1650226882502" timestamp="104537730">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="2628" _type="Delete" date="Mon Apr 18 21:23:40 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1023" docExpressionCount="100" docLength="1177" endLine="42" length="1" offset="1170" startLine="42" starttimestamp="1650226882502" timestamp="104537930">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="2593" _type="MoveCaretCommand" caretOffset="995" date="Mon Apr 18 21:23:33 EDT 2022" docOffset="1152" starttimestamp="1650226882502" timestamp="104531159" />
  <Command __id="2595" _type="InsertStringCommand" date="Mon Apr 18 21:23:34 EDT 2022" starttimestamp="1650226882502" timestamp="104531788" timestamp2="104531788">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2597" _type="InsertStringCommand" date="Mon Apr 18 21:23:34 EDT 2022" starttimestamp="1650226882502" timestamp="104532073" timestamp2="104532073">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2599" _type="InsertStringCommand" date="Mon Apr 18 21:23:35 EDT 2022" starttimestamp="1650226882502" timestamp="104533127" timestamp2="104533127">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="2601" _type="InsertStringCommand" date="Mon Apr 18 21:23:35 EDT 2022" starttimestamp="1650226882502" timestamp="104533254" timestamp2="104533254">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="2603" _type="InsertStringCommand" date="Mon Apr 18 21:23:35 EDT 2022" starttimestamp="1650226882502" timestamp="104533410" timestamp2="104533410">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="2605" _type="InsertStringCommand" date="Mon Apr 18 21:23:36 EDT 2022" starttimestamp="1650226882502" timestamp="104533511" timestamp2="104533511">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2607" _type="InsertStringCommand" date="Mon Apr 18 21:23:36 EDT 2022" starttimestamp="1650226882502" timestamp="104533611" timestamp2="104533611">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2609" _type="InsertStringCommand" date="Mon Apr 18 21:23:36 EDT 2022" starttimestamp="1650226882502" timestamp="104533727" timestamp2="104533727">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="2611" _type="InsertStringCommand" date="Mon Apr 18 21:23:36 EDT 2022" starttimestamp="1650226882502" timestamp="104533958" timestamp2="104533958">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2613" _type="InsertStringCommand" date="Mon Apr 18 21:23:38 EDT 2022" starttimestamp="1650226882502" timestamp="104535841" timestamp2="104535841">
    <data><![CDATA[D]]></data>
  </Command>
  <Command __id="2615" _type="InsertStringCommand" date="Mon Apr 18 21:23:38 EDT 2022" starttimestamp="1650226882502" timestamp="104536176" timestamp2="104536176">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2617" _type="InsertStringCommand" date="Mon Apr 18 21:23:38 EDT 2022" starttimestamp="1650226882502" timestamp="104536392" timestamp2="104536392">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="2619" _type="InsertStringCommand" date="Mon Apr 18 21:23:39 EDT 2022" starttimestamp="1650226882502" timestamp="104536545" timestamp2="104536545">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2621" _type="InsertStringCommand" date="Mon Apr 18 21:23:39 EDT 2022" starttimestamp="1650226882502" timestamp="104536677" timestamp2="104536677">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2623" _type="InsertStringCommand" date="Mon Apr 18 21:23:39 EDT 2022" starttimestamp="1650226882502" timestamp="104537061" timestamp2="104537061">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2625" _type="InsertStringCommand" date="Mon Apr 18 21:23:39 EDT 2022" starttimestamp="1650226882502" timestamp="104537192" timestamp2="104537192">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2627" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:23:40 EDT 2022" starttimestamp="1650226882502" timestamp="104537730" />
  <Command __id="2629" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:23:40 EDT 2022" starttimestamp="1650226882502" timestamp="104537930" />
  <Command __id="2631" _type="InsertStringCommand" date="Mon Apr 18 21:23:48 EDT 2022" starttimestamp="1650226882502" timestamp="104545838" timestamp2="104545838">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2633" _type="InsertStringCommand" date="Mon Apr 18 21:23:48 EDT 2022" starttimestamp="1650226882502" timestamp="104545939" timestamp2="104545939">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2635" _type="InsertStringCommand" date="Mon Apr 18 21:23:48 EDT 2022" starttimestamp="1650226882502" timestamp="104546155" timestamp2="104546155">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2637" _type="InsertStringCommand" date="Mon Apr 18 21:23:48 EDT 2022" starttimestamp="1650226882502" timestamp="104546355" timestamp2="104546355">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2639" _type="InsertStringCommand" date="Mon Apr 18 21:23:48 EDT 2022" starttimestamp="1650226882502" timestamp="104546455" timestamp2="104546455">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="2630" _type="Insert" date="Mon Apr 18 21:23:48 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1024" docExpressionCount="100" docLength="1178" length="1" offset="1170" starttimestamp="1650226882502" timestamp="104545838">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2632" _type="Insert" date="Mon Apr 18 21:23:48 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1025" docExpressionCount="100" docLength="1179" length="1" offset="1171" starttimestamp="1650226882502" timestamp="104545923">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="2634" _type="Insert" date="Mon Apr 18 21:23:48 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1026" docExpressionCount="100" docLength="1180" length="1" offset="1172" starttimestamp="1650226882502" timestamp="104546139">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="2636" _type="Insert" date="Mon Apr 18 21:23:48 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1027" docExpressionCount="100" docLength="1181" length="1" offset="1173" starttimestamp="1650226882502" timestamp="104546339">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="2638" _type="Insert" date="Mon Apr 18 21:23:48 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1028" docExpressionCount="100" docLength="1182" length="1" offset="1174" starttimestamp="1650226882502" timestamp="104546455">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="2640" _type="Insert" date="Mon Apr 18 21:23:49 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1029" docExpressionCount="100" docLength="1183" length="1" offset="1175" starttimestamp="1650226882502" timestamp="104546571">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="2642" _type="Insert" date="Mon Apr 18 21:23:49 EDT 2022" docASTNodeCount="172" docActiveCodeLength="1030" docExpressionCount="100" docLength="1184" length="1" offset="1176" starttimestamp="1650226882502" timestamp="104546687">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2644" _type="Insert" date="Mon Apr 18 21:23:50 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1031" docExpressionCount="102" docLength="1185" length="1" offset="1177" starttimestamp="1650226882502" timestamp="104547526">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2646" _type="Insert" date="Mon Apr 18 21:23:50 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1032" docExpressionCount="102" docLength="1186" length="1" offset="1178" starttimestamp="1650226882502" timestamp="104547626">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2648" _type="Insert" date="Mon Apr 18 21:23:50 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1033" docExpressionCount="102" docLength="1187" length="1" offset="1179" starttimestamp="1650226882502" timestamp="104547889">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="2650" _type="Insert" date="Mon Apr 18 21:23:50 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1034" docExpressionCount="102" docLength="1188" length="1" offset="1180" starttimestamp="1650226882502" timestamp="104548047">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2652" _type="Insert" date="Mon Apr 18 21:23:50 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1035" docExpressionCount="102" docLength="1189" length="1" offset="1181" starttimestamp="1650226882502" timestamp="104548167">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2654" _type="Delete" date="Mon Apr 18 21:23:51 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1034" docExpressionCount="102" docLength="1188" endLine="42" length="1" offset="1181" startLine="42" starttimestamp="1650226882502" timestamp="104548707">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2656" _type="Insert" date="Mon Apr 18 21:23:51 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1035" docExpressionCount="102" docLength="1189" length="1" offset="1181" starttimestamp="1650226882502" timestamp="104548907">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="2658" _type="Insert" date="Mon Apr 18 21:23:51 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1036" docExpressionCount="102" docLength="1190" length="1" offset="1182" starttimestamp="1650226882502" timestamp="104548976">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2660" _type="Insert" date="Mon Apr 18 21:23:51 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1037" docExpressionCount="102" docLength="1191" length="1" offset="1183" starttimestamp="1650226882502" timestamp="104549150">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <DocumentChange __id="2662" _type="Insert" date="Mon Apr 18 21:23:51 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1038" docExpressionCount="102" docLength="1192" length="1" offset="1184" starttimestamp="1650226882502" timestamp="104549263">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2664" _type="Insert" date="Mon Apr 18 21:23:52 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1040" docExpressionCount="102" docLength="1194" length="2" offset="1185" starttimestamp="1650226882502" timestamp="104550007">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="2641" _type="InsertStringCommand" date="Mon Apr 18 21:23:49 EDT 2022" starttimestamp="1650226882502" timestamp="104546571" timestamp2="104546571">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="2643" _type="InsertStringCommand" date="Mon Apr 18 21:23:49 EDT 2022" starttimestamp="1650226882502" timestamp="104546702" timestamp2="104546702">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2645" _type="InsertStringCommand" date="Mon Apr 18 21:23:50 EDT 2022" starttimestamp="1650226882502" timestamp="104547542" timestamp2="104547542">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2647" _type="InsertStringCommand" date="Mon Apr 18 21:23:50 EDT 2022" starttimestamp="1650226882502" timestamp="104547642" timestamp2="104547642">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2649" _type="InsertStringCommand" date="Mon Apr 18 21:23:50 EDT 2022" starttimestamp="1650226882502" timestamp="104547889" timestamp2="104547889">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2651" _type="InsertStringCommand" date="Mon Apr 18 21:23:50 EDT 2022" starttimestamp="1650226882502" timestamp="104548052" timestamp2="104548052">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2653" _type="InsertStringCommand" date="Mon Apr 18 21:23:50 EDT 2022" starttimestamp="1650226882502" timestamp="104548171" timestamp2="104548171">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2655" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:23:51 EDT 2022" starttimestamp="1650226882502" timestamp="104548707" />
  <Command __id="2657" _type="InsertStringCommand" date="Mon Apr 18 21:23:51 EDT 2022" starttimestamp="1650226882502" timestamp="104548907" timestamp2="104548907">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2659" _type="InsertStringCommand" date="Mon Apr 18 21:23:51 EDT 2022" starttimestamp="1650226882502" timestamp="104548992" timestamp2="104548992">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2661" _type="InsertStringCommand" date="Mon Apr 18 21:23:51 EDT 2022" starttimestamp="1650226882502" timestamp="104549150" timestamp2="104549150">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="2663" _type="InsertStringCommand" date="Mon Apr 18 21:23:51 EDT 2022" starttimestamp="1650226882502" timestamp="104549263" timestamp2="104549263">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2665" _type="InsertStringCommand" date="Mon Apr 18 21:23:52 EDT 2022" starttimestamp="1650226882502" timestamp="104550013" timestamp2="104550013">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="2667" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104551579" timestamp2="104551579">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="2669" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104551832" timestamp2="104551832">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2671" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104551960" timestamp2="104551960">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2673" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104552049" timestamp2="104552049">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2675" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104552164" timestamp2="104552164">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="2677" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104552217" timestamp2="104552217">
    <data><![CDATA[g]]></data>
  </Command>
  <Command __id="2679" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104552396" timestamp2="104552396">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2681" _type="InsertStringCommand" date="Mon Apr 18 21:23:54 EDT 2022" starttimestamp="1650226882502" timestamp="104552449" timestamp2="104552449">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2683" _type="InsertStringCommand" date="Mon Apr 18 21:23:55 EDT 2022" starttimestamp="1650226882502" timestamp="104552612" timestamp2="104552612">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2684" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:23:56 EDT 2022" starttimestamp="1650226882502" timestamp="104553581" />
  <Command __id="2685" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_PREVIOUS" date="Mon Apr 18 21:23:56 EDT 2022" starttimestamp="1650226882502" timestamp="104554152" />
  <DocumentChange __id="2666" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1041" docExpressionCount="102" docLength="1195" length="1" offset="1186" starttimestamp="1650226882502" timestamp="104551563">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="2668" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1042" docExpressionCount="102" docLength="1196" length="1" offset="1187" starttimestamp="1650226882502" timestamp="104551817">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="2670" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1043" docExpressionCount="102" docLength="1197" length="1" offset="1188" starttimestamp="1650226882502" timestamp="104551960">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2672" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1044" docExpressionCount="102" docLength="1198" length="1" offset="1189" starttimestamp="1650226882502" timestamp="104552049">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="2674" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1045" docExpressionCount="102" docLength="1199" length="1" offset="1190" starttimestamp="1650226882502" timestamp="104552149">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="2676" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1046" docExpressionCount="102" docLength="1200" length="1" offset="1191" starttimestamp="1650226882502" timestamp="104552217">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <DocumentChange __id="2678" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1047" docExpressionCount="102" docLength="1201" length="1" offset="1192" starttimestamp="1650226882502" timestamp="104552396">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2680" _type="Insert" date="Mon Apr 18 21:23:54 EDT 2022" docASTNodeCount="178" docActiveCodeLength="1048" docExpressionCount="102" docLength="1202" length="1" offset="1193" starttimestamp="1650226882502" timestamp="104552449">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2682" _type="Insert" date="Mon Apr 18 21:23:55 EDT 2022" docASTNodeCount="182" docActiveCodeLength="1049" docExpressionCount="104" docLength="1203" length="1" offset="1194" starttimestamp="1650226882502" timestamp="104552596">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="2687" _type="Delete" date="Mon Apr 18 21:23:57 EDT 2022" docASTNodeCount="182" docActiveCodeLength="1048" docExpressionCount="104" docLength="1202" endLine="42" length="1" offset="1193" startLine="42" starttimestamp="1650226882502" timestamp="104554753">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2691" _type="Insert" date="Mon Apr 18 21:23:58 EDT 2022" docASTNodeCount="182" docActiveCodeLength="1049" docExpressionCount="104" docLength="1203" length="1" offset="1195" starttimestamp="1650226882502" timestamp="104556202">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2693" _type="Insert" date="Mon Apr 18 21:23:58 EDT 2022" docASTNodeCount="182" docActiveCodeLength="1050" docExpressionCount="104" docLength="1204" length="1" offset="1196" starttimestamp="1650226882502" timestamp="104556488">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="2695" _type="Insert" date="Mon Apr 18 21:23:59 EDT 2022" docASTNodeCount="182" docActiveCodeLength="1058" docExpressionCount="104" docLength="1212" length="8" offset="1197" starttimestamp="1650226882502" timestamp="104556672">
    <text><![CDATA[
		
	}]]></text>
  </DocumentChange>
  <Command __id="2686" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_PREVIOUS" date="Mon Apr 18 21:23:56 EDT 2022" starttimestamp="1650226882502" timestamp="104554368" />
  <Command __id="2688" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:23:57 EDT 2022" starttimestamp="1650226882502" timestamp="104554753" />
  <Command __id="2689" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:23:57 EDT 2022" starttimestamp="1650226882502" timestamp="104555038" />
  <Command __id="2690" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:23:58 EDT 2022" starttimestamp="1650226882502" timestamp="104555501" />
  <Command __id="2692" _type="InsertStringCommand" date="Mon Apr 18 21:23:58 EDT 2022" starttimestamp="1650226882502" timestamp="104556202" timestamp2="104556202">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2694" _type="InsertStringCommand" date="Mon Apr 18 21:23:58 EDT 2022" starttimestamp="1650226882502" timestamp="104556488" timestamp2="104556488">
    <data><![CDATA[{]]></data>
  </Command>
  <Command __id="2696" _type="InsertStringCommand" date="Mon Apr 18 21:23:59 EDT 2022" starttimestamp="1650226882502" timestamp="104556688" timestamp2="104556688">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2698" _type="InsertStringCommand" date="Mon Apr 18 21:24:04 EDT 2022" starttimestamp="1650226882502" timestamp="104561876" timestamp2="104561876">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2700" _type="InsertStringCommand" date="Mon Apr 18 21:24:04 EDT 2022" starttimestamp="1650226882502" timestamp="104561976" timestamp2="104561976">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2702" _type="InsertStringCommand" date="Mon Apr 18 21:24:04 EDT 2022" starttimestamp="1650226882502" timestamp="104562076" timestamp2="104562076">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2704" _type="InsertStringCommand" date="Mon Apr 18 21:24:04 EDT 2022" starttimestamp="1650226882502" timestamp="104562260" timestamp2="104562260">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="2706" _type="InsertStringCommand" date="Mon Apr 18 21:24:04 EDT 2022" starttimestamp="1650226882502" timestamp="104562330" timestamp2="104562330">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2708" _type="InsertStringCommand" date="Mon Apr 18 21:24:04 EDT 2022" starttimestamp="1650226882502" timestamp="104562492" timestamp2="104562492">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="2710" _type="InsertStringCommand" date="Mon Apr 18 21:24:05 EDT 2022" starttimestamp="1650226882502" timestamp="104562608" timestamp2="104562608">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2712" _type="InsertStringCommand" date="Mon Apr 18 21:24:05 EDT 2022" starttimestamp="1650226882502" timestamp="104562761" timestamp2="104562761">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="2714" _type="InsertStringCommand" date="Mon Apr 18 21:24:05 EDT 2022" starttimestamp="1650226882502" timestamp="104562946" timestamp2="104562946">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="2716" _type="InsertStringCommand" date="Mon Apr 18 21:24:05 EDT 2022" starttimestamp="1650226882502" timestamp="104563100" timestamp2="104563100">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2718" _type="InsertStringCommand" date="Mon Apr 18 21:24:05 EDT 2022" starttimestamp="1650226882502" timestamp="104563237" timestamp2="104563237">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2720" _type="InsertStringCommand" date="Mon Apr 18 21:24:05 EDT 2022" starttimestamp="1650226882502" timestamp="104563477" timestamp2="104563477">
    <data><![CDATA[;]]></data>
  </Command>
  <DocumentChange __id="2697" _type="Insert" date="Mon Apr 18 21:24:04 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1059" docExpressionCount="105" docLength="1213" length="1" offset="1201" starttimestamp="1650226882502" timestamp="104561876">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2699" _type="Insert" date="Mon Apr 18 21:24:04 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1060" docExpressionCount="105" docLength="1214" length="1" offset="1202" starttimestamp="1650226882502" timestamp="104561976">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2701" _type="Insert" date="Mon Apr 18 21:24:04 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1061" docExpressionCount="105" docLength="1215" length="1" offset="1203" starttimestamp="1650226882502" timestamp="104562061">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="2703" _type="Insert" date="Mon Apr 18 21:24:04 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1062" docExpressionCount="105" docLength="1216" length="1" offset="1204" starttimestamp="1650226882502" timestamp="104562245">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="2705" _type="Insert" date="Mon Apr 18 21:24:04 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1063" docExpressionCount="105" docLength="1217" length="1" offset="1205" starttimestamp="1650226882502" timestamp="104562330">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2707" _type="Insert" date="Mon Apr 18 21:24:04 EDT 2022" docASTNodeCount="183" docActiveCodeLength="1064" docExpressionCount="104" docLength="1218" length="1" offset="1206" starttimestamp="1650226882502" timestamp="104562476">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="2709" _type="Insert" date="Mon Apr 18 21:24:05 EDT 2022" docASTNodeCount="183" docActiveCodeLength="1065" docExpressionCount="104" docLength="1219" length="1" offset="1207" starttimestamp="1650226882502" timestamp="104562592">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2711" _type="Insert" date="Mon Apr 18 21:24:05 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1066" docExpressionCount="105" docLength="1220" length="1" offset="1208" starttimestamp="1650226882502" timestamp="104562761">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="2713" _type="Insert" date="Mon Apr 18 21:24:05 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1067" docExpressionCount="105" docLength="1221" length="1" offset="1209" starttimestamp="1650226882502" timestamp="104562946">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="2715" _type="Insert" date="Mon Apr 18 21:24:05 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1068" docExpressionCount="105" docLength="1222" length="1" offset="1210" starttimestamp="1650226882502" timestamp="104563090">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="2717" _type="Insert" date="Mon Apr 18 21:24:05 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1069" docExpressionCount="105" docLength="1223" length="1" offset="1211" starttimestamp="1650226882502" timestamp="104563232">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="2719" _type="Insert" date="Mon Apr 18 21:24:05 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1070" docExpressionCount="105" docLength="1224" length="1" offset="1212" starttimestamp="1650226882502" timestamp="104563461">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="2721" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Apr 18 21:24:07 EDT 2022" starttimestamp="1650226882502" timestamp="104564623" />
  <Command __id="2722" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:24:07 EDT 2022" starttimestamp="1650226882502" timestamp="104564715" />
  <Command __id="2723" _type="EclipseCommand" commandID="" date="Mon Apr 18 21:24:07 EDT 2022" starttimestamp="1650226882502" timestamp="104564763" />
  <Command __id="2724" _type="MoveCaretCommand" caretOffset="1025" date="Mon Apr 18 21:24:07 EDT 2022" docOffset="1182" starttimestamp="1650226882502" timestamp="104565048" />
  <Command __id="2725" _type="MoveCaretCommand" caretOffset="1050" date="Mon Apr 18 21:24:07 EDT 2022" docOffset="1207" starttimestamp="1650226882502" timestamp="104565411" />
  <Command __id="2726" _type="MoveCaretCommand" caretOffset="998" date="Mon Apr 18 21:24:08 EDT 2022" docOffset="1155" starttimestamp="1650226882502" timestamp="104565710" />
  <Command __id="2728" _type="MoveCaretCommand" caretOffset="4124" date="Mon Apr 18 21:26:15 EDT 2022" docOffset="4124" starttimestamp="1650226882502" timestamp="104692709" />
  <Command __id="2729" _type="SelectTextCommand" caretOffset="4080" date="Mon Apr 18 21:26:28 EDT 2022" end="4124" start="4080" starttimestamp="1650226882502" timestamp="104706039" />
  <Command __id="2730" _type="SelectTextCommand" caretOffset="4080" date="Mon Apr 18 21:26:28 EDT 2022" end="4124" start="4080" starttimestamp="1650226882502" timestamp="104706046" />
  <Command __id="2731" _type="MoveCaretCommand" caretOffset="4039" date="Mon Apr 18 21:26:28 EDT 2022" docOffset="4039" starttimestamp="1650226882502" timestamp="104706324" />
  <Command __id="2732" _type="MoveCaretCommand" caretOffset="4039" date="Mon Apr 18 21:26:28 EDT 2022" docOffset="4039" starttimestamp="1650226882502" timestamp="104706334" />
  <Command __id="2727" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:26:15 EDT 2022" docASTNodeCount="1346" docActiveCodeLength="7886" docExpressionCount="838" docLength="8984" projectName="pa3" starttimestamp="1650226882502" timestamp="104692647">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.openScope();¶			table.enter(cd);¶			cd.visit(this, null);¶			table.closeScope();¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="2733" _type="SelectTextCommand" caretOffset="4056" date="Mon Apr 18 21:26:30 EDT 2022" end="4098" start="4056" starttimestamp="1650226882502" timestamp="104707510" />
  <Command __id="2734" _type="SelectTextCommand" caretOffset="4056" date="Mon Apr 18 21:26:30 EDT 2022" end="4098" start="4056" starttimestamp="1650226882502" timestamp="104707518" />
  <DocumentChange __id="2735" _type="Replace" date="Mon Apr 18 21:27:00 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7845" docExpressionCount="831" docLength="8943" endLine="108" insertionLength="1" int_docASTNodeCount="1337" int_docActiveCodeLength="7844" int_docExpressionCount="831" int_docLength="8942" length="42" offset="4056" startLine="107" starttimestamp="1650226882502" timestamp="104738226">
    <deletedText><![CDATA[			table.openScope();
			table.enter(cd);]]></deletedText>
    <insertedText><![CDATA[=]]></insertedText>
  </DocumentChange>
  <Command __id="2736" _type="InsertStringCommand" date="Mon Apr 18 21:27:00 EDT 2022" starttimestamp="1650226882502" timestamp="104738234" timestamp2="104738234">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="2737" _type="InsertStringCommand" date="Mon Apr 18 21:27:00 EDT 2022" starttimestamp="1650226882502" timestamp="104738234" timestamp2="104738234">
    <data><![CDATA[=]]></data>
  </Command>
  <DocumentChange __id="2738" _type="Delete" date="Mon Apr 18 21:27:01 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7844" docExpressionCount="831" docLength="8942" endLine="107" length="1" offset="4056" startLine="107" starttimestamp="1650226882502" timestamp="104739152">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <Command __id="2739" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:01 EDT 2022" starttimestamp="1650226882502" timestamp="104739152" />
  <Command __id="2740" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:01 EDT 2022" starttimestamp="1650226882502" timestamp="104739152" />
  <DocumentChange __id="2741" _type="Delete" date="Mon Apr 18 21:27:02 EDT 2022" docASTNodeCount="1337" docActiveCodeLength="7842" docExpressionCount="831" docLength="8940" endLine="107" length="2" offset="4054" startLine="106" starttimestamp="1650226882502" timestamp="104739506">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="2742" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:02 EDT 2022" starttimestamp="1650226882502" timestamp="104739506" />
  <Command __id="2743" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:02 EDT 2022" starttimestamp="1650226882502" timestamp="104739506" />
  <Command __id="2744" _type="SelectTextCommand" caretOffset="4085" date="Mon Apr 18 21:27:02 EDT 2022" end="4104" start="4085" starttimestamp="1650226882502" timestamp="104740439" />
  <Command __id="2745" _type="SelectTextCommand" caretOffset="4085" date="Mon Apr 18 21:27:02 EDT 2022" end="4104" start="4085" starttimestamp="1650226882502" timestamp="104740446" />
  <Command __id="2746" _type="MoveCaretCommand" caretOffset="4101" date="Mon Apr 18 21:27:03 EDT 2022" docOffset="4101" starttimestamp="1650226882502" timestamp="104740832" />
  <Command __id="2747" _type="MoveCaretCommand" caretOffset="4101" date="Mon Apr 18 21:27:03 EDT 2022" docOffset="4101" starttimestamp="1650226882502" timestamp="104740832" />
  <Command __id="2748" _type="SelectTextCommand" caretOffset="4082" date="Mon Apr 18 21:27:04 EDT 2022" end="4104" start="4082" starttimestamp="1650226882502" timestamp="104741610" />
  <Command __id="2749" _type="SelectTextCommand" caretOffset="4082" date="Mon Apr 18 21:27:04 EDT 2022" end="4104" start="4082" starttimestamp="1650226882502" timestamp="104741614" />
  <DocumentChange __id="2750" _type="Delete" date="Mon Apr 18 21:27:04 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7820" docExpressionCount="828" docLength="8918" endLine="108" length="22" offset="4082" startLine="108" starttimestamp="1650226882502" timestamp="104741678">
    <text><![CDATA[			table.closeScope();]]></text>
  </DocumentChange>
  <Command __id="2751" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:04 EDT 2022" starttimestamp="1650226882502" timestamp="104741678" />
  <Command __id="2752" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:04 EDT 2022" starttimestamp="1650226882502" timestamp="104741678" />
  <DocumentChange __id="2753" _type="Delete" date="Mon Apr 18 21:27:04 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" endLine="108" length="2" offset="4080" startLine="107" starttimestamp="1650226882502" timestamp="104742011">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="2754" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:04 EDT 2022" starttimestamp="1650226882502" timestamp="104742011" />
  <Command __id="2755" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:27:04 EDT 2022" starttimestamp="1650226882502" timestamp="104742011" />
  <Command __id="2756" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:27:42 EDT 2022" docASTNodeCount="89" docActiveCodeLength="510" docExpressionCount="47" docLength="607" projectName="pa3" starttimestamp="1650226882502" timestamp="104779572">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\ClassDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import  miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class ClassDecl extends Declaration {¶¶  public ClassDecl(String cn, FieldDeclList fdl, MethodDeclList mdl, SourcePosition posn) {¶	  super(cn, null, posn);¶	  fieldDeclList = fdl;¶	  methodDeclList = mdl;¶  }¶  ¶  public <A,R> R visit(Visitor<A, R> v, A o) {¶      return v.visitClassDecl(this, o);¶  }¶      ¶  public FieldDeclList fieldDeclList;¶  public MethodDeclList methodDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="2757" _type="SelectTextCommand" caretOffset="159" date="Mon Apr 18 21:27:42 EDT 2022" end="159" start="150" starttimestamp="1650226882502" timestamp="104779618" />
  <Command __id="2759" _type="MoveCaretCommand" caretOffset="4316" date="Mon Apr 18 21:27:55 EDT 2022" docOffset="4316" starttimestamp="1650226882502" timestamp="104793037" />
  <Command __id="2760" _type="MoveCaretCommand" caretOffset="4316" date="Mon Apr 18 21:27:55 EDT 2022" docOffset="4316" starttimestamp="1650226882502" timestamp="104793056" />
  <Command __id="2761" _type="MoveCaretCommand" caretOffset="4181" date="Mon Apr 18 21:27:55 EDT 2022" docOffset="4181" starttimestamp="1650226882502" timestamp="104793390" />
  <Command __id="2762" _type="MoveCaretCommand" caretOffset="4181" date="Mon Apr 18 21:27:55 EDT 2022" docOffset="4181" starttimestamp="1650226882502" timestamp="104793390" />
  <Command __id="2763" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:27:57 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104794708" />
  <Command __id="2764" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:27:57 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104794710" />
  <Command __id="2765" _type="MoveCaretCommand" caretOffset="4239" date="Mon Apr 18 21:27:57 EDT 2022" docOffset="4239" starttimestamp="1650226882502" timestamp="104795040" />
  <Command __id="2766" _type="MoveCaretCommand" caretOffset="4239" date="Mon Apr 18 21:27:57 EDT 2022" docOffset="4239" starttimestamp="1650226882502" timestamp="104795046" />
  <Command __id="2767" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:05 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104803222" />
  <Command __id="2768" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:05 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104803230" />
  <Command __id="2769" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:09 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104807294" />
  <Command __id="2770" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:09 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104807302" />
  <Command __id="2771" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:10 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104807710" />
  <Command __id="2772" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:10 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104807718" />
  <Command __id="2773" _type="MoveCaretCommand" caretOffset="4293" date="Mon Apr 18 21:28:25 EDT 2022" docOffset="4293" starttimestamp="1650226882502" timestamp="104823040" />
  <Command __id="2774" _type="MoveCaretCommand" caretOffset="4293" date="Mon Apr 18 21:28:25 EDT 2022" docOffset="4293" starttimestamp="1650226882502" timestamp="104823046" />
  <Command __id="2775" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.LINE_UP" date="Mon Apr 18 21:28:32 EDT 2022" starttimestamp="1650226882502" timestamp="104830136" />
  <Command __id="2776" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.LINE_UP" date="Mon Apr 18 21:28:32 EDT 2022" starttimestamp="1650226882502" timestamp="104830136" />
  <Command __id="2777" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:28:33 EDT 2022" starttimestamp="1650226882502" timestamp="104830498" />
  <Command __id="2778" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" date="Mon Apr 18 21:28:33 EDT 2022" starttimestamp="1650226882502" timestamp="104830498" />
  <Command __id="2779" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:34 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104831652" />
  <Command __id="2780" _type="MoveCaretCommand" caretOffset="4271" date="Mon Apr 18 21:28:34 EDT 2022" docOffset="4271" starttimestamp="1650226882502" timestamp="104831662" />
  <Command __id="2782" _type="InsertStringCommand" date="Mon Apr 18 21:28:34 EDT 2022" starttimestamp="1650226882502" timestamp="104832153" timestamp2="104832153">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2783" _type="InsertStringCommand" date="Mon Apr 18 21:28:34 EDT 2022" starttimestamp="1650226882502" timestamp="104832153" timestamp2="104832153">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2785" _type="InsertStringCommand" date="Mon Apr 18 21:28:35 EDT 2022" starttimestamp="1650226882502" timestamp="104832753" timestamp2="104832753">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2786" _type="InsertStringCommand" date="Mon Apr 18 21:28:35 EDT 2022" starttimestamp="1650226882502" timestamp="104832753" timestamp2="104832753">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="2788" _type="InsertStringCommand" date="Mon Apr 18 21:28:35 EDT 2022" starttimestamp="1650226882502" timestamp="104832922" timestamp2="104832922">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="2789" _type="InsertStringCommand" date="Mon Apr 18 21:28:35 EDT 2022" starttimestamp="1650226882502" timestamp="104832922" timestamp2="104832922">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="2791" _type="InsertStringCommand" date="Mon Apr 18 21:28:35 EDT 2022" starttimestamp="1650226882502" timestamp="104833106" timestamp2="104833106">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="2792" _type="InsertStringCommand" date="Mon Apr 18 21:28:35 EDT 2022" starttimestamp="1650226882502" timestamp="104833106" timestamp2="104833106">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="2794" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104833498" timestamp2="104833498">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2795" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104833498" timestamp2="104833498">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2797" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104833701" timestamp2="104833701">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2798" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104833706" timestamp2="104833706">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2800" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104833869" timestamp2="104833869">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2801" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104833869" timestamp2="104833869">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2803" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104834023" timestamp2="104834023">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2804" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104834023" timestamp2="104834023">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2806" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104834138" timestamp2="104834138">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2807" _type="InsertStringCommand" date="Mon Apr 18 21:28:36 EDT 2022" starttimestamp="1650226882502" timestamp="104834138" timestamp2="104834138">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2809" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104834871" timestamp2="104834871">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="2810" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104834871" timestamp2="104834871">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="2812" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104834987" timestamp2="104834987">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2813" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104834987" timestamp2="104834987">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2758" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:27:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7818" docExpressionCount="828" docLength="8916" projectName="pa3" starttimestamp="1650226882502" timestamp="104792990">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			"), Diff(DELETE,"table.openScope();¶			table.enter(cd);¶			cd.visit(this, null);¶			table.closeScope("), Diff(INSERT,"cd.visit(this, null"), Diff(EQUAL,");¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		// scope 1
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enter(cd1);
		table.enter(cd2);
		table.enter(cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="2781" _type="Insert" date="Mon Apr 18 21:28:34 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7822" docExpressionCount="828" docLength="8920" length="4" offset="4271" starttimestamp="1650226882502" timestamp="104832153">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="2784" _type="Insert" date="Mon Apr 18 21:28:35 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8924" length="4" offset="4275" starttimestamp="1650226882502" timestamp="104832753">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="2787" _type="Insert" date="Mon Apr 18 21:28:35 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7827" docExpressionCount="828" docLength="8925" length="1" offset="4279" starttimestamp="1650226882502" timestamp="104832922">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <DocumentChange __id="2790" _type="Insert" date="Mon Apr 18 21:28:35 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8926" length="1" offset="4280" starttimestamp="1650226882502" timestamp="104833084">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <DocumentChange __id="2793" _type="Insert" date="Mon Apr 18 21:28:35 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8927" length="1" offset="4281" starttimestamp="1650226882502" timestamp="104833496">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2796" _type="Insert" date="Mon Apr 18 21:28:36 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8928" length="1" offset="4282" starttimestamp="1650226882502" timestamp="104833701">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="2799" _type="Insert" date="Mon Apr 18 21:28:36 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8929" length="1" offset="4283" starttimestamp="1650226882502" timestamp="104833869">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="2802" _type="Insert" date="Mon Apr 18 21:28:36 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8930" length="1" offset="4284" starttimestamp="1650226882502" timestamp="104834023">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="2805" _type="Insert" date="Mon Apr 18 21:28:36 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8931" length="1" offset="4285" starttimestamp="1650226882502" timestamp="104834138">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2808" _type="Insert" date="Mon Apr 18 21:28:37 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8932" length="1" offset="4286" starttimestamp="1650226882502" timestamp="104834871">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="2811" _type="Insert" date="Mon Apr 18 21:28:37 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8933" length="1" offset="4287" starttimestamp="1650226882502" timestamp="104834987">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2814" _type="Insert" date="Mon Apr 18 21:28:37 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8934" length="1" offset="4288" starttimestamp="1650226882502" timestamp="104835087">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="2817" _type="Insert" date="Mon Apr 18 21:28:37 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8935" length="1" offset="4289" starttimestamp="1650226882502" timestamp="104835341">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="2820" _type="Insert" date="Mon Apr 18 21:28:37 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8936" length="1" offset="4290" starttimestamp="1650226882502" timestamp="104835473">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="2823" _type="Insert" date="Mon Apr 18 21:28:38 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8937" length="1" offset="4291" starttimestamp="1650226882502" timestamp="104835610">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="2826" _type="Insert" date="Mon Apr 18 21:28:38 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8938" length="1" offset="4292" starttimestamp="1650226882502" timestamp="104835742">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="2829" _type="Insert" date="Mon Apr 18 21:28:38 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8939" length="1" offset="4293" starttimestamp="1650226882502" timestamp="104835889">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2832" _type="Insert" date="Mon Apr 18 21:28:38 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8940" length="1" offset="4294" starttimestamp="1650226882502" timestamp="104836111">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="2835" _type="Insert" date="Mon Apr 18 21:28:38 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8941" length="1" offset="4295" starttimestamp="1650226882502" timestamp="104836210">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="2838" _type="Insert" date="Mon Apr 18 21:28:38 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8942" length="1" offset="4296" starttimestamp="1650226882502" timestamp="104836326">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="2841" _type="Insert" date="Mon Apr 18 21:28:38 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8943" length="1" offset="4297" starttimestamp="1650226882502" timestamp="104836458">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="2844" _type="Insert" date="Mon Apr 18 21:28:39 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8944" length="1" offset="4298" starttimestamp="1650226882502" timestamp="104836589">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="2847" _type="Insert" date="Mon Apr 18 21:28:39 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8945" length="1" offset="4299" starttimestamp="1650226882502" timestamp="104836743">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2815" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104835087" timestamp2="104835087">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="2816" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104835087" timestamp2="104835087">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="2818" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104835357" timestamp2="104835357">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="2819" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104835357" timestamp2="104835357">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="2821" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104835488" timestamp2="104835488">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2822" _type="InsertStringCommand" date="Mon Apr 18 21:28:37 EDT 2022" starttimestamp="1650226882502" timestamp="104835488" timestamp2="104835488">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2824" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104835610" timestamp2="104835610">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2825" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104835610" timestamp2="104835610">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2827" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104835742" timestamp2="104835742">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2828" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104835757" timestamp2="104835757">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2830" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104835904" timestamp2="104835904">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2831" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104835904" timestamp2="104835904">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2833" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836111" timestamp2="104836111">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2834" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836111" timestamp2="104836111">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2836" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836226" timestamp2="104836226">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="2837" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836226" timestamp2="104836226">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="2839" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836342" timestamp2="104836342">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2840" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836342" timestamp2="104836342">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2842" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836473" timestamp2="104836473">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2843" _type="InsertStringCommand" date="Mon Apr 18 21:28:38 EDT 2022" starttimestamp="1650226882502" timestamp="104836473" timestamp2="104836473">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2845" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104836605" timestamp2="104836605">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2846" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104836605" timestamp2="104836605">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2848" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104836743" timestamp2="104836743">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2849" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104836743" timestamp2="104836743">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="2850" _type="Insert" date="Mon Apr 18 21:28:39 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8946" length="1" offset="4300" starttimestamp="1650226882502" timestamp="104836843">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2851" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104836843" timestamp2="104836843">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2852" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104836843" timestamp2="104836843">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2853" _type="Insert" date="Mon Apr 18 21:28:39 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8947" length="1" offset="4301" starttimestamp="1650226882502" timestamp="104837058">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <Command __id="2854" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837058" timestamp2="104837058">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="2855" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837058" timestamp2="104837058">
    <data><![CDATA[f]]></data>
  </Command>
  <DocumentChange __id="2856" _type="Insert" date="Mon Apr 18 21:28:39 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8948" length="1" offset="4302" starttimestamp="1650226882502" timestamp="104837127">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="2857" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837127" timestamp2="104837127">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2858" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837127" timestamp2="104837127">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="2859" _type="Insert" date="Mon Apr 18 21:28:39 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8949" length="1" offset="4303" starttimestamp="1650226882502" timestamp="104837274">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2860" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837274" timestamp2="104837274">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2861" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837274" timestamp2="104837274">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="2862" _type="Insert" date="Mon Apr 18 21:28:39 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8950" length="1" offset="4304" starttimestamp="1650226882502" timestamp="104837406">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2863" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837412" timestamp2="104837412">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2864" _type="InsertStringCommand" date="Mon Apr 18 21:28:39 EDT 2022" starttimestamp="1650226882502" timestamp="104837412" timestamp2="104837412">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2865" _type="Delete" date="Mon Apr 18 21:28:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8949" endLine="118" length="1" offset="4304" startLine="118" starttimestamp="1650226882502" timestamp="104837590">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2866" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837606" />
  <Command __id="2867" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837606" />
  <DocumentChange __id="2868" _type="Delete" date="Mon Apr 18 21:28:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8948" endLine="118" length="1" offset="4303" startLine="118" starttimestamp="1650226882502" timestamp="104837712">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2869" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837712" />
  <Command __id="2870" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837712" />
  <DocumentChange __id="2871" _type="Insert" date="Mon Apr 18 21:28:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8949" length="1" offset="4303" starttimestamp="1650226882502" timestamp="104837813">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2872" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837813" timestamp2="104837813">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2873" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837828" timestamp2="104837828">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2874" _type="Insert" date="Mon Apr 18 21:28:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8950" length="1" offset="4304" starttimestamp="1650226882502" timestamp="104837929">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="2875" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837944" timestamp2="104837944">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="2876" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104837944" timestamp2="104837944">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="2877" _type="Insert" date="Mon Apr 18 21:28:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8951" length="1" offset="4305" starttimestamp="1650226882502" timestamp="104838013">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2878" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104838013" timestamp2="104838013">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2879" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104838013" timestamp2="104838013">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="2880" _type="Insert" date="Mon Apr 18 21:28:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8952" length="1" offset="4306" starttimestamp="1650226882502" timestamp="104838292">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="2881" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104838292" timestamp2="104838292">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2882" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104838292" timestamp2="104838292">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="2883" _type="Insert" date="Mon Apr 18 21:28:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8953" length="1" offset="4307" starttimestamp="1650226882502" timestamp="104838435">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2884" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104838444" timestamp2="104838444">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2885" _type="InsertStringCommand" date="Mon Apr 18 21:28:40 EDT 2022" starttimestamp="1650226882502" timestamp="104838444" timestamp2="104838444">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2886" _type="Insert" date="Mon Apr 18 21:28:41 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8954" length="1" offset="4308" starttimestamp="1650226882502" timestamp="104838714">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="2887" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104838714" timestamp2="104838714">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2888" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104838714" timestamp2="104838714">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="2889" _type="Insert" date="Mon Apr 18 21:28:41 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8955" length="1" offset="4309" starttimestamp="1650226882502" timestamp="104838846">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="2890" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104838846" timestamp2="104838846">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2891" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104838846" timestamp2="104838846">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="2892" _type="Insert" date="Mon Apr 18 21:28:41 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8956" length="1" offset="4310" starttimestamp="1650226882502" timestamp="104838946">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2893" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104838961" timestamp2="104838961">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2894" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104838961" timestamp2="104838961">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2895" _type="Insert" date="Mon Apr 18 21:28:41 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8957" length="1" offset="4311" starttimestamp="1650226882502" timestamp="104839109">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2896" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104839109" timestamp2="104839109">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2897" _type="InsertStringCommand" date="Mon Apr 18 21:28:41 EDT 2022" starttimestamp="1650226882502" timestamp="104839109" timestamp2="104839109">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2898" _type="Delete" date="Mon Apr 18 21:28:42 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8956" endLine="118" length="1" offset="4311" startLine="118" starttimestamp="1650226882502" timestamp="104840117">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2899" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="104840117" />
  <Command __id="2900" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="104840117" />
  <DocumentChange __id="2901" _type="Insert" date="Mon Apr 18 21:28:42 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8957" length="1" offset="4311" starttimestamp="1650226882502" timestamp="104840318">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="2902" _type="InsertStringCommand" date="Mon Apr 18 21:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="104840318" timestamp2="104840318">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2903" _type="InsertStringCommand" date="Mon Apr 18 21:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="104840318" timestamp2="104840318">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="2904" _type="Insert" date="Mon Apr 18 21:28:42 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8958" length="1" offset="4312" starttimestamp="1650226882502" timestamp="104840465">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="2905" _type="InsertStringCommand" date="Mon Apr 18 21:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="104840465" timestamp2="104840465">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="2906" _type="InsertStringCommand" date="Mon Apr 18 21:28:42 EDT 2022" starttimestamp="1650226882502" timestamp="104840465" timestamp2="104840465">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="2907" _type="Insert" date="Mon Apr 18 21:28:43 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8959" length="1" offset="4313" starttimestamp="1650226882502" timestamp="104840565">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2908" _type="InsertStringCommand" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104840565" timestamp2="104840565">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2909" _type="InsertStringCommand" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104840565" timestamp2="104840565">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="2910" _type="Delete" date="Mon Apr 18 21:28:43 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8958" endLine="118" length="1" offset="4313" startLine="118" starttimestamp="1650226882502" timestamp="104840835">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2911" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104840835" />
  <Command __id="2912" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104840835" />
  <DocumentChange __id="2913" _type="Delete" date="Mon Apr 18 21:28:43 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8957" endLine="118" length="1" offset="4312" startLine="118" starttimestamp="1650226882502" timestamp="104840997">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="2914" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104840997" />
  <Command __id="2915" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104840997" />
  <DocumentChange __id="2916" _type="Delete" date="Mon Apr 18 21:28:43 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8956" endLine="118" length="1" offset="4311" startLine="118" starttimestamp="1650226882502" timestamp="104841167">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="2917" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104841167" />
  <Command __id="2918" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104841167" />
  <DocumentChange __id="2919" _type="Delete" date="Mon Apr 18 21:28:43 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8955" endLine="118" length="1" offset="4310" startLine="118" starttimestamp="1650226882502" timestamp="104841351">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2920" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104841351" />
  <Command __id="2921" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:43 EDT 2022" starttimestamp="1650226882502" timestamp="104841351" />
  <DocumentChange __id="2922" _type="Delete" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8954" endLine="118" length="1" offset="4309" startLine="118" starttimestamp="1650226882502" timestamp="104841498">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="2923" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841498" />
  <Command __id="2924" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841513" />
  <DocumentChange __id="2925" _type="Insert" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8955" length="1" offset="4309" starttimestamp="1650226882502" timestamp="104841699">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="2926" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841699" timestamp2="104841699">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="2927" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841699" timestamp2="104841699">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="2928" _type="Insert" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8956" length="1" offset="4310" starttimestamp="1650226882502" timestamp="104841767">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2929" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841783" timestamp2="104841783">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2930" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841783" timestamp2="104841783">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="2931" _type="Insert" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8957" length="1" offset="4311" starttimestamp="1650226882502" timestamp="104841868">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2932" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841868" timestamp2="104841868">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2933" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104841868" timestamp2="104841868">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2934" _type="Insert" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8958" length="1" offset="4312" starttimestamp="1650226882502" timestamp="104842084">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="2935" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842084" timestamp2="104842084">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="2936" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842084" timestamp2="104842084">
    <data><![CDATA[m]]></data>
  </Command>
  <DocumentChange __id="2937" _type="Insert" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8959" length="1" offset="4313" starttimestamp="1650226882502" timestamp="104842169">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2938" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842184" timestamp2="104842184">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2939" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842184" timestamp2="104842184">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2940" _type="Insert" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8960" length="1" offset="4314" starttimestamp="1650226882502" timestamp="104842385">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="2941" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842385" timestamp2="104842385">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="2942" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842385" timestamp2="104842385">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="2943" _type="Insert" date="Mon Apr 18 21:28:44 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8961" length="1" offset="4315" starttimestamp="1650226882502" timestamp="104842485">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <Command __id="2944" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842485" timestamp2="104842485">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="2945" _type="InsertStringCommand" date="Mon Apr 18 21:28:44 EDT 2022" starttimestamp="1650226882502" timestamp="104842485" timestamp2="104842485">
    <data><![CDATA[h]]></data>
  </Command>
  <DocumentChange __id="2946" _type="Insert" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8962" length="1" offset="4316" starttimestamp="1650226882502" timestamp="104842585">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="2947" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104842600" timestamp2="104842600">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="2948" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104842600" timestamp2="104842600">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="2949" _type="Insert" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8963" length="1" offset="4317" starttimestamp="1650226882502" timestamp="104842738">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="2950" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104842738" timestamp2="104842738">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2951" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104842738" timestamp2="104842738">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="2952" _type="Insert" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8964" length="1" offset="4318" starttimestamp="1650226882502" timestamp="104842800">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2953" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104842816" timestamp2="104842816">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2954" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104842816" timestamp2="104842816">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="2955" _type="Delete" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8963" endLine="118" length="1" offset="4318" startLine="118" starttimestamp="1650226882502" timestamp="104842985">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2956" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843001" />
  <Command __id="2957" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843001" />
  <DocumentChange __id="2958" _type="Delete" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8962" endLine="118" length="1" offset="4317" startLine="118" starttimestamp="1650226882502" timestamp="104843154">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="2959" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843154" />
  <Command __id="2960" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843154" />
  <DocumentChange __id="2961" _type="Insert" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8963" length="1" offset="4317" starttimestamp="1650226882502" timestamp="104843238">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="2962" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843238" timestamp2="104843238">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="2963" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843238" timestamp2="104843238">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="2964" _type="Insert" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8964" length="1" offset="4318" starttimestamp="1650226882502" timestamp="104843270">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="2965" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843270" timestamp2="104843270">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2966" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843270" timestamp2="104843270">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="2967" _type="Insert" date="Mon Apr 18 21:28:45 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8965" length="1" offset="4319" starttimestamp="1650226882502" timestamp="104843457">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2968" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843461" timestamp2="104843461">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2969" _type="InsertStringCommand" date="Mon Apr 18 21:28:45 EDT 2022" starttimestamp="1650226882502" timestamp="104843461" timestamp2="104843461">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2970" _type="Insert" date="Mon Apr 18 21:28:46 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8966" length="1" offset="4320" starttimestamp="1650226882502" timestamp="104843562">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="2971" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104843565" timestamp2="104843565">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="2972" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104843565" timestamp2="104843565">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="2973" _type="Insert" date="Mon Apr 18 21:28:46 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8967" length="1" offset="4321" starttimestamp="1650226882502" timestamp="104843839">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="2974" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104843839" timestamp2="104843839">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="2975" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104843839" timestamp2="104843839">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="2976" _type="Insert" date="Mon Apr 18 21:28:46 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8968" length="1" offset="4322" starttimestamp="1650226882502" timestamp="104843970">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="2977" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104843986" timestamp2="104843986">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="2978" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104843986" timestamp2="104843986">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="2979" _type="Insert" date="Mon Apr 18 21:28:46 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8969" length="1" offset="4323" starttimestamp="1650226882502" timestamp="104844186">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="2980" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104844186" timestamp2="104844186">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="2981" _type="InsertStringCommand" date="Mon Apr 18 21:28:46 EDT 2022" starttimestamp="1650226882502" timestamp="104844186" timestamp2="104844186">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="2982" _type="Insert" date="Mon Apr 18 21:28:47 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8970" length="1" offset="4324" starttimestamp="1650226882502" timestamp="104844971">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="2983" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104844971" timestamp2="104844971">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="2984" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104844971" timestamp2="104844971">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="2985" _type="Insert" date="Mon Apr 18 21:28:47 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8971" length="1" offset="4325" starttimestamp="1650226882502" timestamp="104845072">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="2986" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845072" timestamp2="104845072">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2987" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845072" timestamp2="104845072">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="2988" _type="Insert" date="Mon Apr 18 21:28:47 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8972" length="1" offset="4326" starttimestamp="1650226882502" timestamp="104845187">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="2989" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845203" timestamp2="104845203">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="2990" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845203" timestamp2="104845203">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="2991" _type="Insert" date="Mon Apr 18 21:28:47 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8973" length="1" offset="4327" starttimestamp="1650226882502" timestamp="104845256">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="2992" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845272" timestamp2="104845272">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="2993" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845272" timestamp2="104845272">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="2994" _type="Insert" date="Mon Apr 18 21:28:47 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8974" length="1" offset="4328" starttimestamp="1650226882502" timestamp="104845341">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="2995" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845341" timestamp2="104845341">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="2996" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845341" timestamp2="104845341">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="2997" _type="Insert" date="Mon Apr 18 21:28:47 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8975" length="1" offset="4329" starttimestamp="1650226882502" timestamp="104845457">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="2998" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845457" timestamp2="104845457">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="2999" _type="InsertStringCommand" date="Mon Apr 18 21:28:47 EDT 2022" starttimestamp="1650226882502" timestamp="104845457" timestamp2="104845457">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="3000" _type="Delete" date="Mon Apr 18 21:28:48 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8974" endLine="118" length="1" offset="4329" startLine="118" starttimestamp="1650226882502" timestamp="104845889">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="3001" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:48 EDT 2022" starttimestamp="1650226882502" timestamp="104845889" />
  <Command __id="3002" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:48 EDT 2022" starttimestamp="1650226882502" timestamp="104845889" />
  <DocumentChange __id="3003" _type="Delete" date="Mon Apr 18 21:28:48 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8973" endLine="118" length="1" offset="4328" startLine="118" starttimestamp="1650226882502" timestamp="104846026">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="3004" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:48 EDT 2022" starttimestamp="1650226882502" timestamp="104846026" />
  <Command __id="3005" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:48 EDT 2022" starttimestamp="1650226882502" timestamp="104846026" />
  <DocumentChange __id="3006" _type="Insert" date="Mon Apr 18 21:28:48 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8974" length="1" offset="4328" starttimestamp="1650226882502" timestamp="104846042">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <Command __id="3007" _type="InsertStringCommand" date="Mon Apr 18 21:28:48 EDT 2022" starttimestamp="1650226882502" timestamp="104846042" timestamp2="104846042">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="3008" _type="InsertStringCommand" date="Mon Apr 18 21:28:48 EDT 2022" starttimestamp="1650226882502" timestamp="104846042" timestamp2="104846042">
    <data><![CDATA[b]]></data>
  </Command>
  <DocumentChange __id="3009" _type="Insert" date="Mon Apr 18 21:28:49 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8975" length="1" offset="4329" starttimestamp="1650226882502" timestamp="104846574">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="3010" _type="InsertStringCommand" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104846574" timestamp2="104846574">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="3011" _type="InsertStringCommand" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104846574" timestamp2="104846574">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="3012" _type="Insert" date="Mon Apr 18 21:28:49 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8976" length="1" offset="4330" starttimestamp="1650226882502" timestamp="104846590">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <Command __id="3013" _type="InsertStringCommand" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104846590" timestamp2="104846590">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="3014" _type="InsertStringCommand" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104846590" timestamp2="104846590">
    <data><![CDATA[k]]></data>
  </Command>
  <DocumentChange __id="3015" _type="Insert" date="Mon Apr 18 21:28:49 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8977" length="1" offset="4331" starttimestamp="1650226882502" timestamp="104846690">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="3016" _type="InsertStringCommand" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104846690" timestamp2="104846690">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3017" _type="InsertStringCommand" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104846690" timestamp2="104846690">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="3018" _type="Delete" date="Mon Apr 18 21:28:49 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8976" endLine="118" length="1" offset="4331" startLine="118" starttimestamp="1650226882502" timestamp="104847391">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="3019" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104847391" />
  <Command __id="3020" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:49 EDT 2022" starttimestamp="1650226882502" timestamp="104847391" />
  <DocumentChange __id="3021" _type="Delete" date="Mon Apr 18 21:28:50 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8975" endLine="118" length="1" offset="4330" startLine="118" starttimestamp="1650226882502" timestamp="104847522">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <Command __id="3022" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:50 EDT 2022" starttimestamp="1650226882502" timestamp="104847528" />
  <Command __id="3023" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:50 EDT 2022" starttimestamp="1650226882502" timestamp="104847528" />
  <DocumentChange __id="3024" _type="Insert" date="Mon Apr 18 21:28:50 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7826" docExpressionCount="828" docLength="8976" length="1" offset="4330" starttimestamp="1650226882502" timestamp="104847575">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="3025" _type="InsertStringCommand" date="Mon Apr 18 21:28:50 EDT 2022" starttimestamp="1650226882502" timestamp="104847575" timestamp2="104847575">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3026" _type="InsertStringCommand" date="Mon Apr 18 21:28:50 EDT 2022" starttimestamp="1650226882502" timestamp="104847575" timestamp2="104847575">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3027" _type="MoveCaretCommand" caretOffset="4487" date="Mon Apr 18 21:28:51 EDT 2022" docOffset="4487" starttimestamp="1650226882502" timestamp="104848557" />
  <Command __id="3028" _type="MoveCaretCommand" caretOffset="4487" date="Mon Apr 18 21:28:51 EDT 2022" docOffset="4487" starttimestamp="1650226882502" timestamp="104848557" />
  <Command __id="3029" _type="MoveCaretCommand" caretOffset="4493" date="Mon Apr 18 21:28:51 EDT 2022" docOffset="4493" starttimestamp="1650226882502" timestamp="104848877" />
  <Command __id="3030" _type="MoveCaretCommand" caretOffset="4493" date="Mon Apr 18 21:28:51 EDT 2022" docOffset="4493" starttimestamp="1650226882502" timestamp="104848886" />
  <DocumentChange __id="3031" _type="Insert" date="Mon Apr 18 21:28:53 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8980" length="4" offset="4493" starttimestamp="1650226882502" timestamp="104851064">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="3032" _type="InsertStringCommand" date="Mon Apr 18 21:28:53 EDT 2022" starttimestamp="1650226882502" timestamp="104851064" timestamp2="104851064">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="3033" _type="InsertStringCommand" date="Mon Apr 18 21:28:53 EDT 2022" starttimestamp="1650226882502" timestamp="104851064" timestamp2="104851064">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="3034" _type="Insert" date="Mon Apr 18 21:28:54 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7831" docExpressionCount="828" docLength="8981" length="1" offset="4497" starttimestamp="1650226882502" timestamp="104851843">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <Command __id="3035" _type="InsertStringCommand" date="Mon Apr 18 21:28:54 EDT 2022" starttimestamp="1650226882502" timestamp="104851843" timestamp2="104851843">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="3036" _type="InsertStringCommand" date="Mon Apr 18 21:28:54 EDT 2022" starttimestamp="1650226882502" timestamp="104851843" timestamp2="104851843">
    <data><![CDATA[/]]></data>
  </Command>
  <DocumentChange __id="3037" _type="Insert" date="Mon Apr 18 21:28:54 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8982" length="1" offset="4498" starttimestamp="1650226882502" timestamp="104851959">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <Command __id="3038" _type="InsertStringCommand" date="Mon Apr 18 21:28:54 EDT 2022" starttimestamp="1650226882502" timestamp="104851974" timestamp2="104851974">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="3039" _type="InsertStringCommand" date="Mon Apr 18 21:28:54 EDT 2022" starttimestamp="1650226882502" timestamp="104851974" timestamp2="104851974">
    <data><![CDATA[/]]></data>
  </Command>
  <DocumentChange __id="3040" _type="Insert" date="Mon Apr 18 21:28:54 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8983" length="1" offset="4499" starttimestamp="1650226882502" timestamp="104852391">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="3041" _type="InsertStringCommand" date="Mon Apr 18 21:28:54 EDT 2022" starttimestamp="1650226882502" timestamp="104852391" timestamp2="104852391">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="3042" _type="InsertStringCommand" date="Mon Apr 18 21:28:54 EDT 2022" starttimestamp="1650226882502" timestamp="104852391" timestamp2="104852391">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="3043" _type="Insert" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8984" length="1" offset="4500" starttimestamp="1650226882502" timestamp="104852513">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="3044" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852513" timestamp2="104852513">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3045" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852513" timestamp2="104852513">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="3046" _type="Delete" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8983" endLine="127" length="1" offset="4500" startLine="127" starttimestamp="1650226882502" timestamp="104852713">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="3047" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852713" />
  <Command __id="3048" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852713" />
  <DocumentChange __id="3049" _type="Delete" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8982" endLine="127" length="1" offset="4499" startLine="127" starttimestamp="1650226882502" timestamp="104852844">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="3050" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852844" />
  <Command __id="3051" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852844" />
  <DocumentChange __id="3052" _type="Insert" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8983" length="1" offset="4499" starttimestamp="1650226882502" timestamp="104852928">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="3053" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852944" timestamp2="104852944">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3054" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104852944" timestamp2="104852944">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="3055" _type="Insert" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8984" length="1" offset="4500" starttimestamp="1650226882502" timestamp="104853006">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="3056" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853013" timestamp2="104853013">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="3057" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853013" timestamp2="104853013">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="3058" _type="Insert" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8985" length="1" offset="4501" starttimestamp="1650226882502" timestamp="104853129">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="3059" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853129" timestamp2="104853129">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="3060" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853129" timestamp2="104853129">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="3061" _type="Insert" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8986" length="1" offset="4502" starttimestamp="1650226882502" timestamp="104853213">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="3062" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853213" timestamp2="104853213">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="3063" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853213" timestamp2="104853213">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="3064" _type="Insert" date="Mon Apr 18 21:28:55 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8987" length="1" offset="4503" starttimestamp="1650226882502" timestamp="104853378">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="3065" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853381" timestamp2="104853381">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="3066" _type="InsertStringCommand" date="Mon Apr 18 21:28:55 EDT 2022" starttimestamp="1650226882502" timestamp="104853381" timestamp2="104853381">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="3067" _type="Insert" date="Mon Apr 18 21:28:56 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8988" length="1" offset="4504" starttimestamp="1650226882502" timestamp="104853877">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="3068" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104853892" timestamp2="104853892">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="3069" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104853892" timestamp2="104853892">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="3070" _type="Insert" date="Mon Apr 18 21:28:56 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8989" length="1" offset="4505" starttimestamp="1650226882502" timestamp="104854077">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="3071" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104854108" timestamp2="104854108">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3072" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104854108" timestamp2="104854108">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="3073" _type="Insert" date="Mon Apr 18 21:28:56 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8990" length="1" offset="4506" starttimestamp="1650226882502" timestamp="104854330">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="3074" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104854330" timestamp2="104854330">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="3075" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104854330" timestamp2="104854330">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="3076" _type="Insert" date="Mon Apr 18 21:28:56 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8991" length="1" offset="4507" starttimestamp="1650226882502" timestamp="104854415">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="3077" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104854431" timestamp2="104854431">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="3078" _type="InsertStringCommand" date="Mon Apr 18 21:28:56 EDT 2022" starttimestamp="1650226882502" timestamp="104854431" timestamp2="104854431">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="3079" _type="Insert" date="Mon Apr 18 21:28:57 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8992" length="1" offset="4508" starttimestamp="1650226882502" timestamp="104854547">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="3080" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854547" timestamp2="104854547">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="3081" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854547" timestamp2="104854547">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="3082" _type="Insert" date="Mon Apr 18 21:28:57 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8993" length="1" offset="4509" starttimestamp="1650226882502" timestamp="104854678">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="3083" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854678" timestamp2="104854678">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3084" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854678" timestamp2="104854678">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="3085" _type="Insert" date="Mon Apr 18 21:28:57 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8994" length="1" offset="4510" starttimestamp="1650226882502" timestamp="104854862">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="3086" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854862" timestamp2="104854862">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="3087" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854862" timestamp2="104854862">
    <data><![CDATA[m]]></data>
  </Command>
  <DocumentChange __id="3088" _type="Insert" date="Mon Apr 18 21:28:57 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8995" length="1" offset="4511" starttimestamp="1650226882502" timestamp="104854931">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="3089" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854931" timestamp2="104854931">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3090" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104854931" timestamp2="104854931">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="3091" _type="Insert" date="Mon Apr 18 21:28:57 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8996" length="1" offset="4512" starttimestamp="1650226882502" timestamp="104855047">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="3092" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104855047" timestamp2="104855047">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="3093" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104855047" timestamp2="104855047">
    <data><![CDATA[m]]></data>
  </Command>
  <DocumentChange __id="3094" _type="Insert" date="Mon Apr 18 21:28:57 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8997" length="1" offset="4513" starttimestamp="1650226882502" timestamp="104855310">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <Command __id="3095" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104855316" timestamp2="104855316">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="3096" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104855316" timestamp2="104855316">
    <data><![CDATA[b]]></data>
  </Command>
  <DocumentChange __id="3097" _type="Insert" date="Mon Apr 18 21:28:57 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8998" length="1" offset="4514" starttimestamp="1650226882502" timestamp="104855463">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="3098" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104855463" timestamp2="104855463">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3099" _type="InsertStringCommand" date="Mon Apr 18 21:28:57 EDT 2022" starttimestamp="1650226882502" timestamp="104855463" timestamp2="104855463">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="3100" _type="Insert" date="Mon Apr 18 21:28:58 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="8999" length="1" offset="4515" starttimestamp="1650226882502" timestamp="104855563">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="3101" _type="InsertStringCommand" date="Mon Apr 18 21:28:58 EDT 2022" starttimestamp="1650226882502" timestamp="104855563" timestamp2="104855563">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="3102" _type="InsertStringCommand" date="Mon Apr 18 21:28:58 EDT 2022" starttimestamp="1650226882502" timestamp="104855563" timestamp2="104855563">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="3103" _type="Insert" date="Mon Apr 18 21:28:58 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="9000" length="1" offset="4516" starttimestamp="1650226882502" timestamp="104855664">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="3104" _type="InsertStringCommand" date="Mon Apr 18 21:28:58 EDT 2022" starttimestamp="1650226882502" timestamp="104855679" timestamp2="104855679">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="3105" _type="InsertStringCommand" date="Mon Apr 18 21:28:58 EDT 2022" starttimestamp="1650226882502" timestamp="104855679" timestamp2="104855679">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="3107" _type="SelectTextCommand" caretOffset="158" date="Mon Apr 18 21:29:58 EDT 2022" end="158" start="149" starttimestamp="1650226882502" timestamp="104916082" />
  <Command __id="3106" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:29:58 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="104915966">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="3108" _type="MoveCaretCommand" caretOffset="323" date="Mon Apr 18 21:30:36 EDT 2022" docOffset="380" starttimestamp="1650226882502" timestamp="104954313" />
  <Command __id="3109" _type="MoveCaretCommand" caretOffset="323" date="Mon Apr 18 21:30:36 EDT 2022" docOffset="380" starttimestamp="1650226882502" timestamp="104954318" />
  <Command __id="3110" _type="MoveCaretCommand" caretOffset="312" date="Mon Apr 18 21:30:37 EDT 2022" docOffset="369" starttimestamp="1650226882502" timestamp="104954694" />
  <Command __id="3111" _type="MoveCaretCommand" caretOffset="312" date="Mon Apr 18 21:30:37 EDT 2022" docOffset="369" starttimestamp="1650226882502" timestamp="104954694" />
  <Command __id="3112" _type="MoveCaretCommand" caretOffset="210" date="Mon Apr 18 21:30:37 EDT 2022" docOffset="267" starttimestamp="1650226882502" timestamp="104955030" />
  <Command __id="3113" _type="MoveCaretCommand" caretOffset="210" date="Mon Apr 18 21:30:37 EDT 2022" docOffset="267" starttimestamp="1650226882502" timestamp="104955038" />
  <Command __id="3114" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:30:51 EDT 2022" docASTNodeCount="65" docActiveCodeLength="367" docExpressionCount="34" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="104969203">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Declaration.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public abstract class Declaration extends AST {¶	public Declaration decl;¶	¶	public Declaration(String name, TypeDenoter type, SourcePosition posn) {¶		super(posn);¶		this.name = name;¶		this.type = type;¶	}¶	¶	public String name;¶	public TypeDenoter type;¶}¶")]]]></diff>
  </Command>
  <Command __id="3115" _type="SelectTextCommand" caretOffset="169" date="Mon Apr 18 21:30:51 EDT 2022" end="169" start="158" starttimestamp="1650226882502" timestamp="104969367" />
  <Command __id="3116" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:31:01 EDT 2022" docASTNodeCount="218" docActiveCodeLength="1404" docExpressionCount="152" docLength="1404" projectName="pa3" starttimestamp="1650226882502" timestamp="104979343">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\Compiler.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava;¶¶import java.io.FileInputStream;¶import java.io.FileNotFoundException;¶import java.io.InputStream;¶¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ASTDisplay;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.ContextualAnalyzer.Identification;¶import miniJava.SyntacticAnalyzer.Parser;¶import miniJava.SyntacticAnalyzer.Scanner;¶¶public class Compiler {¶	public static void main(String[] args) {¶		InputStream inputStream = null;¶		try {¶			inputStream = new FileInputStream(args[0]);¶		} catch (FileNotFoundException e) {¶			System.out.println("Input file " + args[0] + " not found");¶			System.exit(3);¶		}¶		¶		ErrorReporter errorReporter = new ErrorReporter();¶		Scanner scanner = new Scanner(inputStream, errorReporter);¶		Parser parser = new Parser(scanner, errorReporter);¶		¶		System.out.println("Syntactic analysis ... ");¶		Package ast = (Package) parser.parse();¶		System.out.print("Sytactic analysis complete: ");¶		if (errorReporter.hasErrors()) {¶			System.out.println("Invalid miniJava program");¶			System.exit(4);¶		}¶		else {¶			System.out.println("Valid miniJava program");¶			new ASTDisplay().showTree(ast);¶		}¶		¶		System.out.println("Starting contextual analysis...");¶		Identification id = new Identification(ast, errorReporter);¶		¶		¶		¶		¶		¶		System.exit(0);¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="3117" _type="MoveCaretCommand" caretOffset="643" date="Mon Apr 18 21:31:01 EDT 2022" docOffset="643" starttimestamp="1650226882502" timestamp="104979405" />
  <Command __id="3118" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:31:03 EDT 2022" docASTNodeCount="89" docActiveCodeLength="510" docExpressionCount="47" docLength="607" projectName="pa3" starttimestamp="1650226882502" timestamp="104980735">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\ClassDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import  miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class ClassDecl extends Declaration {¶¶  public ClassDecl(String cn, FieldDeclList fdl, MethodDeclList mdl, SourcePosition posn) {¶	  super(cn, null, posn);¶	  fieldDeclList = fdl;¶	  methodDeclList = mdl;¶  }¶  ¶  public <A,R> R visit(Visitor<A, R> v, A o) {¶      return v.visitClassDecl(this, o);¶  }¶      ¶  public FieldDeclList fieldDeclList;¶  public MethodDeclList methodDeclList;¶}¶")]]]></diff>
  </Command>
  <Command __id="3119" _type="SelectTextCommand" caretOffset="159" date="Mon Apr 18 21:31:03 EDT 2022" end="159" start="150" starttimestamp="1650226882502" timestamp="104980782" />
  <Command __id="3120" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:31:03 EDT 2022" docASTNodeCount="88" docActiveCodeLength="513" docExpressionCount="46" docLength="610" projectName="pa3" starttimestamp="1650226882502" timestamp="104981142">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MethodDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class MethodDecl extends MemberDecl {¶	¶	public MethodDecl(MemberDecl md, ParameterDeclList pl, StatementList sl, SourcePosition posn){¶    super(md,posn);¶    parameterDeclList = pl;¶    statementList = sl;¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitMethodDecl(this, o);¶    }¶	¶	public ParameterDeclList parameterDeclList;¶	public StatementList statementList;¶}¶")]]]></diff>
  </Command>
  <Command __id="3121" _type="MoveCaretCommand" caretOffset="365" date="Mon Apr 18 21:31:03 EDT 2022" docOffset="422" starttimestamp="1650226882502" timestamp="104981205" />
  <Command __id="3122" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:31:04 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="104981574">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="3123" _type="MoveCaretCommand" caretOffset="210" date="Mon Apr 18 21:31:04 EDT 2022" docOffset="267" starttimestamp="1650226882502" timestamp="104981621" />
  <Command __id="3125" _type="SelectTextCommand" caretOffset="4836" date="Mon Apr 18 21:31:23 EDT 2022" end="4836" start="4835" starttimestamp="1650226882502" timestamp="105001274" />
  <Command __id="3126" _type="SelectTextCommand" caretOffset="4807" date="Mon Apr 18 21:31:24 EDT 2022" end="4835" start="4807" starttimestamp="1650226882502" timestamp="105001766" />
  <Command __id="3127" _type="SelectTextCommand" caretOffset="4807" date="Mon Apr 18 21:31:24 EDT 2022" end="4835" start="4807" starttimestamp="1650226882502" timestamp="105001766" />
  <Command __id="3128" _type="MoveCaretCommand" caretOffset="4863" date="Mon Apr 18 21:31:24 EDT 2022" docOffset="4863" starttimestamp="1650226882502" timestamp="105002154" />
  <Command __id="3129" _type="MoveCaretCommand" caretOffset="4863" date="Mon Apr 18 21:31:24 EDT 2022" docOffset="4863" starttimestamp="1650226882502" timestamp="105002166" />
  <Command __id="3124" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:31:23 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="9000" projectName="pa3" starttimestamp="1650226882502" timestamp="105001205">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		"), Diff(INSERT,"¶		// add members so all fields and methods are visible¶		"), Diff(EQUAL,"table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		"), Diff(INSERT,"// visit all members¶		"), Diff(EQUAL,"for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.ArrayType;
import miniJava.AbstractSyntaxTrees.AssignStmt;
import miniJava.AbstractSyntaxTrees.BaseType;
import miniJava.AbstractSyntaxTrees.BinaryExpr;
import miniJava.AbstractSyntaxTrees.BlockStmt;
import miniJava.AbstractSyntaxTrees.BooleanLiteral;
import miniJava.AbstractSyntaxTrees.CallExpr;
import miniJava.AbstractSyntaxTrees.CallStmt;
import miniJava.AbstractSyntaxTrees.ClassDecl;
import miniJava.AbstractSyntaxTrees.ClassType;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;
import miniJava.AbstractSyntaxTrees.FieldDeclList;
import miniJava.AbstractSyntaxTrees.IdRef;
import miniJava.AbstractSyntaxTrees.Identifier;
import miniJava.AbstractSyntaxTrees.IfStmt;
import miniJava.AbstractSyntaxTrees.IntLiteral;
import miniJava.AbstractSyntaxTrees.IxAssignStmt;
import miniJava.AbstractSyntaxTrees.IxExpr;
import miniJava.AbstractSyntaxTrees.LiteralExpr;
import miniJava.AbstractSyntaxTrees.MethodDecl;
import miniJava.AbstractSyntaxTrees.MethodDeclList;
import miniJava.AbstractSyntaxTrees.NewArrayExpr;
import miniJava.AbstractSyntaxTrees.NewObjectExpr;
import miniJava.AbstractSyntaxTrees.Operator;
import miniJava.AbstractSyntaxTrees.ParameterDecl;
import miniJava.AbstractSyntaxTrees.ParameterDeclList;
import miniJava.AbstractSyntaxTrees.QualRef;
import miniJava.AbstractSyntaxTrees.RefExpr;
import miniJava.AbstractSyntaxTrees.ReturnStmt;
import miniJava.AbstractSyntaxTrees.Statement;
import miniJava.AbstractSyntaxTrees.StatementList;
import miniJava.AbstractSyntaxTrees.ThisRef;
import miniJava.AbstractSyntaxTrees.TypeKind;
import miniJava.AbstractSyntaxTrees.UnaryExpr;
import miniJava.AbstractSyntaxTrees.VarDecl;
import miniJava.AbstractSyntaxTrees.VarDeclStmt;
import miniJava.AbstractSyntaxTrees.Visitor;
import miniJava.AbstractSyntaxTrees.WhileStmt;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.SourcePosition;
import miniJava.SyntacticAnalyzer.Token;
import miniJava.SyntacticAnalyzer.TokenKind;

public class Identification implements Visitor<Object, Object>{
	public IdentificationTable table;
	private ErrorReporter reporter;
	
	public Identification(Package ast, ErrorReporter reporter) {
		this.reporter = reporter;
		table = new IdentificationTable(reporter);
		ast.visit(this, null);
	}

	@Override
	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {
		// TODO Auto-generated method stub
		
		// scope 1
		table.openScope();
		
		SourcePosition sp = new SourcePosition(0);
		
		FieldDeclList fl1 = new FieldDeclList();
		MethodDeclList ml1 = new MethodDeclList();
		StatementList sl1 = new StatementList();
		ParameterDeclList pl1 = new ParameterDeclList();
		BaseType bt1 = new BaseType(TypeKind.INT, sp);
		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);
		pl1.add(pd1);
		
		BaseType bt2 = new BaseType(TypeKind.VOID, sp);
		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);
		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);
		ml1.add(md1);
		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);
		
		FieldDeclList fl2 = new FieldDeclList();
		MethodDeclList ml2 = new MethodDeclList();
		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);
		Identifier id2 = new Identifier(t2);
		id2.decl = cd1;
		ClassType ct1 = new ClassType(id2, sp);
		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);
		fl2.add(fd2);
		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);
		
		FieldDeclList fl3 = new FieldDeclList();
		MethodDeclList ml3 = new MethodDeclList();
		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);
		
		table.enter(cd1);
		table.enter(cd2);
		table.enter(cd3);
		
		
		for (ClassDecl cd: prog.classDeclList) {
			table.enter(cd);
		}
		
		for (ClassDecl cd: prog.classDeclList) {
			cd.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitClassDecl(ClassDecl cd, Object arg) {
		// TODO Auto-generated method stub
		ClassDecl currentClass = cd;
		
		// add members so all fields and methods are visible
		table.openScope();
		for(FieldDecl fd: cd.fieldDeclList) {
			table.enter(fd);
		}
		for(MethodDecl md: cd.methodDeclList) {
			table.enter(md);
		}
		
		// visit all members
		for(FieldDecl fd: cd.fieldDeclList) {
			fd.visit(this, null);
		}
		for(MethodDecl md: cd.methodDeclList) {
			md.visit(this, null);
		}
		table.closeScope();
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object arg) {
		// TODO Auto-generated method stub
		fd.type.visit(this, null);
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object arg) {
		// TODO Auto-generated method stub
		md.type.visit(this, null);
		table.openScope();
		for(ParameterDecl pd: md.parameterDeclList) {
			pd.visit(this, null);
		}
		table.openScope();
		for(Statement st: md.statementList) {
			st.visit(this, null);
		}
		table.closeScope();
		table.closeScope();
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIxExpr(IxExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitThisRef(ThisRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitQRef(QualRef ref, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}
}
]]></snapshot>
  </Command>
  <Command __id="3130" _type="MoveCaretCommand" caretOffset="5032" date="Mon Apr 18 21:31:26 EDT 2022" docOffset="5032" starttimestamp="1650226882502" timestamp="105003717" />
  <Command __id="3131" _type="MoveCaretCommand" caretOffset="5032" date="Mon Apr 18 21:31:26 EDT 2022" docOffset="5032" starttimestamp="1650226882502" timestamp="105003717" />
  <Command __id="3132" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:32:00 EDT 2022" docASTNodeCount="88" docActiveCodeLength="513" docExpressionCount="46" docLength="610" projectName="pa3" starttimestamp="1650226882502" timestamp="105037991">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MethodDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class MethodDecl extends MemberDecl {¶	¶	public MethodDecl(MemberDecl md, ParameterDeclList pl, StatementList sl, SourcePosition posn){¶    super(md,posn);¶    parameterDeclList = pl;¶    statementList = sl;¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitMethodDecl(this, o);¶    }¶	¶	public ParameterDeclList parameterDeclList;¶	public StatementList statementList;¶}¶")]]]></diff>
  </Command>
  <Command __id="3133" _type="MoveCaretCommand" caretOffset="365" date="Mon Apr 18 21:32:00 EDT 2022" docOffset="422" starttimestamp="1650226882502" timestamp="105038072" />
  <Command __id="3135" _type="SelectTextCommand" caretOffset="2869" date="Mon Apr 18 21:32:38 EDT 2022" end="2869" start="2859" starttimestamp="1650226882502" timestamp="105076315" />
  <Command __id="3136" _type="MoveCaretCommand" caretOffset="3038" date="Mon Apr 18 21:32:39 EDT 2022" docOffset="5378" starttimestamp="1650226882502" timestamp="105076816" />
  <Command __id="3137" _type="MoveCaretCommand" caretOffset="3038" date="Mon Apr 18 21:32:39 EDT 2022" docOffset="5378" starttimestamp="1650226882502" timestamp="105076830" />
  <Command __id="3139" _type="ShellCommand" date="Mon Apr 18 21:32:41 EDT 2022" starttimestamp="1650226882502" timestamp="105079080" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3140" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:32:49 EDT 2022" forward="false" matchWord="false" offset="5378" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105086502" wrapSearch="false">
    <searchString><![CDATA[methoddecl]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3141" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:32:56 EDT 2022" forward="false" matchWord="false" offset="6501" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105094407" wrapSearch="false">
    <searchString><![CDATA[methoddecl]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3142" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:32:57 EDT 2022" forward="false" matchWord="false" offset="6501" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105094799" wrapSearch="false">
    <searchString><![CDATA[methoddecl]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3143" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:32:57 EDT 2022" forward="false" matchWord="false" offset="6501" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105095111" wrapSearch="false">
    <searchString><![CDATA[methoddecl]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3144" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:32:57 EDT 2022" forward="false" matchWord="false" offset="6501" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105095288" wrapSearch="false">
    <searchString><![CDATA[methoddecl]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3134" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:32:38 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="105076237">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3145" _type="ShellCommand" date="Mon Apr 18 21:32:59 EDT 2022" starttimestamp="1650226882502" timestamp="105096622" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3146" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:33:08 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="9000" projectName="pa3" starttimestamp="1650226882502" timestamp="105105767">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		¶		// add members so all fields and methods are visible¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		// visit all members¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="3147" _type="MoveCaretCommand" caretOffset="5032" date="Mon Apr 18 21:33:08 EDT 2022" docOffset="5032" starttimestamp="1650226882502" timestamp="105105818" />
  <Command __id="3148" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:33:09 EDT 2022" docASTNodeCount="88" docActiveCodeLength="513" docExpressionCount="46" docLength="610" projectName="pa3" starttimestamp="1650226882502" timestamp="105107453">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MethodDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class MethodDecl extends MemberDecl {¶	¶	public MethodDecl(MemberDecl md, ParameterDeclList pl, StatementList sl, SourcePosition posn){¶    super(md,posn);¶    parameterDeclList = pl;¶    statementList = sl;¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitMethodDecl(this, o);¶    }¶	¶	public ParameterDeclList parameterDeclList;¶	public StatementList statementList;¶}¶")]]]></diff>
  </Command>
  <Command __id="3149" _type="MoveCaretCommand" caretOffset="551" date="Mon Apr 18 21:33:10 EDT 2022" docOffset="608" starttimestamp="1650226882502" timestamp="105107506" />
  <Command __id="3150" _type="MoveCaretCommand" caretOffset="387" date="Mon Apr 18 21:33:10 EDT 2022" docOffset="444" starttimestamp="1650226882502" timestamp="105107854" />
  <Command __id="3151" _type="MoveCaretCommand" caretOffset="376" date="Mon Apr 18 21:33:10 EDT 2022" docOffset="433" starttimestamp="1650226882502" timestamp="105108366" />
  <Command __id="3152" _type="MoveCaretCommand" caretOffset="359" date="Mon Apr 18 21:33:11 EDT 2022" docOffset="416" starttimestamp="1650226882502" timestamp="105108702" />
  <Command __id="3153" _type="MoveCaretCommand" caretOffset="372" date="Mon Apr 18 21:33:11 EDT 2022" docOffset="429" starttimestamp="1650226882502" timestamp="105109187" />
  <Command __id="3154" _type="MoveCaretCommand" caretOffset="362" date="Mon Apr 18 21:33:12 EDT 2022" docOffset="419" starttimestamp="1650226882502" timestamp="105109598" />
  <Command __id="3156" _type="MoveCaretCommand" caretOffset="5106" date="Mon Apr 18 21:33:13 EDT 2022" docOffset="5106" starttimestamp="1650226882502" timestamp="105110928" />
  <Command __id="3157" _type="MoveCaretCommand" caretOffset="5032" date="Mon Apr 18 21:33:13 EDT 2022" docOffset="5032" starttimestamp="1650226882502" timestamp="105111298" />
  <Command __id="3158" _type="MoveCaretCommand" caretOffset="5032" date="Mon Apr 18 21:33:13 EDT 2022" docOffset="5032" starttimestamp="1650226882502" timestamp="105111302" />
  <Command __id="3159" _type="ShellCommand" date="Mon Apr 18 21:33:24 EDT 2022" starttimestamp="1650226882502" timestamp="105121656" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3160" _type="ShellCommand" date="Mon Apr 18 21:33:41 EDT 2022" starttimestamp="1650226882502" timestamp="105139030" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3161" _type="MoveCaretCommand" caretOffset="5274" date="Mon Apr 18 21:33:41 EDT 2022" docOffset="5274" starttimestamp="1650226882502" timestamp="105139098" />
  <Command __id="3162" _type="MoveCaretCommand" caretOffset="5274" date="Mon Apr 18 21:33:41 EDT 2022" docOffset="5274" starttimestamp="1650226882502" timestamp="105139102" />
  <Command __id="3163" _type="MoveCaretCommand" caretOffset="5229" date="Mon Apr 18 21:33:41 EDT 2022" docOffset="5229" starttimestamp="1650226882502" timestamp="105139393" />
  <Command __id="3164" _type="MoveCaretCommand" caretOffset="5229" date="Mon Apr 18 21:33:41 EDT 2022" docOffset="5229" starttimestamp="1650226882502" timestamp="105139398" />
  <Command __id="3165" _type="MoveCaretCommand" caretOffset="5319" date="Mon Apr 18 21:33:55 EDT 2022" docOffset="5319" starttimestamp="1650226882502" timestamp="105153074" />
  <Command __id="3166" _type="MoveCaretCommand" caretOffset="5319" date="Mon Apr 18 21:33:55 EDT 2022" docOffset="5319" starttimestamp="1650226882502" timestamp="105153078" />
  <Command __id="3167" _type="MoveCaretCommand" caretOffset="5373" date="Mon Apr 18 21:33:55 EDT 2022" docOffset="5373" starttimestamp="1650226882502" timestamp="105153437" />
  <Command __id="3168" _type="MoveCaretCommand" caretOffset="5373" date="Mon Apr 18 21:33:55 EDT 2022" docOffset="5373" starttimestamp="1650226882502" timestamp="105153438" />
  <Command __id="3169" _type="MoveCaretCommand" caretOffset="5407" date="Mon Apr 18 21:33:56 EDT 2022" docOffset="5407" starttimestamp="1650226882502" timestamp="105153885" />
  <Command __id="3170" _type="MoveCaretCommand" caretOffset="5407" date="Mon Apr 18 21:33:56 EDT 2022" docOffset="5407" starttimestamp="1650226882502" timestamp="105153885" />
  <Command __id="3171" _type="MoveCaretCommand" caretOffset="5067" date="Mon Apr 18 21:34:00 EDT 2022" docOffset="5067" starttimestamp="1650226882502" timestamp="105158027" />
  <Command __id="3172" _type="MoveCaretCommand" caretOffset="5067" date="Mon Apr 18 21:34:00 EDT 2022" docOffset="5067" starttimestamp="1650226882502" timestamp="105158038" />
  <Command __id="3173" _type="SelectTextCommand" caretOffset="5112" date="Mon Apr 18 21:34:03 EDT 2022" end="5112" start="5086" starttimestamp="1650226882502" timestamp="105160601" />
  <Command __id="3174" _type="SelectTextCommand" caretOffset="5112" date="Mon Apr 18 21:34:03 EDT 2022" end="5112" start="5086" starttimestamp="1650226882502" timestamp="105160605" />
  <Command __id="3175" _type="MoveCaretCommand" caretOffset="5112" date="Mon Apr 18 21:34:03 EDT 2022" docOffset="5112" starttimestamp="1650226882502" timestamp="105160918" />
  <Command __id="3176" _type="MoveCaretCommand" caretOffset="5112" date="Mon Apr 18 21:34:03 EDT 2022" docOffset="5112" starttimestamp="1650226882502" timestamp="105160918" />
  <Command __id="3155" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:33:13 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="9000" projectName="pa3" starttimestamp="1650226882502" timestamp="105110874">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		¶		// add members so all fields and methods are visible¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		// visit all members¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="3177" _type="MoveCaretCommand" caretOffset="5411" date="Mon Apr 18 21:34:09 EDT 2022" docOffset="5411" starttimestamp="1650226882502" timestamp="105166821" />
  <Command __id="3178" _type="MoveCaretCommand" caretOffset="5411" date="Mon Apr 18 21:34:09 EDT 2022" docOffset="5411" starttimestamp="1650226882502" timestamp="105166822" />
  <Command __id="3179" _type="MoveCaretCommand" caretOffset="5367" date="Mon Apr 18 21:34:09 EDT 2022" docOffset="5367" starttimestamp="1650226882502" timestamp="105167190" />
  <Command __id="3180" _type="MoveCaretCommand" caretOffset="5367" date="Mon Apr 18 21:34:09 EDT 2022" docOffset="5367" starttimestamp="1650226882502" timestamp="105167190" />
  <Command __id="3181" _type="MoveCaretCommand" caretOffset="5396" date="Mon Apr 18 21:34:10 EDT 2022" docOffset="5396" starttimestamp="1650226882502" timestamp="105167623" />
  <Command __id="3182" _type="MoveCaretCommand" caretOffset="5396" date="Mon Apr 18 21:34:10 EDT 2022" docOffset="5396" starttimestamp="1650226882502" timestamp="105167623" />
  <Command __id="3183" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:34:22 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1070" docExpressionCount="105" docLength="1224" projectName="pa3" starttimestamp="1650226882502" timestamp="105180358">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}"), Diff(INSERT,"¶	¶	public Declaration retrieve(String s) {¶		return null;¶	}"), Diff(EQUAL,"¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package miniJava.ContextualAnalyzer;

import java.util.HashMap;
import java.util.Stack;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.Declaration;
import miniJava.AbstractSyntaxTrees.FieldDecl;

public class IdentificationTable {
	public Stack<HashMap<String, Declaration>> table;
	
	public IdentificationTable(ErrorReporter reporter) {
		// TODO Auto-generated constructor stub
		table = new Stack<HashMap<String, Declaration>>();
	}

	public void openScope() {
		// TODO Auto-generated method stub
		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();
		table.push(newScope);
	}

	public void closeScope() {
		// TODO Auto-generated method stub
		table.pop();
	}

	public void enter(Declaration decl) {
		// TODO Auto-generated method stub
		HashMap<String, Declaration> currScope = table.peek();
		String name = decl.name;
		if (currScope.containsKey(name)) {
			// position ?
			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");
			System.exit(4);
		} else {
			currScope.put(name, decl);
		}
		return;
	}
	
	public Declaration retrieve(String s) {
		return null;
	}

}
]]></snapshot>
  </Command>
  <Command __id="3184" _type="MoveCaretCommand" caretOffset="998" date="Mon Apr 18 21:34:22 EDT 2022" docOffset="1155" starttimestamp="1650226882502" timestamp="105180421" />
  <Command __id="3185" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:34:30 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="105187710">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3186" _type="SelectTextCommand" caretOffset="4161" date="Mon Apr 18 21:34:30 EDT 2022" end="4161" start="4151" starttimestamp="1650226882502" timestamp="105187777" />
  <Command __id="3187" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:34:47 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="105205095">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="3188" _type="MoveCaretCommand" caretOffset="210" date="Mon Apr 18 21:34:47 EDT 2022" docOffset="267" starttimestamp="1650226882502" timestamp="105205182" />
  <Command __id="3189" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:35:12 EDT 2022" docASTNodeCount="101" docActiveCodeLength="629" docExpressionCount="60" docLength="726" projectName="pa3" starttimestamp="1650226882502" timestamp="105230467">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MemberDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶abstract public class MemberDecl extends Declaration {¶¶    public MemberDecl(boolean isPrivate, boolean isStatic, TypeDenoter mt, String name, SourcePosition posn) {¶        super(name, mt, posn);¶        this.isPrivate = isPrivate;¶        this.isStatic = isStatic;¶    }¶    ¶    public MemberDecl(MemberDecl md, SourcePosition posn){¶    	super(md.name, md.type, posn);¶    	this.isPrivate = md.isPrivate;¶    	this.isStatic = md.isStatic;¶    }¶    ¶    public boolean isPrivate;¶    public boolean isStatic;¶}¶")]]]></diff>
  </Command>
  <Command __id="3190" _type="SelectTextCommand" caretOffset="168" date="Mon Apr 18 21:35:13 EDT 2022" end="168" start="158" starttimestamp="1650226882502" timestamp="105230583" />
  <Command __id="3191" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:35:21 EDT 2022" docASTNodeCount="65" docActiveCodeLength="367" docExpressionCount="34" docLength="464" projectName="pa3" starttimestamp="1650226882502" timestamp="105239074">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\Declaration.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public abstract class Declaration extends AST {¶	public Declaration decl;¶	¶	public Declaration(String name, TypeDenoter type, SourcePosition posn) {¶		super(posn);¶		this.name = name;¶		this.type = type;¶	}¶	¶	public String name;¶	public TypeDenoter type;¶}¶")]]]></diff>
  </Command>
  <Command __id="3192" _type="SelectTextCommand" caretOffset="169" date="Mon Apr 18 21:35:21 EDT 2022" end="169" start="158" starttimestamp="1650226882502" timestamp="105239131" />
  <Command __id="3193" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:35:29 EDT 2022" docASTNodeCount="88" docActiveCodeLength="513" docExpressionCount="46" docLength="610" projectName="pa3" starttimestamp="1650226882502" timestamp="105247150">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\MethodDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class MethodDecl extends MemberDecl {¶	¶	public MethodDecl(MemberDecl md, ParameterDeclList pl, StatementList sl, SourcePosition posn){¶    super(md,posn);¶    parameterDeclList = pl;¶    statementList = sl;¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitMethodDecl(this, o);¶    }¶	¶	public ParameterDeclList parameterDeclList;¶	public StatementList statementList;¶}¶")]]]></diff>
  </Command>
  <Command __id="3194" _type="MoveCaretCommand" caretOffset="362" date="Mon Apr 18 21:35:29 EDT 2022" docOffset="419" starttimestamp="1650226882502" timestamp="105247197" />
  <Command __id="3195" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:35:30 EDT 2022" docASTNodeCount="88" docActiveCodeLength="491" docExpressionCount="46" docLength="588" projectName="pa3" starttimestamp="1650226882502" timestamp="105247806">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\AbstractSyntaxTrees\FieldDecl.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"/**¶ * miniJava Abstract Syntax Tree classes¶ * @author prins¶ * @version COMP 520 (v2.2)¶ */¶package miniJava.AbstractSyntaxTrees;¶¶import miniJava.SyntacticAnalyzer.SourcePosition;¶¶public class FieldDecl extends MemberDecl {¶	¶	public FieldDecl(boolean isPrivate, boolean isStatic, TypeDenoter t, String name, SourcePosition posn){¶    super(isPrivate, isStatic, t, name, posn);¶	}¶	¶	public FieldDecl(MemberDecl md, SourcePosition posn) {¶		super(md,posn);¶	}¶	¶	public <A, R> R visit(Visitor<A, R> v, A o) {¶        return v.visitFieldDecl(this, o);¶    }¶}¶¶")]]]></diff>
  </Command>
  <Command __id="3196" _type="MoveCaretCommand" caretOffset="210" date="Mon Apr 18 21:35:30 EDT 2022" docOffset="267" starttimestamp="1650226882502" timestamp="105247874" />
  <Command __id="3198" _type="MoveCaretCommand" caretOffset="3097" date="Mon Apr 18 21:35:45 EDT 2022" docOffset="5437" starttimestamp="1650226882502" timestamp="105262795" />
  <Command __id="3199" _type="SelectTextCommand" caretOffset="3167" date="Mon Apr 18 21:35:45 EDT 2022" end="3167" start="3097" starttimestamp="1650226882502" timestamp="105263250" />
  <Command __id="3200" _type="SelectTextCommand" caretOffset="3167" date="Mon Apr 18 21:35:45 EDT 2022" end="3167" start="3097" starttimestamp="1650226882502" timestamp="105263254" />
  <Command __id="3201" _type="MoveCaretCommand" caretOffset="3167" date="Mon Apr 18 21:35:46 EDT 2022" docOffset="5507" starttimestamp="1650226882502" timestamp="105263551" />
  <Command __id="3202" _type="MoveCaretCommand" caretOffset="3167" date="Mon Apr 18 21:35:46 EDT 2022" docOffset="5507" starttimestamp="1650226882502" timestamp="105263551" />
  <Command __id="3203" _type="SelectTextCommand" caretOffset="3097" date="Mon Apr 18 21:35:47 EDT 2022" end="3129" start="3097" starttimestamp="1650226882502" timestamp="105265132" />
  <Command __id="3204" _type="SelectTextCommand" caretOffset="3097" date="Mon Apr 18 21:35:47 EDT 2022" end="3129" start="3097" starttimestamp="1650226882502" timestamp="105265142" />
  <Command __id="3205" _type="MoveCaretCommand" caretOffset="3195" date="Mon Apr 18 21:35:48 EDT 2022" docOffset="5535" starttimestamp="1650226882502" timestamp="105265554" />
  <Command __id="3206" _type="MoveCaretCommand" caretOffset="3195" date="Mon Apr 18 21:35:48 EDT 2022" docOffset="5535" starttimestamp="1650226882502" timestamp="105265558" />
  <Command __id="3207" _type="SelectTextCommand" caretOffset="3097" date="Mon Apr 18 21:35:49 EDT 2022" end="3129" start="3097" starttimestamp="1650226882502" timestamp="105266872" />
  <Command __id="3208" _type="SelectTextCommand" caretOffset="3097" date="Mon Apr 18 21:35:49 EDT 2022" end="3129" start="3097" starttimestamp="1650226882502" timestamp="105266872" />
  <Command __id="3209" _type="MoveCaretCommand" caretOffset="3119" date="Mon Apr 18 21:35:50 EDT 2022" docOffset="5459" starttimestamp="1650226882502" timestamp="105267511" />
  <Command __id="3210" _type="MoveCaretCommand" caretOffset="3119" date="Mon Apr 18 21:35:50 EDT 2022" docOffset="5459" starttimestamp="1650226882502" timestamp="105267511" />
  <Command __id="3211" _type="SelectTextCommand" caretOffset="3096" date="Mon Apr 18 21:35:52 EDT 2022" end="3129" start="3096" starttimestamp="1650226882502" timestamp="105269741" />
  <Command __id="3212" _type="SelectTextCommand" caretOffset="3096" date="Mon Apr 18 21:35:52 EDT 2022" end="3129" start="3096" starttimestamp="1650226882502" timestamp="105269741" />
  <Command __id="3213" _type="MoveCaretCommand" caretOffset="3206" date="Mon Apr 18 21:35:52 EDT 2022" docOffset="5546" starttimestamp="1650226882502" timestamp="105270205" />
  <Command __id="3214" _type="MoveCaretCommand" caretOffset="3206" date="Mon Apr 18 21:35:52 EDT 2022" docOffset="5546" starttimestamp="1650226882502" timestamp="105270205" />
  <Command __id="3215" _type="MoveCaretCommand" caretOffset="3078" date="Mon Apr 18 21:36:08 EDT 2022" docOffset="5418" starttimestamp="1650226882502" timestamp="105285791" />
  <Command __id="3216" _type="MoveCaretCommand" caretOffset="3078" date="Mon Apr 18 21:36:08 EDT 2022" docOffset="5418" starttimestamp="1650226882502" timestamp="105285798" />
  <Command __id="3217" _type="MoveCaretCommand" caretOffset="3121" date="Mon Apr 18 21:36:08 EDT 2022" docOffset="5461" starttimestamp="1650226882502" timestamp="105286223" />
  <Command __id="3218" _type="MoveCaretCommand" caretOffset="3121" date="Mon Apr 18 21:36:08 EDT 2022" docOffset="5461" starttimestamp="1650226882502" timestamp="105286238" />
  <Command __id="3219" _type="SelectTextCommand" caretOffset="3126" date="Mon Apr 18 21:36:08 EDT 2022" end="3126" start="3117" starttimestamp="1650226882502" timestamp="105286407" />
  <Command __id="3220" _type="SelectTextCommand" caretOffset="3126" date="Mon Apr 18 21:36:08 EDT 2022" end="3126" start="3117" starttimestamp="1650226882502" timestamp="105286407" />
  <Command __id="3222" _type="ShellCommand" date="Mon Apr 18 21:36:10 EDT 2022" starttimestamp="1650226882502" timestamp="105287635" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3223" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:36:11 EDT 2022" forward="false" matchWord="false" offset="5466" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105288888" wrapSearch="false">
    <searchString><![CDATA[parseType]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3224" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:36:11 EDT 2022" forward="false" matchWord="false" offset="5466" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105289478" wrapSearch="false">
    <searchString><![CDATA[parseType]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3225" _type="ShellCommand" date="Mon Apr 18 21:36:12 EDT 2022" starttimestamp="1650226882502" timestamp="105290398" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3226" _type="MoveCaretCommand" caretOffset="3123" date="Mon Apr 18 21:36:13 EDT 2022" docOffset="5463" starttimestamp="1650226882502" timestamp="105291391" />
  <Command __id="3227" _type="MoveCaretCommand" caretOffset="3123" date="Mon Apr 18 21:36:13 EDT 2022" docOffset="5463" starttimestamp="1650226882502" timestamp="105291391" />
  <Command __id="3228" _type="MoveCaretCommand" caretOffset="3123" date="Mon Apr 18 21:36:14 EDT 2022" docOffset="5463" starttimestamp="1650226882502" timestamp="105291582" />
  <Command __id="3229" _type="MoveCaretCommand" caretOffset="3123" date="Mon Apr 18 21:36:14 EDT 2022" docOffset="5463" starttimestamp="1650226882502" timestamp="105291582" />
  <Command __id="3230" _type="MoveCaretCommand" caretOffset="3261" date="Mon Apr 18 21:36:17 EDT 2022" docOffset="5601" starttimestamp="1650226882502" timestamp="105294825" />
  <Command __id="3231" _type="MoveCaretCommand" caretOffset="3261" date="Mon Apr 18 21:36:17 EDT 2022" docOffset="5601" starttimestamp="1650226882502" timestamp="105294825" />
  <Command __id="3232" _type="MoveCaretCommand" caretOffset="3119" date="Mon Apr 18 21:36:18 EDT 2022" docOffset="5459" starttimestamp="1650226882502" timestamp="105296091" />
  <Command __id="3233" _type="MoveCaretCommand" caretOffset="3119" date="Mon Apr 18 21:36:18 EDT 2022" docOffset="5459" starttimestamp="1650226882502" timestamp="105296097" />
  <Command __id="3234" _type="MoveCaretCommand" caretOffset="3119" date="Mon Apr 18 21:36:18 EDT 2022" docOffset="5459" starttimestamp="1650226882502" timestamp="105296097" />
  <Command __id="3235" _type="MoveCaretCommand" caretOffset="3119" date="Mon Apr 18 21:36:18 EDT 2022" docOffset="5459" starttimestamp="1650226882502" timestamp="105296097" />
  <Command __id="3197" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:35:45 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="105262749">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3236" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Mon Apr 18 21:36:20 EDT 2022" starttimestamp="1650226882502" timestamp="105297520" />
  <Command __id="3238" _type="MoveCaretCommand" caretOffset="998" date="Mon Apr 18 21:36:42 EDT 2022" docOffset="1155" starttimestamp="1650226882502" timestamp="105320221" />
  <Command __id="3237" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:36:42 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1070" docExpressionCount="105" docLength="1224" projectName="pa3" starttimestamp="1650226882502" timestamp="105320174">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶	¶	public Declaration retrieve(String s) {¶		return null;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3239" _type="MoveCaretCommand" caretOffset="980" date="Mon Apr 18 21:36:43 EDT 2022" docOffset="1137" starttimestamp="1650226882502" timestamp="105321245" />
  <Command __id="3240" _type="MoveCaretCommand" caretOffset="1056" date="Mon Apr 18 21:36:44 EDT 2022" docOffset="1213" starttimestamp="1650226882502" timestamp="105321685" />
  <Command __id="3241" _type="MoveCaretCommand" caretOffset="1056" date="Mon Apr 18 21:36:44 EDT 2022" docOffset="1213" starttimestamp="1650226882502" timestamp="105321985" />
  <Command __id="3242" _type="MoveCaretCommand" caretOffset="1011" date="Mon Apr 18 21:36:44 EDT 2022" docOffset="1168" starttimestamp="1650226882502" timestamp="105322317" />
  <Command __id="3243" _type="MoveCaretCommand" caretOffset="930" date="Mon Apr 18 21:36:45 EDT 2022" docOffset="1087" starttimestamp="1650226882502" timestamp="105322633" />
  <Command __id="3244" _type="MoveCaretCommand" caretOffset="788" date="Mon Apr 18 21:36:45 EDT 2022" docOffset="945" starttimestamp="1650226882502" timestamp="105322949" />
  <Command __id="3245" _type="MoveCaretCommand" caretOffset="607" date="Mon Apr 18 21:36:45 EDT 2022" docOffset="764" starttimestamp="1650226882502" timestamp="105323218" />
  <Command __id="3246" _type="MoveCaretCommand" caretOffset="568" date="Mon Apr 18 21:36:46 EDT 2022" docOffset="725" starttimestamp="1650226882502" timestamp="105323587" />
  <Command __id="3247" _type="MoveCaretCommand" caretOffset="575" date="Mon Apr 18 21:36:46 EDT 2022" docOffset="732" starttimestamp="1650226882502" timestamp="105323861" />
  <Command __id="3248" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:36:48 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="105325998">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3249" _type="SelectTextCommand" caretOffset="23972" date="Mon Apr 18 21:36:48 EDT 2022" end="23972" start="23963" starttimestamp="1650226882502" timestamp="105326060" />
  <Command __id="3250" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:36:49 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1070" docExpressionCount="105" docLength="1224" projectName="pa3" starttimestamp="1650226882502" timestamp="105327102">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶	¶	public Declaration retrieve(String s) {¶		return null;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3251" _type="MoveCaretCommand" caretOffset="575" date="Mon Apr 18 21:36:49 EDT 2022" docOffset="732" starttimestamp="1650226882502" timestamp="105327149" />
  <Command __id="3253" _type="SelectTextCommand" caretOffset="23972" date="Mon Apr 18 21:36:52 EDT 2022" end="23972" start="23963" starttimestamp="1650226882502" timestamp="105329668" />
  <Command __id="3254" _type="MoveCaretCommand" caretOffset="22304" date="Mon Apr 18 21:36:56 EDT 2022" docOffset="24644" starttimestamp="1650226882502" timestamp="105333775" />
  <Command __id="3255" _type="MoveCaretCommand" caretOffset="22304" date="Mon Apr 18 21:36:56 EDT 2022" docOffset="24644" starttimestamp="1650226882502" timestamp="105333775" />
  <Command __id="3257" _type="ShellCommand" date="Mon Apr 18 21:36:57 EDT 2022" starttimestamp="1650226882502" timestamp="105334670" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3258" _type="FindCommand" caseSensitive="false" date="Mon Apr 18 21:36:59 EDT 2022" forward="false" matchWord="false" offset="24644" regexp="false" replaceAll="false" selection="Find" selectionScope="false" starttimestamp="1650226882502" timestamp="105337334" wrapSearch="false">
    <searchString><![CDATA[methoddecl]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="3252" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:36:52 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="105329605">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3259" _type="ShellCommand" date="Mon Apr 18 21:37:01 EDT 2022" starttimestamp="1650226882502" timestamp="105338797" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3261" _type="MoveCaretCommand" caretOffset="575" date="Mon Apr 18 21:37:29 EDT 2022" docOffset="732" starttimestamp="1650226882502" timestamp="105367484" />
  <Command __id="3260" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:37:29 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1070" docExpressionCount="105" docLength="1224" projectName="pa3" starttimestamp="1650226882502" timestamp="105367414">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶	¶	public Declaration retrieve(String s) {¶		return null;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3266" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:37:32 EDT 2022" docASTNodeCount="3249" docActiveCodeLength="22076" docExpressionCount="2262" docLength="29058" projectName="pa3" starttimestamp="1650226882502" timestamp="105370335">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\SyntacticAnalyzer\Parser.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.SyntacticAnalyzer;¶¶import miniJava.SyntacticAnalyzer.Scanner;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.AST;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassDeclList;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.ExprList;¶import miniJava.AbstractSyntaxTrees.Expression;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MemberDecl;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.Reference;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.Terminal;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeDenoter;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶¶public class Parser {¶	private Scanner scanner;¶	private ErrorReporter reporter;¶	private Token currentToken;¶¶	public Parser(Scanner scanner, ErrorReporter reporter) {¶		this.scanner = scanner;¶		this.reporter = reporter;¶	}¶¶¶	/**¶	 *  parse input, catch possible parse error¶	 */¶	public AST parse() throws SyntaxError{¶		currentToken = scanner.scan();¶		AST ast = null;¶		try {¶			ast = parseProgram();¶		}¶		catch (SyntaxError e) { }¶		return ast;¶	}¶	¶	private boolean startsDeclaration(TokenKind kind) throws SyntaxError{¶		return kind == TokenKind.PUBLIC ||¶				kind == TokenKind.PRIVATE ||¶				 kind == TokenKind.STATIC ||¶				  startsType(kind) ||¶					 kind == TokenKind.VOID;¶	}¶	¶	private boolean startsType(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.INT ||¶				   kind == TokenKind.BOOLEAN ||¶					kind == TokenKind.ID;¶	}¶¶	¶	public Package parseProgram() throws SyntaxError {¶		ClassDeclList classList = new ClassDeclList();¶		while (currentToken.kind != TokenKind.EOT) {¶			FieldDeclList fieldList = new FieldDeclList();¶            MethodDeclList methodList = new MethodDeclList();¶            ¶    		accept(TokenKind.CLASS);¶    		Identifier classId = parseId();¶    		accept(TokenKind.LCURLY);¶    		¶//    		System.out.print(currentToken.kind);¶    		while (startsDeclaration(currentToken.kind)) {¶//    			System.out.println("------------starting declaration-----------");¶    			// parse accessibility¶    			boolean isPublic = true;¶    			if (currentToken.kind == TokenKind.PRIVATE) {¶    				acceptIt();¶    				isPublic = false;¶    			} else if (currentToken.kind == TokenKind.PUBLIC) {¶    				acceptIt();¶    			}¶    			¶    			// parse access¶    			boolean isStatic = false;¶    			if (currentToken.kind == TokenKind.STATIC) {¶    				acceptIt();¶    				isStatic = true;¶    			}¶    			¶    			switch(currentToken.kind) {¶    				// Method Declaration¶    				case VOID:¶    					TypeDenoter type = new BaseType(TypeKind.VOID, null);¶    					acceptIt();¶    					Identifier methodId = parseId();¶    					accept(TokenKind.LPAREN);¶    					ParameterDeclList paramList = new ParameterDeclList();¶    					if (startsType(currentToken.kind)) {¶    						paramList = parseParameterList();¶    					}¶    					accept(TokenKind.RPAREN);¶    					accept(TokenKind.LCURLY);¶    					¶    					StatementList stateList = new StatementList();¶    					while (startsStatement(currentToken.kind)) {¶//    						System.out.println("IN VOID METHOD DECLARATION");¶    						stateList.add(parseStatement());¶//    						System.out.println("OUT VOID METHOD DECLARATION");¶    					}¶    					accept(TokenKind.RCURLY);¶    					methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type, methodId.spelling, null), paramList, stateList, null));¶    					break;¶    					¶    				// both possible¶    				default:¶    					if (startsType(currentToken.kind)) {¶    						TypeDenoter type2 = parseType();¶    						Identifier id = parseId();¶    						switch(currentToken.kind) {¶    							// Field Declaration¶    							case SEMICOLON:¶    								acceptIt();¶    								fieldList.add(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null));¶    								break;¶    							¶    							// Method Declaration¶    							case LPAREN:¶    								acceptIt();¶    								ParameterDeclList paramList2 = new ParameterDeclList();¶    								if (startsType(currentToken.kind)) {¶    									paramList2 = parseParameterList();¶    								}¶    								accept(TokenKind.RPAREN);¶    								accept(TokenKind.LCURLY);¶    								¶    								StatementList stateList2 = new StatementList();¶    								while (startsStatement(currentToken.kind)) {¶//    									System.out.println("IN METHOD DECLARATION");¶    									stateList2.add(parseStatement());¶//    									System.out.println("OUT METHOD DECLARATION");¶    								}¶    								accept(TokenKind.RCURLY);¶    								methodList.add(new MethodDecl(new FieldDecl(!isPublic, isStatic, type2, id.spelling, null), paramList2, stateList2, null));¶    								break;¶    						}¶    					}¶    					else {¶    						parseError("Parsing wrong in declarations, no types declared.");¶    					}¶    					break;¶    					¶    			}¶//    			System.out.println("------------ending declaration-----------");¶    		}¶//    		System.out.println("out here end of program: " + currentToken.spelling);¶¶    		accept(TokenKind.RCURLY);¶    		classList.add(new ClassDecl(classId.spelling, fieldList, methodList, null));¶            ¶		}¶		¶¶		accept(TokenKind.EOT);¶		return new Package(classList,null);¶	}¶	¶//	  public Statement(SourcePosition posn) {¶//    public StatementList() {¶//    public BlockStmt(StatementList sl, SourcePosition posn){¶	private Statement parseStatement() throws SyntaxError {¶		Statement stmt = null;¶		switch (currentToken.kind) {¶			// {statements*}¶			case LCURLY:¶				acceptIt();¶				StatementList sl = new StatementList();¶				while (startsStatement(currentToken.kind)) {¶					sl.add(parseStatement());¶				}¶	//			System.out.println("in here: " + currentToken);¶				accept(TokenKind.RCURLY);¶				stmt = new BlockStmt(sl, null);¶				break;¶				¶				¶//				public VarDecl(TypeDenoter t, String name, SourcePosition posn) {¶//			    public VarDeclStmt(VarDecl vd, Expression e, SourcePosition posn){¶			// Type id = Expression;¶			case INT: case BOOLEAN:¶				String name = currentToken.spelling;¶				TypeDenoter td = parseType();¶				Identifier id = parseId();¶				accept(TokenKind.EQUAL);¶				Expression e = parseExpression();¶				accept(TokenKind.SEMICOLON);¶				¶				VarDecl vd = new VarDecl(td, name, null);¶				stmt = new VarDeclStmt(vd, e, null);¶				break;¶			¶			case ID:			¶//				System.out.println("in here0, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				Identifier id2 = parseId();¶//				System.out.println("in here1, " + currentToken.kind + " is***" + currentToken.spelling + "***");¶				switch (currentToken.kind) {¶					// starts with Type¶					// Type id = Expression¶					case ID:¶						TypeDenoter td2 = new ClassType(id2, null);¶						Identifier id3 = parseId();¶						accept(TokenKind.EQUAL);¶						Expression e2 = parseExpression();¶						accept(TokenKind.SEMICOLON);¶						VarDecl vd2 = new VarDecl(td2, id3.spelling, null);¶						stmt = new VarDeclStmt(vd2, e2, null);¶						break;¶					¶					// starts with Reference¶					// Reference = Expression¶					case EQUAL:¶						Reference r = new IdRef(id2, null);¶//						System.out.println("in here2, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						acceptIt();¶//						System.out.println("in here3, " + currentToken.kind + " is*" + currentToken.spelling + "*");¶						Expression e3 = parseExpression();¶//						System.out.println("inhere 4");¶						accept(TokenKind.SEMICOLON);¶						¶						stmt = new AssignStmt(r, e3, null);¶						break;¶					¶					// Reference (arglist?)¶					case LPAREN:¶						Reference r2 = new IdRef(id2, null);¶						ExprList al = new ExprList();¶						acceptIt();¶						if (currentToken.kind == TokenKind.RPAREN) {¶							acceptIt();¶						} else {¶							al = parseArgumentList();¶							accept(TokenKind.RPAREN);¶						}¶						accept(TokenKind.SEMICOLON);¶						stmt = new CallStmt(r2, al, null);¶						break;¶					¶					// both¶					case LBRACKET: ¶						acceptIt();¶						¶						if (currentToken.kind == TokenKind.RBRACKET) {¶							// in Type¶							// Type id = Expression;¶							// Type := id[]¶							acceptIt();							¶							ArrayType at = new ArrayType(new ClassType(id2, null), null);¶							Identifier id4 = parseId();¶							accept(TokenKind.EQUAL);¶							Expression e4 =parseExpression();¶							accept(TokenKind.SEMICOLON);¶							VarDecl vd3 = new VarDecl(at, id4.spelling, null);¶							stmt = new VarDeclStmt(vd3, e4, null);¶						} else {¶							// in Reference¶							Reference r3 = new IdRef(id2, null);¶							Expression e5 = parseExpression();¶							accept(TokenKind.RBRACKET);¶							accept(TokenKind.EQUAL);¶							Expression e6 = parseExpression();¶							accept(TokenKind.SEMICOLON);¶							stmt = new IxAssignStmt(r3, e5, e6, null);¶						}¶						break;¶					¶					case DOT:¶						// in Reference¶						Reference r4 = new IdRef(id2,null);¶						while (currentToken.kind == TokenKind.DOT) {¶							acceptIt();¶							Identifier id4 = parseId();¶							r4 = new QualRef(r4, id4, null);¶						}¶						switch (currentToken.kind) {¶							// Reference = Expression;¶							case EQUAL:¶								acceptIt();¶								Expression e4 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new AssignStmt(r4,e4,null);¶								break;¶							¶							// Reference[Expression] = Expression;¶							case LBRACKET: ¶								acceptIt();¶								Expression e5 = parseExpression();¶								accept(TokenKind.RBRACKET);¶								accept(TokenKind.EQUAL);¶								Expression e6 = parseExpression();¶								accept(TokenKind.SEMICOLON);¶								stmt = new IxAssignStmt(r4, e5, e6, null);¶								break;¶							¶							// Reference(arglist?);¶							case LPAREN:¶								acceptIt();¶								ExprList el2 = new ExprList();¶								if (currentToken.kind == TokenKind.RPAREN) {¶									acceptIt();¶								} else {¶									el2 = parseArgumentList();¶									accept(TokenKind.RPAREN);¶								}¶								accept(TokenKind.SEMICOLON);¶								stmt = new CallStmt(r4, el2, null);¶								break;¶							¶							default:¶								parseError("parsing statement, in subcase ID, in subcase DOT, current token is: " + currentToken.spelling);¶						}¶						break;¶					default:¶						parseError("parsing statement, in subcase ID, current token is: " + currentToken.spelling);¶						break;¶				}¶				break;¶			¶			¶			// in Reference¶			case THIS:¶				Reference rInThis = new ThisRef(null);¶				acceptIt();¶				while (currentToken.kind == TokenKind.DOT) {¶					acceptIt();¶					Identifier idAfterThis = parseId();¶					rInThis = new QualRef(rInThis, idAfterThis, null);¶				}¶				switch (currentToken.kind) {¶				// Reference = Expression;¶				case EQUAL:¶					acceptIt();¶//					System.out.println("before");¶					Expression e5 =parseExpression();¶//					System.out.println("after");¶					accept(TokenKind.SEMICOLON);¶					stmt = new AssignStmt(rInThis, e5, null);¶					break;¶				¶				// Reference[Expression] = Expression;¶				case LBRACKET:¶					acceptIt();¶					Expression e6 = parseExpression();¶					accept(TokenKind.RBRACKET);¶					accept(TokenKind.EQUAL);¶					Expression e7 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶					stmt = new IxAssignStmt(rInThis, e6, e7, null);¶					break;¶					¶				// Reference(arglist?);¶				case LPAREN:¶					acceptIt();¶					ExprList el = new ExprList();¶					if (currentToken.kind == TokenKind.RPAREN) {¶						acceptIt();¶						accept(TokenKind.SEMICOLON);¶					} else {¶						el = parseArgumentList();¶						accept(TokenKind.RPAREN);¶						accept(TokenKind.SEMICOLON);¶					}¶					stmt = new CallStmt(rInThis, el, null);¶					break;¶				¶				default:¶					parseError("parsing statement, in subcase THIS, current token is: " + currentToken);¶				}¶				break;¶				¶			// in reference¶			case RETURN:¶				acceptIt();¶				Expression e2 = null;¶				if (currentToken.kind == TokenKind.SEMICOLON) {¶					acceptIt();¶				} else {¶					e2 = parseExpression();¶					accept(TokenKind.SEMICOLON);¶				}¶				stmt = new ReturnStmt(e2, null);¶				break;¶			¶			case IF:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression ifE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement ifS = parseStatement();¶				if (currentToken.kind == TokenKind.ELSE) {¶					acceptIt();¶					Statement elseS = parseStatement();¶					stmt = new IfStmt(ifE, ifS, elseS, null);¶				} else {¶					stmt = new IfStmt(ifE,ifS,null);¶				}¶				break;¶				¶			case WHILE:¶				acceptIt();¶				accept(TokenKind.LPAREN);¶				Expression whileE = parseExpression();¶				accept(TokenKind.RPAREN);¶				Statement whileS = parseStatement();¶				stmt = new WhileStmt(whileE, whileS, null);¶				break;¶			¶			default:¶				parseError("parsing statement, current token is:" + currentToken);¶				break;¶		}¶		return stmt;¶		¶	}¶¶¶	private ExprList parseArgumentList() throws SyntaxError {¶		// TODO Auto-generated method stub¶		ExprList el = new ExprList();¶		Expression e = parseExpression();¶		el.add(e);¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			e = parseExpression();¶			el.add(e);¶		}¶		return el;¶	}¶¶//	public BinaryExpr(Operator o, Expression e1, Expression e2, SourcePosition posn){¶//	  public Operator (Token t) {¶	private Expression parseExpression() throws SyntaxError {¶		Expression e1 = parseExpressionA();¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶¶		while (currentToken.kind == TokenKind.OR) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionA();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶		return e1;¶	}¶	¶	private Expression parseExpressionA() throws SyntaxError {¶//		System.out.println("into A");¶		Expression e1 = parseExpressionB();¶		while (currentToken.kind == TokenKind.AND) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionB();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out A");¶		return e1;¶	}¶¶	¶	private Expression parseExpressionB() throws SyntaxError {¶//		System.out.println("into B");¶		Expression e1 = parseExpressionC();¶		while (currentToken.kind == TokenKind.ISEQUAL || currentToken.kind == TokenKind.NOTEQUAL) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionC();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out B");¶		return e1;¶	}¶¶¶	private Expression parseExpressionC() throws SyntaxError {¶//		System.out.println("into C");¶		Expression e1 = parseExpressionD();¶		while (currentToken.kind == TokenKind.LT || currentToken.kind == TokenKind.GT ||¶				currentToken.kind == TokenKind.LTE || currentToken.kind == TokenKind.GTE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionD();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out C");¶		return e1;¶	}¶¶¶	private Expression parseExpressionD() throws SyntaxError {¶//		System.out.println("into D");¶		Expression e1 = parseExpressionE();¶		while (currentToken.kind == TokenKind.PLUS || currentToken.kind == TokenKind.MINUS) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionE();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out D");¶		return e1;¶	}¶¶¶	private Expression parseExpressionE() throws SyntaxError {¶//		System.out.println("into E");¶		Expression e1 = parseExpressionF();¶		while (currentToken.kind == TokenKind.TIMES || currentToken.kind == TokenKind.DIVIDE) {¶			Operator o = new Operator(currentToken);¶			acceptIt();¶			Expression e2 = parseExpressionF();¶			e1 = new BinaryExpr(o,e1,e2,null);¶		}¶//		System.out.println("out E");¶		return e1;¶	}¶¶//	   public UnaryExpr(Operator o, Expression e, SourcePosition posn){¶	private Expression parseExpressionF() throws SyntaxError {¶//		System.out.println("into F");¶		Stack<Operator> s = new Stack<>();¶		while (currentToken.kind == TokenKind.MINUS || currentToken.kind == TokenKind.EXCLA) {¶			Operator o = new Operator(currentToken);¶			s.add(o);¶			acceptIt();¶		}¶		Expression e = parseExpressionG();¶		while(!s.isEmpty()) {¶			e = new UnaryExpr(s.pop(),e, null);¶		}¶//		System.out.println("out F");¶		return e;¶	}¶¶¶	private Expression parseExpressionG() throws SyntaxError {¶//		System.out.println("into G");¶//		System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶		Expression e = null;¶		switch (currentToken.kind) {¶		case LPAREN:¶			acceptIt();¶			e = parseExpression();¶			accept(TokenKind.RPAREN);¶			break;¶		¶		¶		case NUM:¶//			  public IntLiteral(Token t) {¶			IntLiteral il = new IntLiteral(currentToken);¶			acceptIt();¶			¶//		    public LiteralExpr(Terminal t, SourcePosition posn){¶			e = new LiteralExpr(il, null);¶			break;¶			¶		case TRUE: case FALSE:¶			BooleanLiteral bl = new BooleanLiteral(currentToken);¶			acceptIt();¶			e = new LiteralExpr(bl, null);¶			break;¶		¶		case NEW:¶			acceptIt();¶			switch (currentToken.kind) {¶				case ID:¶//					  public Identifier (Token t) {¶					Identifier id = new Identifier(currentToken);¶					acceptIt();¶					switch (currentToken.kind) {¶					case LPAREN:¶						acceptIt();¶						accept(TokenKind.RPAREN);¶						¶//					    public NewObjectExpr(ClassType ct, SourcePosition posn){¶//					    public ClassType(Identifier cn, SourcePosition posn){¶						e =  new NewObjectExpr(new ClassType(id, null), null);¶						break;¶						¶					case LBRACKET:¶						acceptIt();¶						e = parseExpression();¶						accept(TokenKind.RBRACKET);¶						¶//					    public NewArrayExpr(TypeDenoter et, Expression e, SourcePosition posn){¶//					    public TypeDenoter(TypeKind type, SourcePosition posn){¶//						public class ClassType extends TypeDenoter¶//						public ClassType(Identifier cn, SourcePosition posn){¶						e = new NewArrayExpr(new ClassType(id,null), e, null);¶						break;¶						¶					default:¶						parseError("parsing expression, nothing after new.");¶					¶					}¶					break;¶					¶				case INT:¶					acceptIt();¶					accept(TokenKind.LBRACKET);¶					e = parseExpression();¶					accept(TokenKind.RBRACKET);¶					¶//				    public BaseType(TypeKind t, SourcePosition posn){¶					e =  new NewArrayExpr(new BaseType(TypeKind.INT, null), e, null);¶					break;¶				¶				default:¶					parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶			}¶			break;¶			¶			¶		// starts with reference¶		case ID: case THIS:¶			Reference r = parseReference();¶¶			switch (currentToken.kind) {¶			// reference[expression]¶			case LBRACKET:¶				acceptIt();¶				e = parseExpression();¶				¶				accept(TokenKind.RBRACKET);¶				¶				//	public IxExpr(Reference r, Expression e, SourcePosition posn){¶				e = new IxExpr(r, e, null);¶				¶				break;¶			¶			// reference(arglist?)¶			case LPAREN:¶				acceptIt();¶				ExprList arglist = new ExprList();¶				if (currentToken.kind == TokenKind.RPAREN) {¶					acceptIt();¶				} else {¶					arglist = parseArgumentList();¶					accept(TokenKind.RPAREN);¶				}¶				¶//			    public CallExpr(Reference f, ExprList el, SourcePosition posn){¶				e = new CallExpr(r,arglist, null);¶				break;¶					¶			default:¶//			    public RefExpr(Reference r, SourcePosition posn){¶//				System.out.println(currentToken.spelling + " is of kind " + currentToken.kind);¶				e = new RefExpr(r, null);¶				break;¶			}¶			break;			¶		¶		default:¶			parseError("parsing expressionG");¶			¶		}¶		return e;¶	}¶¶//	public ThisRef(SourcePosition posn) {¶//	public IdRef(Identifier id, SourcePosition posn){¶//	public QualRef(Reference ref, Identifier id, SourcePosition posn){¶//	 public Identifier (Token t) {¶	private Reference parseReference() throws SyntaxError {¶		if(currentToken.kind == TokenKind.ID || currentToken.kind == TokenKind.THIS) {¶			Reference ref = null;¶			if(currentToken.kind == TokenKind.ID) {¶				ref = new IdRef(new Identifier(currentToken), null);¶			} else {¶				ref = new ThisRef(null);¶			}¶			acceptIt();¶			¶			// dealing with (.id)*¶			while (currentToken.kind == TokenKind.DOT) {¶				acceptIt();¶				if (currentToken.kind == TokenKind.ID) {¶					ref = new QualRef(ref, new Identifier(currentToken), null);¶					acceptIt();¶				} else {¶					parseError("no identifier after reference and dot");¶				}¶			}¶			return ref;¶			¶		} else {¶			parseError("parsing reference");¶			return null;¶		}¶	}¶¶¶//	private void parseExpression() {¶//		// TODO Auto-generated method stub¶//		switch (currentToken.kind) {¶//			// starts with reference¶//			case ID: case THIS:¶//				acceptIt();¶//				// dealing with (.id)*¶//				while (currentToken.kind == TokenKind.DOT) {¶//					acceptIt();¶//					accept(TokenKind.ID);¶//				}¶//				switch (currentToken.kind) {¶//					// reference[expression]¶//					case LBRACKET:¶//						acceptIt();¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					// reference(arglist?)¶//					case LPAREN:¶//						acceptIt();¶//						if (currentToken.kind == TokenKind.RPAREN) {¶//							acceptIt();¶//						} else {¶//							parseArgumentList();¶//							accept(TokenKind.RPAREN);¶//						}¶//						break;¶//						¶//					// just reference¶//					default:¶//						break;¶////						parseError("parsing expression, in subcase ID/THIS, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//				¶//			case UNOP: case MINUS:¶//				acceptIt();¶//				parseExpression();¶//				break;¶//			¶//			case LPAREN:¶//				acceptIt();¶//				parseExpression();¶//				accept(TokenKind.RPAREN);¶//				break;¶//			¶//			case NUM: case TRUE: case FALSE:¶//				acceptIt();¶//				break;¶//			¶//			case NEW:¶//				acceptIt();¶////				System.out.println("in hereeee");¶//				switch (currentToken.kind) {¶//					case ID:¶//						acceptIt();¶//						switch (currentToken.kind) {¶//						case LPAREN:¶//							acceptIt();¶//							accept(TokenKind.RPAREN);¶//							break;¶//						case LBRACKET:¶//							acceptIt();¶//							parseExpression();¶//							accept(TokenKind.RBRACKET);¶//							break;¶//						default:¶//							parseError("parsing expression, nothing after new.");¶//						¶//						}¶//						break;¶//					¶//					case INT:¶//						acceptIt();¶//						accept(TokenKind.LBRACKET);¶//						parseExpression();¶//						accept(TokenKind.RBRACKET);¶//						break;¶//					¶//					default:¶//						parseError("parsing expression, in subcase NEW, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				}¶//				break;¶//			¶//			default:¶//				parseError("parsing expression, current token is: " + currentToken.spelling + "and its kind is: " + currentToken.kind);¶//				break;¶//		}¶//		if (currentToken.kind == TokenKind.BINOP || currentToken.kind == TokenKind.MINUS ¶//				|| currentToken.kind == TokenKind.EQUAL) {¶//			acceptIt();¶//			parseExpression();¶//		}¶//	}¶¶¶	private boolean startsStatement(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.LCURLY ||¶				startsType(kind) ||¶				 startsReference(kind) ||¶				  kind == TokenKind.RETURN ||¶				   kind == TokenKind.IF ||¶					kind == TokenKind.WHILE;¶	}¶¶¶	private boolean startsReference(TokenKind kind) throws SyntaxError {¶		return kind == TokenKind.ID ||¶				kind == TokenKind.THIS;¶	}¶¶¶	private ParameterDeclList parseParameterList() throws SyntaxError {¶		ParameterDeclList paramList = new ParameterDeclList();¶		TypeDenoter td = parseType();¶		Identifier id = parseId();¶		paramList.add(new ParameterDecl(td, id.spelling, null));¶		while (currentToken.kind == TokenKind.COMMA) {¶			acceptIt();¶			td = parseType();¶			id = parseId();¶			paramList.add(new ParameterDecl(td, id.spelling, null));¶		}¶		return paramList;¶	}¶¶¶	private TypeDenoter parseType() throws SyntaxError{¶		TypeDenoter td = null;¶		switch (currentToken.kind) {¶		case INT:¶//		    public BaseType(TypeKind t, SourcePosition posn){¶			td = new BaseType(TypeKind.INT, null);¶			acceptIt();¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				¶//			    public ArrayType(TypeDenoter eltType, SourcePosition posn){¶				td = new ArrayType(td, null);¶			}¶			break;¶		case BOOLEAN:¶			td = new BaseType(TypeKind.BOOLEAN, null);¶			acceptIt();¶			break;¶		case ID:¶			Identifier id = parseId();¶			¶//		    public ClassType(Identifier cn, SourcePosition posn){¶			td = new ClassType(id, null);¶			if (currentToken.kind == TokenKind.LBRACKET) {¶				acceptIt();¶				accept(TokenKind.RBRACKET);¶				td = new ArrayType(td, null);¶			}¶			break;¶		default:¶			parseError("Wrong in parsing Type, currentToken is: " + currentToken);¶		}¶		return td;¶	}¶¶¶	private Identifier parseId() throws SyntaxError {¶		Identifier id = null;¶		if(currentToken.kind == TokenKind.ID) {¶			id = new Identifier(currentToken);¶			acceptIt();¶		} else {¶			parseError("is not an identifier");¶		}¶		return id;¶	}¶¶¶	private void parseClassDeclaration() throws SyntaxError {¶		while (currentToken.kind == TokenKind.CLASS) {¶			parseClassDeclaration();¶		}¶		accept(TokenKind.EOT);¶	}¶¶	/**¶	 * accept current token and advance to next token¶	 */¶	private void acceptIt() throws SyntaxError {¶		accept(currentToken.kind);¶	}¶¶	/**¶	 * verify that current token in input matches expected token and advance to next token¶	 * @param expectedToken¶	 * @throws SyntaxError  if match fails¶	 */¶	private void accept(TokenKind expectedTokenKind) throws SyntaxError {¶		if (currentToken.kind == expectedTokenKind) {¶//			System.out.println(currentToken.spelling);¶			currentToken = scanner.scan();¶		}¶		else¶			parseError("Parsing " + currentToken.spelling + " and expecting '" + expectedTokenKind +¶					"' but found '" + currentToken.kind + "'");¶	}¶¶	/**¶	 * report parse error and unwind call stack to start of parse¶	 * @param e  string with error detail¶	 * @throws SyntaxError¶	 */¶	private void parseError(String e) throws SyntaxError {¶		reporter.reportError("Parse error: " + e);¶		throw new SyntaxError();¶	}¶¶	// show parse stack whenever terminal is  accepted¶	private void pTrace() {¶		StackTraceElement [] stl = Thread.currentThread().getStackTrace();¶		for (int i = stl.length - 1; i > 0 ; i--) {¶			if(stl[i].toString().contains("parse"))¶				System.out.println(stl[i]);¶		}¶		System.out.println("accepting: " + currentToken.kind + " (\"" + currentToken.spelling + "\")");¶		System.out.println();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3268" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:37:34 EDT 2022" docASTNodeCount="184" docActiveCodeLength="1070" docExpressionCount="105" docLength="1224" projectName="pa3" starttimestamp="1650226882502" timestamp="105372198">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\IdentificationTable.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶¶public class IdentificationTable {¶	public Stack<HashMap<String, Declaration>> table;¶	¶	public IdentificationTable(ErrorReporter reporter) {¶		// TODO Auto-generated constructor stub¶		table = new Stack<HashMap<String, Declaration>>();¶	}¶¶	public void openScope() {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> newScope = new HashMap<String, Declaration>();¶		table.push(newScope);¶	}¶¶	public void closeScope() {¶		// TODO Auto-generated method stub¶		table.pop();¶	}¶¶	public void enter(Declaration decl) {¶		// TODO Auto-generated method stub¶		HashMap<String, Declaration> currScope = table.peek();¶		String name = decl.name;¶		if (currScope.containsKey(name)) {¶			// position ?¶			System.out.println("*** line " + decl.posn.toString() + " Duplicate declarations at the same level *** ");¶			System.exit(4);¶		} else {¶			currScope.put(name, decl);¶		}¶		return;¶	}¶	¶	public Declaration retrieve(String s) {¶		return null;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="3271" _type="DiffBasedFileOpenCommand" date="Mon Apr 18 21:37:40 EDT 2022" docASTNodeCount="1333" docActiveCodeLength="7830" docExpressionCount="828" docLength="9000" projectName="pa3" starttimestamp="1650226882502" timestamp="105378078">
    <filePath><![CDATA[F:\eclipse2018-09\workspace\pa3\src\miniJava\ContextualAnalyzer\Identification.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package miniJava.ContextualAnalyzer;¶¶import java.util.HashMap;¶import java.util.Stack;¶¶import miniJava.ErrorReporter;¶import miniJava.AbstractSyntaxTrees.ArrayType;¶import miniJava.AbstractSyntaxTrees.AssignStmt;¶import miniJava.AbstractSyntaxTrees.BaseType;¶import miniJava.AbstractSyntaxTrees.BinaryExpr;¶import miniJava.AbstractSyntaxTrees.BlockStmt;¶import miniJava.AbstractSyntaxTrees.BooleanLiteral;¶import miniJava.AbstractSyntaxTrees.CallExpr;¶import miniJava.AbstractSyntaxTrees.CallStmt;¶import miniJava.AbstractSyntaxTrees.ClassDecl;¶import miniJava.AbstractSyntaxTrees.ClassType;¶import miniJava.AbstractSyntaxTrees.Declaration;¶import miniJava.AbstractSyntaxTrees.FieldDecl;¶import miniJava.AbstractSyntaxTrees.FieldDeclList;¶import miniJava.AbstractSyntaxTrees.IdRef;¶import miniJava.AbstractSyntaxTrees.Identifier;¶import miniJava.AbstractSyntaxTrees.IfStmt;¶import miniJava.AbstractSyntaxTrees.IntLiteral;¶import miniJava.AbstractSyntaxTrees.IxAssignStmt;¶import miniJava.AbstractSyntaxTrees.IxExpr;¶import miniJava.AbstractSyntaxTrees.LiteralExpr;¶import miniJava.AbstractSyntaxTrees.MethodDecl;¶import miniJava.AbstractSyntaxTrees.MethodDeclList;¶import miniJava.AbstractSyntaxTrees.NewArrayExpr;¶import miniJava.AbstractSyntaxTrees.NewObjectExpr;¶import miniJava.AbstractSyntaxTrees.Operator;¶import miniJava.AbstractSyntaxTrees.ParameterDecl;¶import miniJava.AbstractSyntaxTrees.ParameterDeclList;¶import miniJava.AbstractSyntaxTrees.QualRef;¶import miniJava.AbstractSyntaxTrees.RefExpr;¶import miniJava.AbstractSyntaxTrees.ReturnStmt;¶import miniJava.AbstractSyntaxTrees.Statement;¶import miniJava.AbstractSyntaxTrees.StatementList;¶import miniJava.AbstractSyntaxTrees.ThisRef;¶import miniJava.AbstractSyntaxTrees.TypeKind;¶import miniJava.AbstractSyntaxTrees.UnaryExpr;¶import miniJava.AbstractSyntaxTrees.VarDecl;¶import miniJava.AbstractSyntaxTrees.VarDeclStmt;¶import miniJava.AbstractSyntaxTrees.Visitor;¶import miniJava.AbstractSyntaxTrees.WhileStmt;¶import miniJava.AbstractSyntaxTrees.Package;¶import miniJava.SyntacticAnalyzer.SourcePosition;¶import miniJava.SyntacticAnalyzer.Token;¶import miniJava.SyntacticAnalyzer.TokenKind;¶¶public class Identification implements Visitor<Object, Object>{¶	public IdentificationTable table;¶	private ErrorReporter reporter;¶	¶	public Identification(Package ast, ErrorReporter reporter) {¶		this.reporter = reporter;¶		table = new IdentificationTable(reporter);¶		ast.visit(this, null);¶	}¶¶	@Override¶	public Object visitPackage(miniJava.AbstractSyntaxTrees.Package prog, Object arg) {¶		// TODO Auto-generated method stub¶		¶		// scope 1¶		table.openScope();¶		¶		SourcePosition sp = new SourcePosition(0);¶		¶		FieldDeclList fl1 = new FieldDeclList();¶		MethodDeclList ml1 = new MethodDeclList();¶		StatementList sl1 = new StatementList();¶		ParameterDeclList pl1 = new ParameterDeclList();¶		BaseType bt1 = new BaseType(TypeKind.INT, sp);¶		ParameterDecl pd1 = new ParameterDecl(bt1, "n", sp);¶		pl1.add(pd1);¶		¶		BaseType bt2 = new BaseType(TypeKind.VOID, sp);¶		FieldDecl fd1 = new FieldDecl(false, false, bt2, "println", sp);¶		MethodDecl md1 = new MethodDecl(fd1, pl1, sl1, sp);¶		ml1.add(md1);¶		ClassDecl cd1 = new ClassDecl("_PrintStream", fl1, ml1, sp);¶		¶		FieldDeclList fl2 = new FieldDeclList();¶		MethodDeclList ml2 = new MethodDeclList();¶		Token t2 = new Token(TokenKind.ID, "_PrintStream", sp);¶		Identifier id2 = new Identifier(t2);¶		id2.decl = cd1;¶		ClassType ct1 = new ClassType(id2, sp);¶		FieldDecl fd2 = new FieldDecl(false, true, ct1, "out", sp);¶		fl2.add(fd2);¶		ClassDecl cd2 = new ClassDecl("System", fl2, ml2, sp);¶		¶		FieldDeclList fl3 = new FieldDeclList();¶		MethodDeclList ml3 = new MethodDeclList();¶		ClassDecl cd3 = new ClassDecl("String", fl3, ml3, sp);¶		¶		table.enter(cd1);¶		table.enter(cd2);¶		table.enter(cd3);¶		¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			table.enter(cd);¶		}¶		¶		for (ClassDecl cd: prog.classDeclList) {¶			cd.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitClassDecl(ClassDecl cd, Object arg) {¶		// TODO Auto-generated method stub¶		ClassDecl currentClass = cd;¶		¶		// add members so all fields and methods are visible¶		table.openScope();¶		for(FieldDecl fd: cd.fieldDeclList) {¶			table.enter(fd);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			table.enter(md);¶		}¶		¶		// visit all members¶		for(FieldDecl fd: cd.fieldDeclList) {¶			fd.visit(this, null);¶		}¶		for(MethodDecl md: cd.methodDeclList) {¶			md.visit(this, null);¶		}¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitFieldDecl(FieldDecl fd, Object arg) {¶		// TODO Auto-generated method stub¶		fd.type.visit(this, null);¶		return null;¶	}¶¶	@Override¶	public Object visitMethodDecl(MethodDecl md, Object arg) {¶		// TODO Auto-generated method stub¶		md.type.visit(this, null);¶		table.openScope();¶		for(ParameterDecl pd: md.parameterDeclList) {¶			pd.visit(this, null);¶		}¶		table.openScope();¶		for(Statement st: md.statementList) {¶			st.visit(this, null);¶		}¶		table.closeScope();¶		table.closeScope();¶		return null;¶	}¶¶	@Override¶	public Object visitParameterDecl(ParameterDecl pd, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVarDecl(VarDecl decl, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBaseType(BaseType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitClassType(ClassType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitArrayType(ArrayType type, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBlockStmt(BlockStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitAssignStmt(AssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxAssignStmt(IxAssignStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallStmt(CallStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitReturnStmt(ReturnStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIfStmt(IfStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitWhileStmt(WhileStmt stmt, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitRefExpr(RefExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIxExpr(IxExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitCallExpr(CallExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitThisRef(ThisRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdRef(IdRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitQRef(QualRef ref, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIdentifier(Identifier id, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitOperator(Operator op, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitIntLiteral(IntLiteral num, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶¶	@Override¶	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {¶		// TODO Auto-generated method stub¶		return null;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="3262" _type="MoveCaretCommand" caretOffset="652" date="Mon Apr 18 21:37:31 EDT 2022" docOffset="809" starttimestamp="1650226882502" timestamp="105368602" />
  <Command __id="3263" _type="MoveCaretCommand" caretOffset="621" date="Mon Apr 18 21:37:31 EDT 2022" docOffset="778" starttimestamp="1650226882502" timestamp="105368903" />
  <Command __id="3264" _type="MoveCaretCommand" caretOffset="579" date="Mon Apr 18 21:37:31 EDT 2022" docOffset="736" starttimestamp="1650226882502" timestamp="105369213" />
  <Command __id="3265" _type="MoveCaretCommand" caretOffset="490" date="Mon Apr 18 21:37:32 EDT 2022" docOffset="647" starttimestamp="1650226882502" timestamp="105369504" />
  <Command __id="3267" _type="SelectTextCommand" caretOffset="4161" date="Mon Apr 18 21:37:32 EDT 2022" end="4161" start="4151" starttimestamp="1650226882502" timestamp="105370389" />
  <Command __id="3269" _type="MoveCaretCommand" caretOffset="490" date="Mon Apr 18 21:37:34 EDT 2022" docOffset="647" starttimestamp="1650226882502" timestamp="105372260" />
  <Command __id="3270" _type="MoveCaretCommand" caretOffset="618" date="Mon Apr 18 21:37:35 EDT 2022" docOffset="775" starttimestamp="1650226882502" timestamp="105372895" />
  <Command __id="3272" _type="MoveCaretCommand" caretOffset="5396" date="Mon Apr 18 21:37:40 EDT 2022" docOffset="5396" starttimestamp="1650226882502" timestamp="105378135" />
  <Command __id="3273" _type="MoveCaretCommand" caretOffset="5008" date="Mon Apr 18 21:37:41 EDT 2022" docOffset="5008" starttimestamp="1650226882502" timestamp="105378981" />
  <Command __id="3274" _type="MoveCaretCommand" caretOffset="5008" date="Mon Apr 18 21:37:41 EDT 2022" docOffset="5008" starttimestamp="1650226882502" timestamp="105378981" />
  <Command __id="3275" _type="MoveCaretCommand" caretOffset="4979" date="Mon Apr 18 21:37:41 EDT 2022" docOffset="4979" starttimestamp="1650226882502" timestamp="105379285" />
  <Command __id="3276" _type="MoveCaretCommand" caretOffset="4979" date="Mon Apr 18 21:37:41 EDT 2022" docOffset="4979" starttimestamp="1650226882502" timestamp="105379285" />
  <Command __id="3277" _type="MoveCaretCommand" caretOffset="4980" date="Mon Apr 18 21:37:42 EDT 2022" docOffset="4980" starttimestamp="1650226882502" timestamp="105379653" />
  <Command __id="3278" _type="MoveCaretCommand" caretOffset="4980" date="Mon Apr 18 21:37:42 EDT 2022" docOffset="4980" starttimestamp="1650226882502" timestamp="105379661" />
  <Command __id="3280" _type="InsertStringCommand" date="Mon Apr 18 21:37:43 EDT 2022" starttimestamp="1650226882502" timestamp="105380886" timestamp2="105380886">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="3281" _type="InsertStringCommand" date="Mon Apr 18 21:37:43 EDT 2022" starttimestamp="1650226882502" timestamp="105380886" timestamp2="105380886">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="3283" _type="InsertStringCommand" date="Mon Apr 18 21:37:43 EDT 2022" starttimestamp="1650226882502" timestamp="105381140" timestamp2="105381140">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="3284" _type="InsertStringCommand" date="Mon Apr 18 21:37:43 EDT 2022" starttimestamp="1650226882502" timestamp="105381140" timestamp2="105381140">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="3286" _type="InsertStringCommand" date="Mon Apr 18 21:37:43 EDT 2022" starttimestamp="1650226882502" timestamp="105381309" timestamp2="105381309">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="3287" _type="InsertStringCommand" date="Mon Apr 18 21:37:43 EDT 2022" starttimestamp="1650226882502" timestamp="105381309" timestamp2="105381309">
    <data><![CDATA[/]]></data>
  </Command>
  <Command __id="3289" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105381794" timestamp2="105381794">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3290" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105381794" timestamp2="105381794">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3292" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105381888" timestamp2="105381888">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="3293" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105381888" timestamp2="105381888">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="3295" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105382173" timestamp2="105382173">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="3296" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105382173" timestamp2="105382173">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="3298" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105382273" timestamp2="105382273">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3299" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105382273" timestamp2="105382273">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3301" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105382473" timestamp2="105382473">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="3302" _type="InsertStringCommand" date="Mon Apr 18 21:37:44 EDT 2022" starttimestamp="1650226882502" timestamp="105382473" timestamp2="105382473">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="3304" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382542" timestamp2="105382542">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="3305" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382542" timestamp2="105382542">
    <data><![CDATA[k]]></data>
  </Command>
  <Command __id="3307" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382643" timestamp2="105382643">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3308" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382643" timestamp2="105382643">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3310" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382759" timestamp2="105382759">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="3311" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382759" timestamp2="105382759">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="3313" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382828" timestamp2="105382828">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3314" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382828" timestamp2="105382828">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3316" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382997" timestamp2="105382997">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="3317" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105382997" timestamp2="105382997">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="3319" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383113" timestamp2="105383113">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="3320" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383113" timestamp2="105383113">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="3322" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383175" timestamp2="105383175">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="3323" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383175" timestamp2="105383175">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="3325" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383328" timestamp2="105383328">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="3326" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383328" timestamp2="105383328">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="3328" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383460" timestamp2="105383460">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3329" _type="InsertStringCommand" date="Mon Apr 18 21:37:45 EDT 2022" starttimestamp="1650226882502" timestamp="105383460" timestamp2="105383460">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="3331" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105383692" timestamp2="105383692">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="3332" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105383692" timestamp2="105383692">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="3334" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105384176" timestamp2="105384176">
    <data><![CDATA[y]]></data>
  </Command>
  <Command __id="3335" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105384176" timestamp2="105384176">
    <data><![CDATA[y]]></data>
  </Command>
  <Command __id="3337" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105384362" timestamp2="105384362">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="3338" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105384362" timestamp2="105384362">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="3340" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105384478" timestamp2="105384478">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3341" _type="InsertStringCommand" date="Mon Apr 18 21:37:46 EDT 2022" starttimestamp="1650226882502" timestamp="105384478" timestamp2="105384478">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="3342" _type="MoveCaretCommand" caretOffset="5056" date="Mon Apr 18 21:37:48 EDT 2022" docOffset="5056" starttimestamp="1650226882502" timestamp="105385595" />
  <Command __id="3343" _type="MoveCaretCommand" caretOffset="5056" date="Mon Apr 18 21:37:48 EDT 2022" docOffset="5056" starttimestamp="1650226882502" timestamp="105385597" />
  <Command __id="3344" _type="MoveCaretCommand" caretOffset="5230" date="Mon Apr 18 21:37:49 EDT 2022" docOffset="5230" starttimestamp="1650226882502" timestamp="105386750" />
  <Command __id="3345" _type="MoveCaretCommand" caretOffset="5230" date="Mon Apr 18 21:37:49 EDT 2022" docOffset="5230" starttimestamp="1650226882502" timestamp="105386750" />
  <Command __id="3346" _type="MoveCaretCommand" caretOffset="5056" date="Mon Apr 18 21:37:50 EDT 2022" docOffset="5056" starttimestamp="1650226882502" timestamp="105387845" />
  <Command __id="3347" _type="MoveCaretCommand" caretOffset="5056" date="Mon Apr 18 21:37:50 EDT 2022" docOffset="5056" starttimestamp="1650226882502" timestamp="105387845" />
  <Command __id="3348" _type="MoveCaretCommand" caretOffset="5334" date="Mon Apr 18 21:37:51 EDT 2022" docOffset="5334" starttimestamp="1650226882502" timestamp="105389437" />
  <Command __id="3349" _type="MoveCaretCommand" caretOffset="5334" date="Mon Apr 18 21:37:51 EDT 2022" docOffset="5334" starttimestamp="1650226882502" timestamp="105389445" />
  <Command __id="3350" _type="MoveCaretCommand" caretOffset="5435" date="Mon Apr 18 21:37:52 EDT 2022" docOffset="5435" starttimestamp="1650226882502" timestamp="105389709" />
  <Command __id="3351" _type="MoveCaretCommand" caretOffset="5435" date="Mon Apr 18 21:37:52 EDT 2022" docOffset="5435" starttimestamp="1650226882502" timestamp="105389709" />
  <Command __id="3352" _type="MoveCaretCommand" caretOffset="5429" date="Mon Apr 18 21:37:52 EDT 2022" docOffset="5429" starttimestamp="1650226882502" timestamp="105390077" />
  <Command __id="3353" _type="MoveCaretCommand" caretOffset="5429" date="Mon Apr 18 21:37:52 EDT 2022" docOffset="5429" starttimestamp="1650226882502" timestamp="105390077" />
  <Command __id="3354" _type="ShellCommand" date="Mon Apr 18 21:38:04 EDT 2022" starttimestamp="1650226882502" timestamp="105402040" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3355" _type="ShellCommand" date="Mon Apr 18 23:21:41 EDT 2022" starttimestamp="1650226882502" timestamp="111618745" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3356" _type="ShellCommand" date="Mon Apr 18 23:21:42 EDT 2022" starttimestamp="1650226882502" timestamp="111619772" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3357" _type="ShellCommand" date="Mon Apr 18 23:21:42 EDT 2022" starttimestamp="1650226882502" timestamp="111619858" type="ECLIPSE_MINIMIZED" />
  <Command __id="3358" _type="ShellCommand" date="Wed Apr 20 03:52:07 EDT 2022" starttimestamp="1650226882502" timestamp="214244826" type="ECLIPSE_MINIMIZED" />
  <Command __id="3359" _type="ShellCommand" date="Wed Apr 20 18:32:35 EDT 2022" starttimestamp="1650226882502" timestamp="267072704" type="ECLIPSE_MAXIMIZED" />
  <Command __id="3360" _type="ShellCommand" date="Wed Apr 20 18:32:37 EDT 2022" starttimestamp="1650226882502" timestamp="267074683" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3361" _type="ShellCommand" date="Wed Apr 20 18:32:38 EDT 2022" starttimestamp="1650226882502" timestamp="267076257" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3362" _type="ShellCommand" date="Wed Apr 20 18:32:38 EDT 2022" starttimestamp="1650226882502" timestamp="267076368" type="ECLIPSE_MINIMIZED" />
  <Command __id="3363" _type="ShellCommand" date="Wed Apr 20 18:32:39 EDT 2022" starttimestamp="1650226882502" timestamp="267076755" type="ECLIPSE_MAXIMIZED" />
  <Command __id="3364" _type="ShellCommand" date="Wed Apr 20 18:32:39 EDT 2022" starttimestamp="1650226882502" timestamp="267076805" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3365" _type="ShellCommand" date="Wed Apr 20 18:32:40 EDT 2022" starttimestamp="1650226882502" timestamp="267077845" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="3366" _type="ShellCommand" date="Wed Apr 20 18:32:40 EDT 2022" starttimestamp="1650226882502" timestamp="267077954" type="ECLIPSE_MINIMIZED" />
  <Command __id="3367" _type="ShellCommand" date="Wed Apr 20 20:13:00 EDT 2022" starttimestamp="1650226882502" timestamp="273097875" type="ECLIPSE_MAXIMIZED" />
  <Command __id="3368" _type="ShellCommand" date="Wed Apr 20 20:13:03 EDT 2022" starttimestamp="1650226882502" timestamp="273101120" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="3369" _type="ShellCommand" date="Wed Apr 20 20:13:04 EDT 2022" starttimestamp="1650226882502" timestamp="273101574" type="ECLIPSE_LOST_FOCUS" />
